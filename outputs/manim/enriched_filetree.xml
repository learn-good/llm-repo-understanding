<repository name="manim">
  <file name="LICENSE.md"><file-summary>This file contains the MIT License for the Manim project. The license grants permission to use, modify, and distribute the software freely, while providing copyright protection to 3Blue1Brown LLC (2020-2023). The license includes standard MIT License terms including:
        - Rights to use, copy, modify, merge, publish, distribute, sublicense, and sell
        - Requirement to include the copyright notice in all copies
        - Disclaimer of warranty and liability
        - "As is" provision without any kind of warranty</file-summary></file>
  <file name="MANIFEST.in"><file-summary>This is a MANIFEST.in file that specifies which files should be included or excluded when building a Python package distribution. It contains two directives:
        1. 'graft manimlib' - includes all files under the manimlib directory
        2. 'recursive-exclude manimlib *.pyc *.DS_Store' - excludes Python compiled files (.pyc) and macOS system files (.DS_Store) from the manimlib directory and its subdirectories</file-summary></file>
  <file name="README.md"><file-summary>This is the main README file for the Manim animation engine repository. It contains:
        
        1. Project Overview:
        - Describes Manim as an engine for programmatic animations, primarily for math videos
        - Explains there are two versions: the original 3Blue1Brown version and a community edition
        - Shows project status badges for PyPI, license, Reddit, Discord, and documentation
        
        2. Installation Instructions:
        - Warns about differences between ManimGL and ManimCommunity versions
        - Lists system requirements (Python 3.7+, FFmpeg, OpenGL, LaTeX)
        - Provides installation steps for:
          * Direct installation via pip
          * Windows-specific installation
          * Mac OSX installation
          * Anaconda installation
        
        3. Usage Guide:
        - Basic command line usage with example command
        - Lists important CLI flags and their functions
        - References to example scenes and configuration options
        - Points to custom_config.yml for customization
        
        4. Documentation References:
        - Links to official documentation
        - Mentions Chinese documentation version
        - References to additional resources from manim-kindergarten
        
        5. Contributing Guidelines:
        - Welcomes contributions
        - Directs to community edition for more active development
        
        6. License Information:
        - States the project is under MIT license</file-summary></file>
  <directory name="docs">
    <directory-summary>The "docs" directory contains the complete documentation system for the Manim animation engine. It is structured as a Sphinx-based documentation project with the following key components:

1. Build Configuration:
- Makefile and make.bat: Build scripts for Unix and Windows systems
- requirements.txt: Lists documentation dependencies including Sphinx, furo theme, and extensions
- example.py: Contains sample Manim animations for documentation

2. Source Documentation (/source/):
- Getting Started: Comprehensive guides for installation, quickstart, configuration
- Documentation: Technical reference for constants, configuration, and components
- Development: Contributing guidelines and project background
- Custom Sphinx extension (manim_example_ext.py) for rendering Manim examples

3. Structure:
- Uses Sphinx with the Furo theme for clean, modern documentation
- Organized hierarchically with clear separation between beginner guides and technical docs
- Supports multiple languages (links to Chinese version)
- Includes interactive examples and comprehensive configuration options

The directory serves as a complete documentation ecosystem, providing both user guides and technical reference material. While some sections (particularly in /documentation/) are marked as TODO, the getting started guides and core configuration documentation are well-developed. The build system supports both local development and automated builds for web hosting.</directory-summary><file name="Makefile"><declarations>
        SPHINXOPTS    ?=
        SPHINXBUILD   ?= sphinx-build
        SOURCEDIR     = source
        BUILDDIR      = build
    </declarations>
    <dependencies>
        <external>
            sphinx-build
        </external>
        <internal />
    </dependencies>
    <function-defs>
        <function name="help">
            <description>
                Default target that displays Sphinx help information
            </description>
            <args />
            <returns />
            <side-effects>
                Executes sphinx-build with help flag and passes source/build directories and options
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="%">
            <description>
                Catch-all target that routes all unknown targets to Sphinx
            </description>
            <args>
                $@ - represents the target name
            </args>
            <returns />
            <side-effects>
                Executes sphinx-build with the target mode and passes source/build directories and options
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a minimal Makefile for Sphinx documentation generation. It defines basic variables for Sphinx building configuration and provides two main targets: a help target that displays available commands, and a catch-all target that routes unknown commands to Sphinx. The file allows for command-line overrides of Sphinx options and build command.
    </file-summary></file>
    <file name="example.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            <dependency>manimlib</dependency>
        </external>
        <internal>
            
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Creates an animation showing transformation of a square into a circle
            </description>
            <args>
                self - instance of SquareToCircle class
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and plays animations in the scene
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="construct">
            <description>
                Creates an animation demonstrating various transformations of a circle
            </description>
            <args>
                self - instance of SquareToCircleEmbed class
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and plays animations in the scene
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains two scene classes for Manim animations: SquareToCircle and SquareToCircleEmbed. The first class demonstrates a simple transformation from a square to a circle, while the second class shows more complex animations with a circle including stretching, rotating, scaling, and applying complex functions. The file serves as an example of basic Manim usage and animation capabilities.
    </file-summary></file>
    <file name="make.bat"><declarations>
        <variable>SPHINXBUILD=sphinx-build</variable>
        <variable>SOURCEDIR=source</variable>
        <variable>BUILDDIR=build</variable>
    </declarations>
    <dependencies>
        <external>
            <dependency>Sphinx</dependency>
        </external>
        <internal />
    </dependencies>
    <function-defs>
        <function name="help">
            <description>
                Displays Sphinx help information using the sphinx-build command
            </description>
            <args />
            <returns />
            <side-effects>
                <effect>Outputs help information to console</effect>
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a Windows batch file for building Sphinx documentation. It checks for the presence of sphinx-build, sets up necessary environment variables, and provides commands for building documentation. The script includes error handling for missing Sphinx installation and provides a help option. It uses pushd/popd to maintain directory context and supports various Sphinx build options through command-line arguments.
    </file-summary></file>
    <file name="requirements.txt"><file-summary>This is a Python requirements.txt file that specifies external package dependencies needed for documentation. It includes:
        - Sphinx v3.0.3: A documentation generator
        - sphinx-copybutton: A Sphinx extension that adds copy buttons to code blocks
        - furo v2020.10.5b9: A clean documentation theme for Sphinx
        - Jinja2: A template engine for Python
        
        The file uses pip's requirements format, with some packages having specific versions pinned (using ==) while others allow any compatible version.</file-summary></file>
    <directory name="source">
      <directory-summary>The "source" directory is the core documentation root for the Manim animation engine, containing all source files and structure for building the project's documentation using Sphinx. It is organized into three main sections:

1. Getting Started (/getting_started/):
- Comprehensive onboarding documentation including installation, quickstart guides, configuration, and examples
- Structured to guide new users from installation through basic usage

2. Documentation (/documentation/):
- Technical documentation of Manim's components and systems
- Contains detailed documentation for constants and configuration
- Includes placeholder directories for future documentation of core components (animation, camera, mobject, scene, shaders, utils)

3. Development (/development/):
- Information about the project's development process
- Contributing guidelines and changelog
- Background information about different Manim versions

The directory includes essential configuration files:
- conf.py: Sphinx configuration file setting up the documentation build process
- manim_example_ext.py: Custom Sphinx extension for rendering Manim examples
- index.rst: Main documentation landing page and navigation structure

The documentation uses the Furo theme and includes various Sphinx extensions for features like math rendering, code documentation, and interactive examples. While some sections are well-developed (particularly the getting started guides), others are marked as TODO, indicating ongoing documentation development.</directory-summary><file name="conf.py"><declarations>
        project = 'manim'
        copyright = '- This document has been placed in the public domain.'
        author = 'TonyCrane'
        release = ''
        extensions = [list of sphinx extensions]
        autoclass_content = 'both'
        mathjax_path = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
        templates_path = ['_templates']
        source_suffix = '.rst'
        master_doc = 'index'
        pygments_style = 'default'
        html_static_path = ["_static"]
        html_css_files = [list of CSS files]
        html_theme = 'furo'
        html_favicon = '_static/icon.png'
        html_logo = '../../logo/transparent_graph.png'
        html_theme_options = {dictionary}
    </declarations>
    <dependencies>
        <external>
            sphinx.ext.todo
            sphinx.ext.githubpages
            sphinx.ext.mathjax
            sphinx.ext.intersphinx
            sphinx.ext.autodoc
            sphinx.ext.coverage
            sphinx.ext.napoleon
            sphinx_copybutton
            os
            sys
        </external>
        <internal>
            <filepath>
                manim_example_ext
            </filepath>
            <description>
                Custom Sphinx extension for Manim documentation
            </description>
        </internal>
    </dependencies>
    <function-defs>
    </function-defs>
    <file-summary>
        This is a Sphinx configuration file for the Manim documentation. It sets up various documentation settings including project metadata, extensions, theme configuration, and path settings. The file modifies the Python path to include the necessary directories, configures Sphinx extensions for features like math rendering and code documentation, and sets up the Furo theme with custom CSS and styling options.
    </file-summary></file>
      <directory name="development">
        <directory-summary>The development directory contains core documentation files related to Manim's development and contribution processes. It serves two main purposes:

1. Providing context about Manim's different versions and implementations through the about.rst file, which explains the distinction between the 3b1b/manim (Grant Sanderson's version) and ManimCommunity/manim versions, along with their respective features and rendering approaches.

2. Guiding potential contributors through the contributing.rst file, which provides comprehensive instructions on how to participate in the project through various means (code contributions, documentation improvements, bug reports, content sharing) and includes detailed steps for local documentation setup.

This directory is essential for new contributors and developers to understand the project's structure and how they can effectively participate in its development. The files within serve as the primary reference for anyone looking to contribute to or better understand Manim's development ecosystem.</directory-summary><file name="about.rst"><file-summary>This is a documentation file that provides an overview of Manim, an animation engine for explanatory math videos. The file explains that there are two main versions of Manim:

        1. 3b1b/manim - Maintained by Grant Sanderson, using OpenGL and GLSL for GPU rendering, offering higher efficiency and real-time rendering capabilities.

        2. ManimCommunity/manim - Maintained by the Manim Community Dev Team, featuring multiple backend rendering and better documentation.

        The file also explains that this documentation is specifically for the 3b1b/manim version, created by TonyCrane. It mentions that the documentation uses a Sphinx extension called "manim_example_ext" which references the ManimCommunity documentation, and directs readers to the contributing documentation for those interested in contributing.</file-summary></file>
        <file name="changelog.rst" ignore="true" />
        <file name="contributing.rst"><file-summary>This is a documentation file that outlines how to contribute to the manim project. It covers several ways to contribute:
        1. Contributing to source code through pull requests
        2. Contributing to documentation
        3. Reporting bugs through issues
        4. Sharing content created with manim in discussions
        5. Sharing suggestions and ideas in discussions

        The file also includes detailed instructions for building the documentation locally, including:
        - Cloning the repository
        - Installing documentation dependencies via pip
        - Building the HTML documentation using make
        - Location of the output documentation files

        The document emphasizes the importance of following templates when submitting issues or pull requests and encourages community participation through various GitHub discussion categories.</file-summary></file>
      </directory>
      <directory name="documentation">
        <directory-summary>This directory contains the core documentation structure for Manim's major components and functionality. It includes several subdirectories and files that cover different aspects of the framework:

1. Main Documentation Files:
- constants.rst: Documents all important constant values used throughout Manim
- custom_config.rst: Explains configuration options for directories, TeX, styling, windows, and video settings

2. Component-specific Subdirectories (currently placeholder/TODO):
- animation/: Will document the animation system
- camera/: Will cover camera functionality and rendering
- mobject/: Will explain the Mathematical Object system
- scene/: Will detail scene creation and management
- shaders/: Will document shader capabilities
- utils/: Will cover utility functions

Most subdirectories currently contain only placeholder index.rst files marked as "TODO", indicating that significant portions of the documentation are still under development. The directory structure suggests a comprehensive documentation plan that will eventually cover all major aspects of Manim's functionality, though only the configuration and constants documentation is currently complete.</directory-summary><directory name="animation">
          <directory-summary>This directory appears to be a placeholder location for documentation about Manim's animation system. Currently, it only contains an empty index.rst file marked as "TODO", indicating that comprehensive documentation about animations in Manim still needs to be written. The directory is intended to eventually house documentation that explains how animations work in Manim, including their implementation, usage, and various animation types available to users.</directory-summary><file name="index.rst"><file-summary>This is a placeholder documentation file for the Animation section. The file only contains a title "Animation (TODO)" and appears to be a stub that needs to be filled with actual documentation content about animations in Manim.</file-summary></file>
        </directory>
        <directory name="camera">
          <directory-summary>This directory contains documentation files related to Manim's Camera component. Currently, it only has a placeholder index.rst file marked as "TODO", indicating that comprehensive documentation for the Camera functionality is planned but has not yet been written. The Camera is an important component in Manim that handles how scenes and animations are rendered and viewed, but its documentation structure is still under development in this location.</directory-summary><file name="index.rst"><file-summary>This is a placeholder documentation file for the Camera component in Manim. The file currently only contains a header "Camera (TODO)" indicating that documentation for this section is planned but not yet implemented.</file-summary></file>
        </directory>
        <file name="constants.rst"><declarations>
        
        ASPECT_RATIO = 16.0 / 9.0
        FRAME_HEIGHT = 8.0
        FRAME_WIDTH = FRAME_HEIGHT * ASPECT_RATIO
        FRAME_Y_RADIUS = FRAME_HEIGHT / 2
        FRAME_X_RADIUS = FRAME_WIDTH / 2
        DEFAULT_PIXEL_HEIGHT = 1080
        DEFAULT_PIXEL_WIDTH = 1920
        DEFAULT_FPS = 30

        
        SMALL_BUFF = 0.1
        MED_SMALL_BUFF = 0.25
        MED_LARGE_BUFF = 0.5
        LARGE_BUFF = 1
        DEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF
        DEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF

        
        DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0
        DEFAULT_WAIT_TIME = 1.0

        
        ORIGIN, UP, DOWN, RIGHT, LEFT, IN, OUT
        X_AXIS, Y_AXIS, Z_AXIS
        UL, UR, DL, DR
        TOP, BOTTOM, LEFT_SIDE, RIGHT_SIDE

        
        PI, TAU, DEGREES

        
        NORMAL, ITALIC, OBLIQUE, BOLD

        
        DEFAULT_STROKE_WIDTH = 4
    </declarations>
    <dependencies>
        <external>
            numpy (imported as np)
        </external>
        <internal>
        </internal>
    </dependencies>
    <file-summary>
        This is a documentation file that explains the constants defined in the manimlib/constants.py file. It covers various categories of constants including:
        - Frame and pixel dimensions
        - Buffer sizes for spacing
        - Default run times and wait times
        - Coordinate system constants
        - Mathematical constants
        - Text style constants
        - Stroke width settings
        - Color definitions (with visual previews)
        
        The file provides comprehensive documentation of the constant values used throughout the Manim library, serving as a reference for developers using the framework.
    </file-summary></file>
        <file name="custom_config.rst"><file-summary>This documentation file describes various configuration options for Manim. It covers:
        
        1. Directory configurations:
        - mirror_module_path: Controls output folder structure
        - output: Path for saving videos and images
        - raster_images: Directory for storing jpg/png/gif files
        - vector_images: Directory for svg/xdv files
        - sounds: Directory for wav/mp3 files
        - temporary_storage: Directory for cache files

        2. TeX configurations:
        - executable: LaTeX compiler selection
        - template_file: LaTeX template location
        - intermediate_filetype: Type of vector file generated
        - text_to_replace: Template replacement text

        3. Style settings:
        - font: Default text font
        - text_alignment: Default LaTeX alignment
        - background_color: Default background color

        4. Window settings:
        - window_position: Preview window position
        - window_monitor: Monitor selection
        - full_screen: Fullscreen toggle

        5. Video settings:
        - break_into_partial_movies: Option to split scenes
        - camera_resolutions: Various resolution presets (low/medium/high/ultra_high)
        - fps: Frame rate setting

        The file includes detailed examples of directory structures and explains each configuration option's purpose and effect.</file-summary></file>
        <directory name="mobject">
          <directory-summary>This directory contains documentation files related to Manim's Mobject (Mathematical Object) system, which is a core component of the Manim animation engine. Currently, the directory only contains a placeholder index file that needs to be expanded with proper documentation. The presence of a TODO marker indicates this is a planned documentation section that will eventually describe Mobject's functionality, usage, and implementation details. Mobjects are fundamental building blocks in Manim used to create and manipulate mathematical objects and animations, so this documentation section will be important for users once completed.</directory-summary><file name="index.rst"><file-summary>This is a placeholder documentation index file for the Mobject section. The file only contains a title "Mobject (TODO)" and appears to be a stub that needs to be filled out with actual documentation content about Manim's Mobject system. The "(TODO)" marker indicates this documentation section is incomplete and needs to be written.</file-summary></file>
        </directory>
        <directory name="scene">
          <directory-summary>This directory contains documentation for Manim's Scene module, though it is currently a work in progress. The single index.rst file present is a placeholder that only contains a "Scene (TODO)" title, indicating that comprehensive documentation for the Scene functionality is planned but not yet implemented. The Scene module is a fundamental part of Manim's architecture, as scenes are the basic containers for animations and mathematical objects in Manim, making this an important documentation section that needs to be completed.</directory-summary><file name="index.rst"><file-summary>This is a placeholder documentation file for the Scene module in Manim. The file currently only contains a title "Scene (TODO)" indicating that the documentation content is yet to be written. This appears to be part of the Manim documentation structure under docs/source/documentation/scene/.</file-summary></file>
        </directory>
        <directory name="shaders">
          <directory-summary>This directory contains documentation related to shaders in Manim, but is currently a placeholder. The single index.rst file present indicates that shader documentation is planned for future implementation but has not yet been written. Shaders are typically used for custom rendering effects and graphics processing, suggesting this directory will eventually contain documentation about Manim's shader capabilities and usage.</directory-summary><file name="index.rst"><file-summary>This is a placeholder documentation file for shaders in Manim. The file currently only contains a header "Shaders (TODO)" indicating that shader documentation is planned but not yet implemented.</file-summary></file>
        </directory>
        <directory name="utils">
          <directory-summary>This is a documentation directory for utility functions in Manim, currently containing only a placeholder index file. The directory is intended to house documentation for various utility functions and helper methods used throughout Manim, but is currently marked as TODO and awaiting proper documentation content. The presence of just a placeholder index suggests this is an area of the documentation that needs to be developed further to document Manim's utility functions.</directory-summary><file name="index.rst"><file-summary>This is a placeholder documentation index file for the utils section. The file only contains a title "Utils (TODO)" indicating it is a work in progress or placeholder for future utility documentation. The file is located in the manim documentation source directory under utils.</file-summary></file>
        </directory>
      </directory>
      <directory name="getting_started">
        <directory-summary>The "getting_started" directory contains comprehensive documentation files that serve as the initial entry point for new Manim users. It provides a complete onboarding experience through six key documentation files:

1. installation.rst - Provides detailed installation instructions for all major operating systems, including system requirements and different installation methods.

2. quickstart.rst - Offers a practical introduction to creating basic animations, perfect for first-time users wanting to create their first Manim scene.

3. configuration.rst - Explains how to configure Manim through both command-line options and configuration files, helping users customize their setup.

4. example_scenes.rst - Contains a rich collection of example scenes demonstrating various Manim features, serving as both tutorial and reference material.

5. structure.rst - Provides a technical overview of Manim's architecture, including directory structure and class inheritance, helpful for developers and advanced users.

6. whatsnew.rst - Keeps users informed about recent changes and updates to the library, helping them adapt to new versions.

These files are designed to be read in sequence (installation → quickstart → configuration → examples) for new users, while also serving as standalone reference documentation for specific topics. The directory forms the foundation of Manim's user documentation, making it essential for both beginners and experienced users.</directory-summary><file name="configuration.rst"><file-summary>This documentation file covers two main topics related to Manim configuration:

        1. Command Line Interface (CLI):
        - Explains the basic command format: manimgl/manim-render &lt;code&gt;.py &lt;Scene&gt; &lt;flags&gt;
        - Details commonly used flags like -w (write), -o (write and open), -s (skip to end)
        - Provides a comprehensive table of all supported CLI flags with their abbreviations and functions
        - Includes flags for quality control, display options, file handling, and rendering configurations

        2. Custom Configuration:
        - Explains how to use custom_config.yml for permanent configuration changes
        - Describes the configuration file hierarchy and how multiple custom_config.yml files can be used in different directories
        - Details how to manually specify a configuration file using the --config_file flag
        - References additional documentation for detailed configuration options</file-summary></file>
        <file name="example_scenes.rst"><file-summary>This is a documentation file containing example scenes for the Manim library. It includes several detailed examples demonstrating different features and capabilities:

        1. InteractiveDevelopment - Shows basic shape creation and interactive development features
        2. AnimatingMethods - Demonstrates how to animate method calls on objects
        3. TextExample - Shows text creation and formatting capabilities
        4. TexTransformExample - Demonstrates LaTeX transformations and animations
        5. UpdatersExample - Shows how to use updater functions for dynamic animations
        6. CoordinateSystemExample - Demonstrates coordinate system and graphing features
        7. GraphExample - Shows how to create and animate mathematical graphs
        8. SurfaceExample - Demonstrates 3D surface creation and manipulation
        9. OpeningManimExample - A comprehensive example combining multiple features

        Each example includes:
        - Detailed code samples
        - Explanatory comments
        - Links to video demonstrations
        - Descriptions of new classes and methods introduced
        
        The file serves as a tutorial and reference for common Manim usage patterns and features.</file-summary></file>
        <file name="installation.rst"><file-summary>This is an installation guide for Manim that covers:
        
        1. System Requirements:
           - Python 3.7 or higher
           - FFmpeg
           - OpenGL (via PyOpenGL)
           - LaTeX (optional)
           - Pango (Linux only)

        2. Installation instructions for FFmpeg on different platforms:
           - Windows (using Chocolatey)
           - Linux (using apt)
           - MacOS (via ZIP download)

        3. Direct installation methods:
           - Using pip to install manimgl
           - Instructions for development installation from source
           - Specific Windows installation steps including LaTeX and FFmpeg setup

        4. Anaconda installation method:
           - Creating and setting up a conda environment
           - Installing dependencies
           - Installing manim from source

        The document provides command-line instructions and verification steps for each installation method, ensuring users can properly set up Manim regardless of their operating system or preferred installation method.</file-summary></file>
        <file name="quickstart.rst"><file-summary>This is a quickstart guide for Manim that covers:
        1. Basic setup and file structure for creating Manim scenes
        2. Creating a simple scene that draws a circle
        3. Adding animations to transform shapes (square to circle)
        4. Using interactive mode with the embed() function
        
        The guide walks through:
        - Basic file structure and setup
        - Creating basic shapes and setting their properties
        - Adding animations and transformations
        - Using the command line interface
        - Interactive mode usage and examples
        - Basic camera controls and keyboard shortcuts
        
        The document includes practical examples with both static images and animations, explaining each line of code in detail. It serves as an entry point for new users to understand the basic workflow of creating animations with Manim.</file-summary></file>
        <file name="structure.rst"><file-summary>This documentation file describes the overall structure of the Manim library. It contains three main sections:

        1. Manim's directory structure:
        - Provides a detailed tree view of the entire codebase
        - Explains the purpose of each directory and key files
        - Includes descriptions of major components like manimlib/, camera/, scene/, animation/, mobject/, shaders/, and utils/

        2. Inheritance structure:
        - References a diagram showing the class inheritance hierarchy of Manim
        - Includes a link to a detailed PDF and an embedded image showing the relationships between classes

        3. Manim execution process:
        - Contains a diagram illustrating the execution flow of Manim
        - Shows how the library processes and renders animations

        The file serves as a high-level overview and reference guide for understanding Manim's architecture and organization.</file-summary></file>
        <file name="whatsnew.rst"><file-summary>This is a documentation file detailing changes in a new version of manim. It covers major changes across several categories:

        1. Animation changes:
        - Updates to Fade animations
        - New animation types like FadeTransform
        - Changes to Rotating animations

        2. Camera changes:
        - Simplified camera system
        - Implementation of CameraFrame
        - Addition of light source functionality

        3. Mobject changes:
        - Updates to SVG handling
        - New Surface classes
        - Changes to coordinate systems
        - Updates to 3D objects
        - Modifications to various object properties and methods

        4. Scene changes:
        - Removal of specialized scene types
        - New interaction methods
        - State management additions

        5. Utils and Constants changes:
        - New utility functions
        - Updated color constants
        - Screen aspect ratio fixes

        The document serves as a reference guide for users transitioning to the new version, focusing on code-level changes that impact usage.</file-summary></file>
      </directory>
      <file name="index.rst"><file-summary>This is the main documentation index file for Manim, structured in RST format. It serves as the landing page and navigation hub for Manim's documentation. The file includes:
        
        1. A header with the Manim logo
        2. A brief introduction describing Manim as an animation engine for explanatory math videos
        3. A link to the Chinese version of the documentation
        4. Three main documentation sections organized as table of contents (toctree):
           - Getting Started: Covers installation, quickstart, configuration, examples, and structure
           - Documentation: Contains information about constants and custom configuration
           - Development: Includes changelog, contributing guidelines, and about section
        
        The file is primarily focused on organizing and structuring the documentation hierarchy rather than containing actual documentation content.</file-summary></file>
      <file name="manim_example_ext.py"><declarations>
        TEMPLATE = string containing HTML/Jinja2 template for rendering example output
    </declarations>
    <dependencies>
        <external>
            docutils
            jinja2
            os
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="visit">
            <description>
                Visitor function for skip_manim_node that calls visit_admonition
            </description>
            <args>
                self: object reference
                node: node to visit
                name: string, optional name parameter (defaults to empty string)
            </args>
            <returns>
            </returns>
            <side-effects>
                Calls visit_admonition on the provided node
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="depart">
            <description>
                Departure function for skip_manim_node that calls depart_admonition
            </description>
            <args>
                self: object reference
                node: node to depart from
            </args>
            <returns>
            </returns>
            <side-effects>
                Calls depart_admonition on the provided node
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="setup">
            <description>
                Sphinx extension setup function that registers the custom directive and node
            </description>
            <args>
                app: Sphinx application instance
            </args>
            <returns>
                dictionary: metadata about parallel read/write safety
            </returns>
            <side-effects>
                Adds skip_manim_node to app
                Adds ManimExampleDirective to app
                Sets global setup.app, setup.config, and setup.confdir
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements a Sphinx extension that provides a custom directive for including Manim examples in documentation. It defines a skip_manim_node class and ManimExampleDirective class that handle the rendering of example code and media (video/image) output using a Jinja2 template. The extension supports both video and image outputs and allows hiding the source code optionally.
    </file-summary></file>
    </directory>
  </directory>
  <file name="example_scenes.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            - manimlib
            - numpy
            - math
            - re
        </external>
        <internal>
            
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Main construction method used in multiple scene classes to create animations
            </description>
            <args>
                self - Scene instance
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Creates and plays animations in the scene
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    
                </handled>
                <unhandled>
                    
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="setup">
            <description>
                Setup method used in ControlsExample scene to initialize UI controls
            </description>
            <args>
                self - Scene instance
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Initializes UI control elements
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    
                </handled>
                <unhandled>
                    
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains example scenes demonstrating various Manim animation capabilities including:
        - Basic text and mathematical animations
        - Coordinate systems and graphing
        - 3D surfaces and texturing
        - Interactive development tools
        - UI controls and user interaction
        
        The file serves as a tutorial/reference for common Manim usage patterns through concrete examples.
    </file-summary></file>
  <directory name="logo">
    <directory-summary>This directory contains assets and code related to the Manim project's logo and branding materials. The main component is logo.py, which generates a mathematical visualization using Manim's animation capabilities. This visualization likely serves as the basis for the project's logo.

    The directory includes several PNG image files that appear to be different versions of the logo:
    - cropped.png
    - graph.png
    - transparent_graph.png
    - white_with_name.png
    - with_name.png
    - with_subtext.png

    The logo.py script defines a Thumbnail class that creates an animated mathematical visualization featuring function graphs, points, lines, and Riemann rectangles. It uses a custom blue color (NEW_BLUE) and includes several mathematical functions (func and rect) to generate the graphical elements.

    This directory serves as the central location for Manim's branding assets, providing both the source code to generate the logo animation and various pre-rendered versions of the logo for different use cases (with text, transparent background, etc.).</directory-summary><file name="cropped.png" text-readable="false" />
    <file name="graph.png" text-readable="false" />
    <file name="logo.py"><declarations>
        NEW_BLUE = "#68a8e1"
    </declarations>
    <dependencies>
        <external>
            manimlib.imports
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Main construction method for the Thumbnail class that calls show_function_graph
            </description>
            <args>
                self
            </args>
            <returns>
            </returns>
            <side-effects>
                Modifies the scene by calling show_function_graph
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="show_function_graph">
            <description>
                Creates and animates a complex mathematical visualization including function graphs, points, lines, and Riemann rectangles
            </description>
            <args>
                self
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and animates multiple visual elements in the scene
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="func">
            <description>
                Defines a polynomial function for graphing
            </description>
            <args>
                x: numeric
            </args>
            <returns>
                numeric - result of polynomial calculation
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="rect">
            <description>
                Defines a linear function for graphing
            </description>
            <args>
                x: numeric
            </args>
            <returns>
                numeric - result of linear calculation
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines a Thumbnail class that creates a mathematical visualization using the Manim library. It generates a complex animation featuring function graphs, points, lines, and Riemann rectangles, ultimately creating what appears to be a logo or thumbnail image for Manim. The visualization includes interactive elements like trackers and various geometric shapes that are animated together.
    </file-summary></file>
    <file name="transparent_graph.png" text-readable="false" />
    <file name="white_with_name.png" text-readable="false" />
    <file name="with_name.png" text-readable="false" />
    <file name="with_subtext.png" text-readable="false" />
  </directory>
  <directory name="manimlib">
    <directory-summary>The manimlib directory contains the core implementation of the Manim mathematical animation library. It provides a comprehensive framework for creating mathematical animations and visualizations through several key components:

1. Core Animation System:
- animation/ directory: Implements various animation types (transforms, fading, movement)
- mobject/ directory: Contains mathematical objects (shapes, text, graphs) that can be animated
- scene/ directory: Manages animation playback and rendering

2. Rendering Pipeline:
- camera/ directory: Handles scene capture and frame rendering
- shaders/ directory: Contains GLSL shaders for graphics rendering
- window.py: Manages display window and user interaction

3. Asset Management:
- utils/ directory: Provides utilities for file operations, math, colors, etc.
- config.py: Handles configuration management
- constants.py: Defines common constants used throughout the library

4. Interactive Features:
- event_handler/ directory: Implements event system for user interaction
- scene/interactive_scene.py: Provides interactive scene capabilities

5. Typography &amp; Text:
- mobject/svg/ directory: Handles SVG, text and LaTeX rendering
- tex_templates.yml: Defines LaTeX templates

The directory is designed to be used by:
1. Creating scenes that inherit from Scene class
2. Adding mobjects (mathematical objects) to scenes
3. Applying animations to those mobjects
4. Rendering the result to video or displaying interactively

The codebase makes heavy use of numpy for numerical operations, moderngl for graphics rendering, and provides extensive customization options through configuration files.</directory-summary><file name="__init__.py"><declarations>
        __version__ = pkg_resources.get_distribution("manimgl").version
    </declarations>
    <dependencies>
        <external>
            pkg_resources
            typing.TYPE_CHECKING
        </external>
        <internal>
            <filepath>
                manimlib/constants
                manimlib/window
                manimlib/animation/*
                manimlib/camera/camera
                manimlib/mobject/*
                manimlib/scene/*
                manimlib/utils/*
            </filepath>
            <description>
                This is the main initialization file that imports and exposes all the major components of the manim library including animations, mobjects (mathematical objects), scenes, and utility functions. It uses wildcard imports (*) to make all symbols from these modules available at the top level of the package.
            </description>
        </internal>
    </dependencies>
    <function-defs>
    </function-defs>
    <file-summary>
        This is the main __init__.py file for the manimlib package. It serves as the entry point for the library and handles:
        1. Version management using pkg_resources
        2. Type checking setup
        3. Importing and exposing all major components of the library including:
           - Animations
           - Camera functionality
           - Mathematical objects (Mobjects)
           - Scene management
           - Utility functions
        The file uses wildcard imports extensively to make all functionality available at the package level.
    </file-summary></file>
    <file name="__main__.py"><declarations>
    </declarations>
    <dependencies>
        <external>
        </external>
        <internal>
            <filepath>manimlib/__version__</filepath>
            <description>Imports version information for ManimGL</description>
            <filepath>manimlib/config</filepath>
            <description>Handles configuration and CLI argument parsing</description>
            <filepath>manimlib/extract_scene</filepath>
            <description>Handles scene extraction functionality</description>
            <filepath>manimlib/logger</filepath>
            <description>Provides logging functionality</description>
            <filepath>manimlib/utils/init_config</filepath>
            <description>Handles initialization of custom configurations</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Main entry point for the ManimGL application that handles configuration setup, scene extraction, and scene execution
            </description>
            <args>
            </args>
            <returns>
                None
            </returns>
            <side-effects>
                - Prints version information
                - Sets log level if specified
                - Initializes configuration
                - Extracts and runs scenes
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    - Potential exceptions from configuration parsing
                    - Potential exceptions from scene extraction and execution
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is the main entry point file for the ManimGL application. It sets up the environment by handling command-line arguments, configuration, and orchestrates the process of scene extraction and execution. The file includes version display, logging setup, and supports both default and custom configurations. It uses a standard Python script pattern with a main() function that's called when the script is run directly.
    </file-summary></file>
    <directory name="animation">
      <directory-summary>The manimlib/animation/animation directory contains the core animation system for the Manim mathematical animation library. This directory implements various types of animations and transformations that can be applied to mathematical objects (mobjects).

Key components include:

1. Base Animation Framework:
- animation.py: Defines the core Animation class that all other animations inherit from
- composition.py: Provides ways to combine multiple animations (parallel, sequential, lagged)

2. Basic Animation Types:
- creation.py: Animations for showing/creating objects
- fading.py: Fade in/out effects
- growing.py: Animations for objects growing from points or edges
- movement.py: Animations involving motion and paths
- rotation.py: Rotational animations
- transform.py: Transformations between different mobjects

3. Specialized Animation Types:
- numbers.py: Specific animations for numerical displays
- indication.py: Attention-drawing effects like flashing or highlighting
- specialized.py: Special-purpose animations like broadcast effects
- transform_matching_parts.py: Smart transformations that match corresponding parts
- update.py: Animations based on update functions

The directory serves as the animation engine for Manim, providing a comprehensive set of tools for creating mathematical animations. Users can either use these pre-built animations directly or extend them to create custom animations. The system is designed to be modular and composable, allowing complex animations to be built from simpler components.

Common usage involves:
1. Selecting appropriate animation classes
2. Configuring animation parameters (duration, timing functions, etc.)
3. Applying animations to mobjects in scenes
4. Combining multiple animations using composition tools</directory-summary><file name="__init__.py"><file-summary>This is an empty __init__.py file in the manimlib/animation directory. Its presence marks the directory as a Python package, allowing its contents to be imported. The file contains no actual code or declarations.</file-summary></file>
      <file name="animation.py"><declarations>
        DEFAULT_ANIMATION_RUN_TIME = 1.0
        DEFAULT_ANIMATION_LAG_RATIO = 0
    </declarations>
    <dependencies>
        <external>
            from __future__ import annotations
            from copy import deepcopy
            from typing import TYPE_CHECKING, Callable
        </external>
        <internal>
            <filepath>manimlib/mobject/mobject.py</filepath>
            <description>Imports Mobject class and _AnimationBuilder for animation handling</description>
            
            <filepath>manimlib/utils/iterables.py</filepath>
            <description>Imports remove_list_redundancies for list processing</description>
            
            <filepath>manimlib/utils/rate_functions.py</filepath>
            <description>Imports smooth and squish_rate_func for animation timing functions</description>
            
            <filepath>manimlib/utils/simple_functions.py</filepath>
            <description>Imports clip function for value clamping</description>
            
            <filepath>manimlib/scene/scene.py</filepath>
            <description>Imports Scene class for type checking</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="Animation.__init__">
            <description>Constructor for Animation class that initializes animation properties</description>
            <args>
                mobject: Mobject - The object to animate
                run_time: float - Duration of animation
                time_span: tuple[float, float] | None - Start and end times
                lag_ratio: float - Controls timing of submobject animations
                rate_func: Callable - Animation timing function
                name: str - Animation name
                remover: bool - Whether animation removes mobject
                final_alpha_value: float - Final interpolation value
                suspend_mobject_updating: bool - Controls mobject updating
            </args>
            <returns />
            <side-effects>
                Initializes instance variables of the Animation object
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    Assert check for mobject being instance of Mobject
                </handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
        
        <function name="prepare_animation">
            <description>Converts animation builders or animations into proper Animation objects</description>
            <args>
                anim: Animation | _AnimationBuilder - Animation object or builder to prepare
            </args>
            <returns>
                Animation object
            </returns>
            <side-effects />
            <errors-and-exceptions>
                <handled>
                    TypeError for invalid animation types
                </handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines the core Animation class in the Manim library, which handles the animation of mathematical objects. It provides functionality for interpolation, timing, and management of animated objects (mobjects). The file includes utilities for handling animation preparation, timing functions, and proper cleanup of animations in scenes.
    </file-summary></file>
      <file name="composition.py"><declarations>
        DEFAULT_LAGGED_START_LAG_RATIO = 0.05
        AnimationType = Union[Animation, _AnimationBuilder]
    </declarations>
    <dependencies>
        <external>
            numpy
            typing (Union, Iterable, TYPE_CHECKING, Callable, Optional)
        </external>
        <internal>
            <filepath>
                manimlib.animation.animation
                manimlib.mobject.mobject
                manimlib.mobject.types.vectorized_mobject
                manimlib.utils.bezier
                manimlib.utils.iterables
                manimlib.utils.simple_functions
            </filepath>
            <description>
                Imports core animation and mobject classes, utility functions for bezier curves, iteration, and simple mathematical operations used in animation composition
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="AnimationGroup.__init__">
            <description>
                Constructor for AnimationGroup class that handles multiple animations as a single unit
            </description>
            <args>
                *args: AnimationType | Iterable[AnimationType] - Animation objects or iterables of animations
                run_time: float - Duration of the animation group
                lag_ratio: float - Time offset between animations
                group: Optional[Mobject] - Container for the animated objects
                group_type: Optional[type] - Type of group to create
                **kwargs - Additional animation parameters
            </args>
            <returns />
            <side-effects>
                Initializes instance variables and creates group of mobjects
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="AnimationGroup.build_animations_with_timings">
            <description>
                Creates a list of animation timing triplets (animation, start_time, end_time)
            </description>
            <args>
                lag_ratio: float - Time offset between animations
            </args>
            <returns />
            <side-effects>
                Sets self.anims_with_timings with timing information
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="Succession.__init__">
            <description>
                Constructor for Succession class that plays animations one after another
            </description>
            <args>
                *animations: Animation - Animation objects to play in sequence
                lag_ratio: float - Time offset between animations (defaults to 1.0)
                **kwargs - Additional animation parameters
            </args>
            <returns />
            <side-effects>
                Initializes parent AnimationGroup with specified parameters
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="LaggedStartMap.__init__">
            <description>
                Constructor for LaggedStartMap that applies an animation function to each submobject with a time lag
            </description>
            <args>
                anim_func: Callable[[Mobject], Animation] - Function to create animation for each submobject
                group: Mobject - Group of mobjects to animate
                run_time: float - Total duration of all animations
                lag_ratio: float - Time offset between animations
                **kwargs - Additional animation parameters
            </args>
            <returns />
            <side-effects>
                Creates and initializes animations for each submobject in the group
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements various animation composition classes for the Manim library. It includes AnimationGroup for parallel animations, Succession for sequential animations, and LaggedStart/LaggedStartMap for animations with time offsets between elements. The file provides mechanisms to coordinate multiple animations, manage their timing, and handle groups of animated objects.
    </file-summary></file>
      <file name="creation.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            numpy
            abc (ABC, abstractmethod)
            typing (TYPE_CHECKING, Callable)
        </external>
        <internal>
            <filepath>manimlib.animation.animation</filepath>
            <description>Imports Animation base class for animation implementations</description>
            <filepath>manimlib.constants</filepath>
            <description>Imports WHITE color constant</description>
            <filepath>manimlib.mobject.svg.string_mobject</filepath>
            <description>Imports StringMobject for text-based animations</description>
            <filepath>manimlib.mobject.types.vectorized_mobject</filepath>
            <description>Imports VMobject for vector-based animations</description>
            <filepath>manimlib.utils.bezier</filepath>
            <description>Imports integer_interpolate for animation interpolation</description>
            <filepath>manimlib.utils.rate_functions</filepath>
            <description>Imports various rate functions for controlling animation timing</description>
            <filepath>manimlib.utils.simple_functions</filepath>
            <description>Imports clip function for value clamping</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="ShowPartial">
            <description>Abstract base class for partial showing animations</description>
            <args>
                mobject: Mobject - The object to animate
                should_match_start: bool - Whether to match starting state
            </args>
            <returns />
            <side-effects>
                Modifies the mobject's appearance during animation
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Abstract method exception if get_bounds not implemented
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="ShowCreation">
            <description>Animation that gradually shows a mobject being created</description>
            <args>
                mobject: Mobject - The object to animate
                lag_ratio: float - Controls the lag between submobject animations
            </args>
            <returns />
            <side-effects>
                Modifies the mobject's appearance during animation
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="DrawBorderThenFill">
            <description>Animation that first draws the border of a VMobject then fills it</description>
            <args>
                vmobject: VMobject - The vector object to animate
                run_time: float - Duration of animation
                rate_func: Callable - Function controlling animation timing
                stroke_width: float - Width of the border stroke
                stroke_color: ManimColor - Color of the border stroke
            </args>
            <returns />
            <side-effects>
                Modifies the vmobject's appearance during animation
                Creates and manages an outline copy of the vmobject
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    AssertionError if vmobject is not instance of VMobject
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements various creation-based animations for Manim, including showing objects gradually, drawing borders then filling them, and writing text. It contains several animation classes that inherit from Animation base class and implement different ways to reveal or create visual elements on screen.
    </file-summary></file>
      <file name="fading.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            numpy as np
            typing (TYPE_CHECKING, Callable)
        </external>
        <internal>
            <filepath>manimlib.animation.animation</filepath>
            <description>Imports Animation base class</description>
            <filepath>manimlib.animation.transform</filepath>
            <description>Imports Transform class for fade transformations</description>
            <filepath>manimlib.constants</filepath>
            <description>Imports ORIGIN constant</description>
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports Group and Mobject classes</description>
            <filepath>manimlib.mobject.types.vectorized_mobject</filepath>
            <description>Imports VMobject and VGroup for vector-based objects</description>
            <filepath>manimlib.utils.bezier</filepath>
            <description>Imports interpolate function for animations</description>
            <filepath>manimlib.utils.rate_functions</filepath>
            <description>Imports there_and_back function for animation timing</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="Fade">
            <description>Base class for fade animations</description>
            <args>
                mobject: Mobject - object to fade
                shift: np.ndarray - direction to shift during fade
                scale: float - scaling factor during fade
            </args>
            <returns />
            <side-effects>
                Initializes shift_vect and scale_factor class variables
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="FadeIn">
            <description>Animation for fading in objects</description>
            <args>
                mobject: Mobject - object to fade in
            </args>
            <returns>
                Mobject - Starting and target mobjects for the animation
            </returns>
            <side-effects>
                Creates starting mobject with 0 opacity
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="FadeOut">
            <description>Animation for fading out objects</description>
            <args>
                mobject: Mobject - object to fade out
                shift: Vect3 - direction to shift during fade
                remover: bool - whether to remove object after fade
                final_alpha_value: float - final opacity value
            </args>
            <returns>
                Mobject - Target mobject for the animation
            </returns>
            <side-effects>
                Creates target mobject with 0 opacity
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements various fade animations for Manim, including basic fades (FadeIn/FadeOut), point-based fades (FadeInFromPoint/FadeOutToPoint), transform fades (FadeTransform/FadeTransformPieces), and vector-based fades (VFadeIn/VFadeOut/VFadeInThenOut). Each class provides different ways to animate the appearance and disappearance of objects in animations.
    </file-summary></file>
      <file name="growing.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            <dependency>numpy (imported conditionally for type checking)</dependency>
            <dependency>typing.TYPE_CHECKING</dependency>
        </external>
        <internal>
            <filepath>manimlib.animation.transform</filepath>
            <description>Imports Transform class as base class for growing animations</description>
            <filepath>manimlib.constants</filepath>
            <description>Imports PI constant</description>
            <filepath>manimlib.mobject.geometry</filepath>
            <description>Imports Arrow class for type hints</description>
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports Mobject class for type hints</description>
            <filepath>manimlib.typing</filepath>
            <description>Imports ManimColor type for color handling</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="GrowFromPoint.__init__">
            <description>Initializes a growing animation from a specific point</description>
            <args>
                mobject: Mobject - The object to animate
                point: np.ndarray - The point from which to grow
                point_color: ManimColor - Optional color for the starting point
                **kwargs: Additional keyword arguments
            </args>
            <returns />
            <side-effects>
                Sets instance variables point and point_color
                Calls parent class initialization
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="GrowFromPoint.create_target">
            <description>Creates the target state for the growing animation</description>
            <args />
            <returns>Mobject - A copy of the original mobject</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="GrowFromPoint.create_starting_mobject">
            <description>Creates the initial state for the growing animation</description>
            <args />
            <returns>Mobject - The scaled and positioned starting mobject</returns>
            <side-effects>
                Scales the mobject to 0
                Moves it to the specified point
                Optionally changes its color
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="GrowFromCenter.__init__">
            <description>Initializes a growing animation from the center of the mobject</description>
            <args>
                mobject: Mobject - The object to animate
                **kwargs: Additional keyword arguments
            </args>
            <returns />
            <side-effects>
                Calls parent class with calculated center point
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="GrowFromEdge.__init__">
            <description>Initializes a growing animation from a specified edge of the mobject</description>
            <args>
                mobject: Mobject - The object to animate
                edge: np.ndarray - The edge point to grow from
                **kwargs: Additional keyword arguments
            </args>
            <returns />
            <side-effects>
                Calls parent class with calculated edge point
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="GrowArrow.__init__">
            <description>Initializes a growing animation specifically for arrows, starting from the arrow's start point</description>
            <args>
                arrow: Arrow - The arrow object to animate
                **kwargs: Additional keyword arguments
            </args>
            <returns />
            <side-effects>
                Calls parent class with arrow's start point
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements various growing animations for Manim objects. It defines several classes that inherit from Transform to create different types of growing effects: from a point, from center, from edge, and specifically for arrows. Each class provides a way to animate objects growing from nothing to their full size from different starting positions.
    </file-summary></file>
      <file name="indication.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            math
            numpy
            typing
        </external>
        <internal>
            <filepath>manimlib/animation/animation.py</filepath>
            <description>Imports base Animation class</description>
            <filepath>manimlib/animation/composition.py</filepath>
            <description>Imports AnimationGroup and Succession for composing animations</description>
            <filepath>manimlib/constants.py</filepath>
            <description>Imports various constants for positioning, colors, and mathematical values</description>
            <filepath>manimlib/mobject/geometry.py</filepath>
            <description>Imports geometric shapes like Circle, Dot, Line</description>
            <filepath>manimlib/utils/bezier.py</filepath>
            <description>Imports interpolate function for animation calculations</description>
            <filepath>manimlib/utils/rate_functions.py</filepath>
            <description>Imports various rate functions for controlling animation timing</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="FocusOn">
            <description>Creates a focusing animation that draws attention to a specific point</description>
            <args>
                focus_point: np.ndarray | Mobject
                opacity: float = 0.2
                color: ManimColor = GREY
                run_time: float = 2
                remover: bool = True
            </args>
            <returns>Transform animation object</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="Flash">
            <description>Creates a flash effect animation with radiating lines</description>
            <args>
                point: np.ndarray | Mobject
                color: ManimColor = YELLOW
                line_length: float = 0.2
                num_lines: int = 12
                flash_radius: float = 0.3
                line_stroke_width: float = 3.0
                run_time: float = 1.0
            </args>
            <returns>AnimationGroup object</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="ShowPassingFlash">
            <description>Creates an animation that shows a flash passing through a mobject</description>
            <args>
                mobject: Mobject
                time_width: float = 0.1
                remover: bool = True
            </args>
            <returns>Animation object</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains various animation classes for creating visual indications and effects in Manim animations. It includes animations for focusing attention, flashing effects, circular indications, and wave-like movements. The animations are primarily used to highlight or draw attention to specific elements in mathematical animations.
    </file-summary></file>
      <file name="movement.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            <dependency>typing (TYPE_CHECKING, Callable, Sequence)</dependency>
            <dependency>numpy (imported as np)</dependency>
        </external>
        <internal>
            <filepath>manimlib.animation.animation</filepath>
            <description>Imports Animation base class for inheritance</description>
            <filepath>manimlib.utils.rate_functions</filepath>
            <description>Imports linear rate function used in PhaseFlow</description>
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports Mobject type for type hints</description>
            <filepath>manimlib.mobject.types.vectorized_mobject</filepath>
            <description>Imports VMobject type for type hints</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__ (Homotopy)">
            <description>Initializes a Homotopy animation that transforms points based on a given function</description>
            <args>
                homotopy: Callable[[float, float, float, float], Sequence[float]] - transformation function
                mobject: Mobject - object to animate
                run_time: float - duration of animation
                **kwargs - additional arguments
            </args>
            <returns />
            <side-effects>
                Sets instance attributes
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="function_at_time_t">
            <description>Creates a function that applies the homotopy at a specific time t</description>
            <args>
                t: float - time parameter
            </args>
            <returns>Callable that takes np.ndarray and returns Sequence[float]</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="interpolate_submobject">
            <description>Applies the homotopy transformation to a submobject at a given alpha value</description>
            <args>
                submob: Mobject - submobject to transform
                start: Mobject - starting state
                alpha: float - interpolation parameter
            </args>
            <returns />
            <side-effects>
                Modifies the submobject's points
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements various movement-based animations in Manim. It includes:
        - Homotopy: Implements continuous deformation of objects
        - SmoothedVectorizedHomotopy: A smooth version of Homotopy
        - ComplexHomotopy: Implements homotopy using complex numbers
        - PhaseFlow: Implements movement based on a vector field
        - MoveAlongPath: Moves an object along a specified path
        
        Each class extends the Animation base class and provides specific movement behaviors for mathematical animations.
    </file-summary></file>
      <file name="numbers.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            <dependency>typing (TYPE_CHECKING, Callable)</dependency>
        </external>
        <internal>
            <filepath>manimlib.animation.animation</filepath>
            <description>Imports Animation class as base class for number animations</description>
            <filepath>manimlib.mobject.numbers</filepath>
            <description>Imports DecimalNumber class for number display</description>
            <filepath>manimlib.utils.bezier</filepath>
            <description>Imports interpolate function for smooth number transitions</description>
            <filepath>manimlib.utils.simple_functions</filepath>
            <description>Imports clip function for value clamping</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="ChangingDecimal.__init__">
            <description>Constructor for ChangingDecimal animation class</description>
            <args>
                decimal_mob: DecimalNumber - The decimal number mobject to animate
                number_update_func: Callable[[float], float] - Function to update number values
                suspend_mobject_updating: bool - Flag to suspend mobject updates
                **kwargs - Additional keyword arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Initializes instance variables and parent class
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    Assert check for decimal_mob being instance of DecimalNumber
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="ChangingDecimal.interpolate_mobject">
            <description>Updates the decimal number value during animation</description>
            <args>
                alpha: float - Interpolation parameter between 0 and 1
            </args>
            <returns>
            </returns>
            <side-effects>
                Updates the mobject's value using number_update_func
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="ChangeDecimalToValue.__init__">
            <description>Constructor for animation that changes decimal to specific value</description>
            <args>
                decimal_mob: DecimalNumber - The decimal number mobject to animate
                target_number: float | complex - The target number value
                **kwargs - Additional keyword arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Initializes parent class with interpolation function
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="CountInFrom.__init__">
            <description>Constructor for animation that counts from a source number</description>
            <args>
                decimal_mob: DecimalNumber - The decimal number mobject to animate
                source_number: float | complex - Starting number (default 0)
                **kwargs - Additional keyword arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Initializes parent class with interpolation function
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines animation classes for manipulating decimal numbers in manim animations. It includes ChangingDecimal for general number animations, ChangeDecimalToValue for transitioning to specific values, and CountInFrom for counting animations from a source number. All classes inherit from the Animation base class and work with DecimalNumber mobjects.
    </file-summary></file>
      <file name="rotation.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            <dependency>numpy</dependency>
            <dependency>typing</dependency>
        </external>
        <internal>
            <filepath>manimlib.animation.animation</filepath>
            <description>Imports base Animation class that Rotating inherits from</description>
            <filepath>manimlib.constants</filepath>
            <description>Imports constants like ORIGIN, OUT, PI, TAU used for rotation parameters</description>
            <filepath>manimlib.utils.rate_functions</filepath>
            <description>Imports linear and smooth rate functions for controlling animation timing</description>
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports Mobject type for type checking</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__ (Rotating class)">
            <description>Constructor for Rotating animation class that handles rotation of mobjects</description>
            <args>
                mobject: Mobject - The object to be rotated
                angle: float - Rotation angle (default TAU)
                axis: np.ndarray - Axis of rotation (default OUT)
                about_point: np.ndarray | None - Point to rotate around (default None)
                about_edge: np.ndarray | None - Edge to rotate around (default None)
                run_time: float - Duration of animation (default 5.0)
                rate_func: Callable - Function controlling animation timing (default linear)
                suspend_mobject_updating: bool - Whether to suspend updates (default False)
                **kwargs - Additional keyword arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Initializes instance variables for the rotation animation
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    Invalid parameter types or values
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="interpolate_mobject">
            <description>Performs the actual rotation animation by interpolating between start and end states</description>
            <args>
                alpha: float - Interpolation parameter between 0 and 1
            </args>
            <returns>
            </returns>
            <side-effects>
                Modifies the mobject's position/orientation through rotation
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    Invalid data access or rotation parameters
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="__init__ (Rotate class)">
            <description>Constructor for Rotate class, a simplified version of Rotating with different defaults</description>
            <args>
                mobject: Mobject - The object to be rotated
                angle: float - Rotation angle (default PI)
                axis: np.ndarray - Axis of rotation (default OUT)
                run_time: float - Duration of animation (default 1)
                rate_func: Callable - Function controlling animation timing (default smooth)
                about_edge: np.ndarray - Edge to rotate around (default ORIGIN)
                **kwargs - Additional keyword arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Initializes parent Rotating class with modified default parameters
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    Invalid parameter types or values
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines two animation classes for rotating objects in manim: Rotating and Rotate. Rotating is the base class providing full control over rotation parameters, while Rotate is a simplified version with more convenient defaults for common use cases. The classes handle the interpolation of rotation animations over time with customizable parameters like angle, axis, duration, and timing functions.
    </file-summary></file>
      <file name="specialized.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            <package>typing</package>
            <package>numpy (conditional import under TYPE_CHECKING)</package>
        </external>
        <internal>
            <filepath>manimlib.animation.composition</filepath>
            <description>Imports LaggedStart class which is used as the parent class for Broadcast</description>
            <filepath>manimlib.animation.transform</filepath>
            <description>Imports Restore class used in animation composition</description>
            <filepath>manimlib.constants</filepath>
            <description>Imports BLACK and WHITE color constants</description>
            <filepath>manimlib.mobject.geometry</filepath>
            <description>Imports Circle class for creating circular animations</description>
            <filepath>manimlib.mobject.types.vectorized_mobject</filepath>
            <description>Imports VGroup for managing groups of mobjects</description>
            <filepath>manimlib.typing</filepath>
            <description>Imports ManimColor type for type checking</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>Constructor for the Broadcast animation class that creates expanding circular animations from a focal point</description>
            <args>
                focal_point: np.ndarray - Center point of the broadcast
                small_radius: float - Starting radius (default: 0.0)
                big_radius: float - Ending radius (default: 5.0)
                n_circles: int - Number of circles in the animation (default: 5)
                start_stroke_width: float - Initial stroke width (default: 8.0)
                color: ManimColor - Color of the circles (default: WHITE)
                run_time: float - Duration of animation (default: 3.0)
                lag_ratio: float - Time lag between circles (default: 0.2)
                remover: bool - Whether to remove animation after completion (default: True)
                **kwargs - Additional keyword arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Initializes instance variables and creates circle animations
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    Potential ValueError if radius values are invalid
                    Potential TypeError if focal_point is not numpy array
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines a specialized animation class called Broadcast that creates an expanding circular wave effect from a focal point. It inherits from LaggedStart and is typically used for visual emphasis or attention-drawing effects in animations. The animation consists of multiple circles that expand from a small radius to a larger one with a time delay between each circle's expansion.
    </file-summary></file>
      <file name="transform.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            inspect
            numpy
            typing (TYPE_CHECKING, Callable)
            numpy.typing
        </external>
        <internal>
            <filepath>
                manimlib.animation.animation
                manimlib.constants
                manimlib.mobject.mobject
                manimlib.utils.paths
                manimlib.scene.scene
                manimlib.typing
            </filepath>
            <description>
                Imports core Manim components for animation, constants (DEGREES, OUT), mobject handling, path utilities, scene management, and custom typing definitions.
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="Transform">
            <description>
                Base class for transform animations that convert one mobject into another
            </description>
            <args>
                mobject: Mobject - The starting mobject
                target_mobject: Optional[Mobject] - The target state
                path_arc: float - Arc of the path (default 0.0)
                path_arc_axis: np.ndarray - Axis for the arc path
                path_func: Optional[Callable] - Custom path function
            </args>
            <returns>
                Transform animation instance
            </returns>
            <side-effects>
                Modifies the scene by transforming mobjects
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    Exception when target_mobject is None
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="ReplacementTransform">
            <description>
                Transform that replaces the original mobject with the target in the scene
            </description>
            <args>
                Same as Transform class
            </args>
            <returns />
            <side-effects>
                Replaces original mobject with target in scene
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="ApplyMethod">
            <description>
                Animates the application of a method to a mobject
            </description>
            <args>
                method: Callable - Method to apply
                *args - Arguments for the method
                **kwargs - Configuration for the transform
            </args>
            <returns />
            <side-effects>
                Applies the specified method to the mobject
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    Exception when method is not a valid mobject method
                </handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements various transform animations for Manim. It includes the base Transform class and several specialized transforms like ReplacementTransform, ApplyMethod, and others. The transforms handle the animation of converting one mobject into another, applying methods, matrices, or functions to mobjects, and managing the transition paths between states.
    </file-summary></file>
      <file name="transform_matching_parts.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            itertools
            difflib.SequenceMatcher
            typing (TYPE_CHECKING, Iterable)
        </external>
        <internal>
            <filepath>
                manimlib.animation.composition
                manimlib.animation.fading
                manimlib.animation.transform
                manimlib.mobject.mobject
                manimlib.mobject.types.vectorized_mobject
                manimlib.mobject.svg.string_mobject
                manimlib.scene.scene
            </filepath>
            <description>
                Imports various animation, mobject, and scene components needed for transformations and animations between matching parts of mobjects
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="TransformMatchingParts.__init__">
            <description>
                Initializes a transformation animation that matches and transforms corresponding parts between source and target mobjects
            </description>
            <args>
                source: Mobject - Source mobject to transform from
                target: Mobject - Target mobject to transform to
                matched_pairs: Iterable[tuple[Mobject, Mobject]] - Pre-defined pairs of matching parts
                match_animation: type - Animation class for matching parts
                mismatch_animation: type - Animation class for mismatching parts
                run_time: float - Duration of animation
                lag_ratio: float - Timing offset between animations
                **kwargs - Additional animation configuration
            </args>
            <returns>
            </returns>
            <side-effects>
                Initializes instance variables and creates animation sequence
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="TransformMatchingParts.add_transform">
            <description>
                Adds a transform animation between a source and target piece
            </description>
            <args>
                source: Mobject - Source piece to transform from
                target: Mobject - Target piece to transform to
            </args>
            <returns>
            </returns>
            <side-effects>
                Modifies self.anims, self.source_pieces, and self.target_pieces
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="TransformMatchingParts.find_pairs_with_matching_shapes">
            <description>
                Finds pairs of mobjects that have matching shapes between two lists
            </description>
            <args>
                chars1: list[Mobject] - First list of mobjects
                chars2: list[Mobject] - Second list of mobjects
            </args>
            <returns>
                list[tuple[Mobject, Mobject]] - List of matching pairs
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="TransformMatchingStrings.__init__">
            <description>
                Initializes a transformation specifically for string mobjects with matching functionality
            </description>
            <args>
                source: StringMobject - Source string mobject
                target: StringMobject - Target string mobject
                matched_keys: Iterable[str] - Keys for pre-matched parts
                key_map: dict[str, str] - Mapping between source and target keys
                matched_pairs: Iterable[tuple[VMobject, VMobject]] - Pre-defined matching pairs
                **kwargs - Additional configuration parameters
            </args>
            <returns>
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements transformation animations that match and transform corresponding parts between source and target mobjects. It includes specialized classes for handling general mobject transformations (TransformMatchingParts), shape-based transformations (TransformMatchingShapes), and string-based transformations (TransformMatchingStrings/TransformMatchingTex).
    </file-summary></file>
      <file name="update.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            from __future__ import annotations
            from typing import TYPE_CHECKING, Callable
        </external>
        <internal>
            <filepath>
                from manimlib.animation.animation import Animation
                from manimlib.mobject.mobject import Mobject
            </filepath>
            <description>
                Imports the base Animation class and Mobject class for animation functionality and object manipulation
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__ (UpdateFromFunc)">
            <description>
                Initializes UpdateFromFunc animation with a mobject and update function
            </description>
            <args>
                mobject: Mobject - The object to be animated
                update_function: Callable[[Mobject], Mobject | None] - Function to update the mobject
                suspend_mobject_updating: bool - Flag to suspend mobject updating
                **kwargs - Additional keyword arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Sets instance variables and initializes parent class
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="interpolate_mobject (UpdateFromFunc)">
            <description>
                Updates the mobject using the update function
            </description>
            <args>
                alpha: float - Interpolation parameter
            </args>
            <returns>
                None
            </returns>
            <side-effects>
                Modifies the mobject state through update_function
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="__init__ (UpdateFromAlphaFunc)">
            <description>
                Initializes UpdateFromAlphaFunc animation with a mobject and alpha-aware update function
            </description>
            <args>
                mobject: Mobject - The object to be animated
                update_function: Callable[[Mobject, float], Mobject | None] - Function to update the mobject with alpha
                suspend_mobject_updating: bool - Flag to suspend mobject updating
                **kwargs - Additional keyword arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Sets instance variables and initializes parent class
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="interpolate_mobject (UpdateFromAlphaFunc)">
            <description>
                Updates the mobject using the update function with alpha parameter
            </description>
            <args>
                alpha: float - Interpolation parameter
            </args>
            <returns>
                None
            </returns>
            <side-effects>
                Modifies the mobject state through update_function
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="__init__ (MaintainPositionRelativeTo)">
            <description>
                Initializes animation that maintains relative position between two mobjects
            </description>
            <args>
                mobject: Mobject - The object to maintain position
                tracked_mobject: Mobject - The reference object to track
                **kwargs - Additional keyword arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Sets instance variables and calculates initial position difference
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="interpolate_mobject (MaintainPositionRelativeTo)">
            <description>
                Updates the mobject position to maintain relative position to tracked mobject
            </description>
            <args>
                alpha: float - Interpolation parameter
            </args>
            <returns>
                None
            </returns>
            <side-effects>
                Shifts the mobject position relative to tracked mobject
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines three animation classes for updating mobjects: UpdateFromFunc for applying update functions, UpdateFromAlphaFunc for applying alpha-aware update functions, and MaintainPositionRelativeTo for maintaining relative positions between mobjects. All classes inherit from the Animation base class.
    </file-summary></file>
    </directory>
    <directory name="camera">
      <directory-summary>The camera directory in manimlib implements the core camera and frame management system for the Manim animation engine. It contains three key files:

1. camera.py - Implements the main Camera class that handles the rendering pipeline, including OpenGL context initialization, frame buffer management, and scene capture functionality. It serves as the primary interface for rendering mobjects and managing the view.

2. camera_frame.py - Defines the CameraFrame class, which manages the camera's position, orientation, and properties in 3D space. It handles view transformations using quaternions and Euler angles, and provides methods for manipulating the camera's perspective.

3. __init__.py - Marks the directory as a Python package, enabling imports of the camera components.

Together, these files form the visualization system of Manim, allowing for precise control over how scenes are rendered and viewed. The camera system supports both 2D and 3D rendering capabilities, with the Camera class handling the actual rendering process while CameraFrame manages the viewpoint and transformation aspects.

This directory is fundamental to Manim's ability to create mathematical animations, as it provides the infrastructure for converting mathematical objects (mobjects) into rendered frames that can be displayed or saved to video.</directory-summary><file name="__init__.py"><file-summary>This is an empty __init__.py file in the manimlib/camera directory. Its presence marks the directory as a Python package, allowing its contents to be imported. The file contains no actual code or declarations.</file-summary></file>
      <file name="camera.py"><declarations>
        None at file level - all declarations are within class definitions
    </declarations>
    <dependencies>
        <external>
            moderngl
            numpy
            OpenGL.GL
            PIL.Image
            typing
        </external>
        <internal>
            <filepath>
                manimlib.camera.camera_frame
                manimlib.constants
                manimlib.mobject.mobject
                manimlib.utils.color
                manimlib.typing
                manimlib.window
            </filepath>
            <description>
                Imports camera frame implementation, various constants for dimensions and colors,
                mobject classes for 3D objects, color utilities, and type definitions.
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="init_frame">
            <description>Initializes the camera frame with given configuration</description>
            <args>self, **config: dict of configuration parameters</args>
            <returns>None</returns>
            <side-effects>Creates and sets the camera frame instance</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="init_context">
            <description>Initializes the OpenGL context for rendering</description>
            <args>self</args>
            <returns>None</returns>
            <side-effects>Sets up OpenGL context and enables required features</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="capture">
            <description>Renders given mobjects to the frame buffer</description>
            <args>self, *mobjects: Variable number of Mobject instances</args>
            <returns>None</returns>
            <side-effects>Clears buffer, updates uniforms, renders objects, and handles window buffer swapping</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements the Camera class for the Manim library, which handles the rendering pipeline and frame management. It provides functionality for initializing OpenGL contexts, managing frame buffers, handling camera transformations, and capturing rendered scenes. The file also includes a ThreeDCamera subclass for backward compatibility.
    </file-summary></file>
      <file name="camera_frame.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            numpy
            scipy.spatial.transform
            pyrr
            warnings
            math
            typing
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports various constants like DEGREES, RADIANS, FRAME_SHAPE, and directional constants</description>
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports Mobject as base class for CameraFrame</description>
            <filepath>manimlib.utils.space_ops</filepath>
            <description>Imports normalize function for vector operations</description>
            <filepath>manimlib.utils.simple_functions</filepath>
            <description>Imports clip function for value clamping</description>
            <filepath>manimlib.typing</filepath>
            <description>Imports Vect3 type for type hints</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>Initializes a CameraFrame object with specified parameters</description>
            <args>
                frame_shape: tuple[float, float] - Shape of the frame
                center_point: Vect3 - Center position of the frame
                fovy: float - Field of view in y direction
                euler_axes: str - Order of Euler angle rotations
                z_index: int - Rendering order
            </args>
            <returns />
            <side-effects>
                Initializes instance variables and uniforms
                Sets up initial frame geometry
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="set_orientation">
            <description>Sets the orientation of the camera frame using a rotation object</description>
            <args>rotation: Rotation - Rotation object specifying new orientation</args>
            <returns>self - For method chaining</returns>
            <side-effects>Updates the orientation uniform</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        
    </function-defs>
    <file-summary>
        This file defines the CameraFrame class, which is a specialized Mobject that handles camera positioning and orientation in a 3D space. It provides methods for manipulating the camera's position, rotation, field of view, and other properties. The class uses quaternions for rotation representation and includes methods for working with Euler angles. It's a core component for managing view transformations in the Manim animation engine.
    </file-summary></file>
    </directory>
    <file name="config.py"><declarations>
        __config_file__ = "custom_config.yml"
    </declarations>
    <dependencies>
        <external>
            argparse
            colour
            importlib
            inspect
            os
            screeninfo
            sys
            yaml
        </external>
        <internal>
            <filepath>manimlib.logger</filepath>
            <description>Used for logging messages and errors</description>
            <filepath>manimlib.utils.dict_ops</filepath>
            <description>Used for merging dictionaries recursively</description>
            <filepath>manimlib.utils.init_config</filepath>
            <description>Used for initializing custom configurations</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="parse_cli">
            <description>Parses command line arguments for manim configuration</description>
            <args>None</args>
            <returns>Namespace object containing parsed command line arguments</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled>argparse.ArgumentError</handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_manim_dir">
            <description>Gets the absolute path to the manim directory</description>
            <args>None</args>
            <returns>String path to manim directory</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_module">
            <description>Imports and returns a module from a file path</description>
            <args>file_name: str | None - Path to the Python file</args>
            <returns>Module object or None</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_configuration">
            <description>Creates a complete configuration dictionary from command line arguments and config files</description>
            <args>args: Namespace - Parsed command line arguments</args>
            <returns>Dictionary containing complete manim configuration</returns>
            <side-effects>
                Initializes global configuration
                May create config files
            </side-effects>
            <errors-and-exceptions>
                <handled>ValueError for invalid colors</handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file handles configuration management for the Manim library. It processes command line arguments, reads configuration files, and sets up various rendering and display options. The file provides functions to parse CLI arguments, manage config files, and create comprehensive configuration dictionaries that control Manim's behavior. It also includes utilities for handling file paths, module imports, and screen resolution settings.
    </file-summary></file>
    <file name="constants.py"><declarations>
        
        ASPECT_RATIO: float
        FRAME_HEIGHT: float
        FRAME_WIDTH: float
        FRAME_SHAPE: tuple[float, float]
        FRAME_Y_RADIUS: float
        FRAME_X_RADIUS: float
        DEFAULT_PIXEL_HEIGHT: int
        DEFAULT_PIXEL_WIDTH: int
        DEFAULT_FPS: int
        
        
        SMALL_BUFF: float = 0.1
        MED_SMALL_BUFF: float = 0.25
        MED_LARGE_BUFF: float = 0.5
        LARGE_BUFF: float = 1
        DEFAULT_MOBJECT_TO_EDGE_BUFFER: float
        DEFAULT_MOBJECT_TO_MOBJECT_BUFFER: float
        
        
        DEFAULT_WAIT_TIME: float = 1.0
        
        
        ORIGIN, UP, DOWN, RIGHT, LEFT, IN, OUT, X_AXIS, Y_AXIS, Z_AXIS: Vect3
        NULL_POINTS: np.array
        UL, UR, DL, DR, TOP, BOTTOM, LEFT_SIDE, RIGHT_SIDE: Vect3
        
        
        PI, TAU, DEGREES, RADIANS: float
        
        
        FFMPEG_BIN: str
        JOINT_TYPE_MAP: dict
        
        
        NORMAL, ITALIC, OBLIQUE, BOLD: str
        DEFAULT_STROKE_WIDTH: float
        
        
        CTRL_SYMBOL, SHIFT_SYMBOL, COMMAND_SYMBOL, DELETE_SYMBOL: int
        ARROW_SYMBOLS: list[int]
        SHIFT_MODIFIER, CTRL_MODIFIER, COMMAND_MODIFIER: int
        
        
        Multiple color constants (BLUE_E through WHITE): ManimColor
        MANIM_COLORS: List[ManimColor]
        COLORMAP_3B1B: List[ManimColor]
    </declarations>
    <dependencies>
        <external>
            numpy
            typing
        </external>
        <internal>
            <filepath>
                manimlib.config
                manimlib.typing
            </filepath>
            <description>
                Imports configuration functions for frame and pixel dimensions, and custom type definitions for colors and vectors
            </description>
        </internal>
    </dependencies>
    <function-defs>
    </function-defs>
    <file-summary>
        A comprehensive constants file for the Manim library that defines various configuration values, including:
        - Frame dimensions and aspect ratios
        - Buffer sizes for visual spacing
        - Vector constants for positioning
        - Mathematical constants
        - Text styling options
        - Keyboard interaction constants
        - An extensive color palette with variations
        The file serves as a central repository for commonly used values throughout the Manim animation library.
    </file-summary></file>
    <file name="default_config.yml"><file-summary>This is a YAML configuration file for the Manim animation library that defines default settings and parameters. It includes:
        - Directory configurations for output, images, sounds, and temporary storage
        - Universal import statement
        - Style settings (tex template, font, text alignment, background color)
        - Window display settings (position, monitor, full screen mode)
        - File writer configurations (video codec, pixel format, partial movie settings)
        - Camera resolution presets (low, medium, high, 4k)
        - Frame rate setting
        - Exception handling and error sound settings
        
        The file serves as the default configuration that can be overridden by user-specific settings. It controls various aspects of how Manim generates and outputs animations, handles resources, and manages the development environment.</file-summary></file>
    <directory name="event_handler">
      <directory-summary>The event_handler directory implements a comprehensive event handling system for the Manim library. It consists of four key files that work together to manage user interactions:

1. event_type.py defines an enumeration of all possible event types (mouse/keyboard events)
2. event_listener.py provides the EventListener class that connects mathematical objects (mobjects) with specific event types and their callbacks
3. event_dispatcher.py implements the main EventDispatcher class that manages event listeners and coordinates event propagation
4. __init__.py creates a singleton EVENT_DISPATCHER instance for global use

The system follows a publisher-subscriber pattern where:
- Mobjects can subscribe to specific events using EventListener instances
- The EventDispatcher maintains these subscriptions and routes events to appropriate listeners
- Events are typed using the EventType enumeration for consistency

This directory provides the foundation for all interactive features in Manim, allowing mathematical objects to respond to user input through mouse and keyboard events. The system is designed to be thread-safe through its singleton pattern and provides comprehensive tracking of mouse positions and keyboard states.

To use this system, developers should:
1. Use the global EVENT_DISPATCHER instance
2. Create EventListener instances for their mobjects
3. Register these listeners with the dispatcher
4. Handle events through callback functions</directory-summary><file name="__init__.py"><declarations>
        EVENT_DISPATCHER = EventDispatcher()
    </declarations>
    <dependencies>
        <external>
        </external>
        <internal>
            <filepath>manimlib.event_handler.event_dispatcher</filepath>
            <description>
                Imports the EventDispatcher class to create a singleton instance for event handling
            </description>
        </internal>
    </dependencies>
    <function-defs>
    </function-defs>
    <file-summary>
        This is an initialization file for the event_handler module that creates a singleton instance of EventDispatcher. The file establishes a global EVENT_DISPATCHER object that should remain the only instance of EventDispatcher throughout the runtime of the application, implementing the Singleton pattern for event handling.
    </file-summary></file>
      <file name="event_dispatcher.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            numpy (imported as np)
        </external>
        <internal>
            <filepath>manimlib/event_handler/event_listner.py</filepath>
            <description>Imports EventListener class for handling event callbacks</description>
            <filepath>manimlib/event_handler/event_type.py</filepath>
            <description>Imports EventType enum for event type classification</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>Initializes the EventDispatcher with event listeners and tracking variables</description>
            <args>self</args>
            <returns />
            <side-effects>
                Initializes instance variables for event listeners, mouse positions, and pressed keys
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="add_listner">
            <description>Adds an event listener to the dispatcher</description>
            <args>
                self
                event_listner: EventListener
            </args>
            <returns>self (EventDispatcher instance)</returns>
            <side-effects>
                Modifies the event_listners dictionary
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    AssertionError if event_listner is not an EventListener instance
                </handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="remove_listner">
            <description>Removes an event listener from the dispatcher</description>
            <args>
                self
                event_listner: EventListener
            </args>
            <returns>self (EventDispatcher instance)</returns>
            <side-effects>
                Modifies the event_listners dictionary
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    AssertionError if event_listner is not an EventListener instance
                    General exception when listener not found
                </handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="dispatch">
            <description>Dispatches events to appropriate listeners based on event type</description>
            <args>
                self
                event_type: EventType
                **event_data: Additional event data
            </args>
            <returns>propagate_event (bool or None)</returns>
            <side-effects>
                Updates mouse positions and pressed keys
                Calls listener callbacks
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    AssertionError for drag event listeners
                </handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_listners_count">
            <description>Returns the total count of event listeners</description>
            <args>self</args>
            <returns>int</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_mouse_point">
            <description>Returns the current mouse position</description>
            <args>self</args>
            <returns>np.ndarray</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_mouse_drag_point">
            <description>Returns the current mouse drag position</description>
            <args>self</args>
            <returns>np.ndarray</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="is_key_pressed">
            <description>Checks if a specific key is currently pressed</description>
            <args>
                self
                symbol: int
            </args>
            <returns>bool</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements an event dispatcher system for handling various types of events (mouse, keyboard) in the Manim library. It maintains a collection of event listeners and coordinates event propagation to appropriate handlers. The class includes functionality for tracking mouse positions, key states, and managing draggable objects.
    </file-summary></file>
      <file name="event_listner.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            from __future__ import annotations
            from typing import TYPE_CHECKING, Callable
        </external>
        <internal>
            <filepath>from manimlib.event_handler.event_type import EventType</filepath>
            <description>Imports EventType class for type hinting event types in the EventListener class</description>
            <filepath>from manimlib.mobject.mobject import Mobject</filepath>
            <description>Imports Mobject class for type hinting mobject parameter in the EventListener class</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>Constructor for the EventListener class that initializes a new event listener with a mobject, event type, and callback function</description>
            <args>
                self: EventListener
                mobject: Mobject - The mobject to attach the event listener to
                event_type: EventType - The type of event to listen for
                event_callback: Callable[[Mobject, dict[str]]] - The callback function to execute when event occurs
            </args>
            <returns>
            </returns>
            <side-effects>
                Sets instance variables mobject, event_type, and callback
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="__eq__">
            <description>Equality comparison method that checks if two EventListener objects are equal</description>
            <args>
                self: EventListener
                o: object - The object to compare with
            </args>
            <returns>
                bool - True if the objects are equal, False otherwise
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    Generic exception catch for attribute access errors when comparing with non-EventListener objects
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines the EventListener class which is responsible for handling events in the Manim library. It connects mobjects (mathematical objects) with event types and their corresponding callback functions. The class provides basic initialization and equality comparison functionality.
    </file-summary></file>
      <file name="event_type.py"><declarations>
        <constant>EventType - An Enum class defining various event types for mouse and keyboard interactions</constant>
    </declarations>
    <dependencies>
        <external>
            enum - Python's standard library for creating enumerated constants
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
    </function-defs>
    <file-summary>
        This file defines an enumeration class EventType that contains constants for different types of mouse and keyboard events. The events include mouse motion, press, release, drag, and scroll events, as well as keyboard press and release events. Each enum value is a string that describes the event type. This enumeration is likely used throughout the Manim library to handle and dispatch various user input events in a consistent manner.
    </file-summary></file>
    </directory>
    <file name="extract_scene.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            copy
            inspect
            sys
        </external>
        <internal>
            <filepath>manimlib.config</filepath>
            <description>Imports get_custom_config for configuration management</description>
            <filepath>manimlib.logger</filepath>
            <description>Imports log for error logging</description>
            <filepath>manimlib.scene.interactive_scene</filepath>
            <description>Imports InteractiveScene as base class for BlankScene</description>
            <filepath>manimlib.scene.scene</filepath>
            <description>Imports Scene class for scene management</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="is_child_scene">
            <description>Determines if an object is a valid Scene subclass from the specified module</description>
            <args>obj: Any object to check, module: Python module object</args>
            <returns>Boolean indicating if obj is a valid scene class</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="prompt_user_for_choice">
            <description>Prompts user to select which scenes to render from available options</description>
            <args>scene_classes: List of scene classes</args>
            <returns>List of selected scene classes</returns>
            <side-effects>Prints to console and reads user input</side-effects>
            <errors-and-exceptions>
                <handled>
                    IndexError: Invalid scene number
                    KeyError: Invalid scene name
                    EOFError: User interrupt
                </handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_scene_config">
            <description>Extracts scene-specific configuration from general config</description>
            <args>config: Dictionary containing configuration</args>
            <returns>Dictionary of scene-specific configuration parameters</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="compute_total_frames">
            <description>Calculates total frames needed for a scene by running a preview</description>
            <args>scene_class: Scene class to analyze, scene_config: Scene configuration</args>
            <returns>Integer number of total frames</returns>
            <side-effects>Creates and runs a test scene instance</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="scene_from_class">
            <description>Creates a scene instance from a scene class with proper configuration</description>
            <args>scene_class: Scene class, scene_config: Scene configuration, config: General configuration</args>
            <returns>Scene instance</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_scenes_to_render">
            <description>Determines which scenes should be rendered based on configuration</description>
            <args>all_scene_classes: List of available scenes, scene_config: Scene configuration, config: General configuration</args>
            <returns>List of scene instances to render</returns>
            <side-effects>May prompt user for input if needed</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_scene_classes_from_module">
            <description>Extracts all valid scene classes from a module</description>
            <args>module: Python module object</args>
            <returns>List of scene classes</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="main">
            <description>Main entry point for scene extraction and creation</description>
            <args>config: Configuration dictionary</args>
            <returns>List of scene instances</returns>
            <side-effects>May create and configure multiple scene instances</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file handles the extraction and creation of scenes in the Manim library. It provides functionality for identifying valid scenes from modules, managing scene configuration, and handling user interaction for scene selection. The file includes utilities for computing frame counts and managing scene rendering setup.
    </file-summary></file>
    <file name="logger.py"><declarations>
        FORMAT = "%(message)s"
        log = logging.getLogger("manimgl")
    </declarations>
    <dependencies>
        <external>
            logging
            rich.logging.RichHandler
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
    </function-defs>
    <file-summary>
        This file sets up logging configuration for the Manim library. It creates a logger instance named "manimgl" with Rich formatting for enhanced console output. The logging level is set to DEBUG, though the basic configuration is set to WARNING level. The file uses the Rich library's RichHandler for prettier console logging output. The logger instance is exposed through the __all__ variable for importing elsewhere in the project.
    </file-summary></file>
    <directory name="mobject">
      <directory-summary>The mobject directory contains the core building blocks and visual elements of the Manim animation library. It provides several key functionalities:

1. Core Object System:
- Base Mobject class (mobject.py) that defines the fundamental mathematical object system
- Value tracking system (value_tracker.py) for managing animatable values
- Update utilities (mobject_update_utils.py) for object animations and transformations

2. Geometric Elements:
- Basic shapes and geometric primitives (geometry.py)
- Coordinate systems and graphs (coordinate_systems.py, functions.py)
- Number lines and mathematical visualizations (number_line.py)
- Boolean operations on shapes (boolean_ops.py)

3. Text and Mathematical Typography:
- Matrix displays (matrix.py)
- Number displays (numbers.py)
- Frame and screen elements (frame.py)

4. Advanced Visualization:
- Vector fields (vector_field.py)
- Three-dimensional objects (three_dimensions.py)
- Probability visualizations (probability.py)
- Interactive elements (interactive.py)

5. Specialized Subdirectories:
- svg/: Handles SVG parsing and rendering, including LaTeX and text
- types/: Defines core object types like vector graphics, surfaces, and point clouds

This directory forms the foundation of Manim's visual system, providing the building blocks that animations are constructed from. Most user code will interact with these classes to create mathematical visualizations and animations.</directory-summary><file name="__init__.py"><file-summary>This is an empty __init__.py file in the manimlib/mobject directory. Its presence marks the directory as a Python package, allowing its contents to be imported. The file contains no actual code or declarations.</file-summary></file>
      <file name="boolean_ops.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            numpy
            pathops
        </external>
        <internal>
            <filepath>
                manimlib.mobject.types.vectorized_mobject
            </filepath>
            <description>
                Imports VMobject class which is used as the base class for boolean operations
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="_convert_vmobject_to_skia_path">
            <description>
                Converts a VMobject to a Skia path for boolean operations
            </description>
            <args>
                vmobject: VMobject - The vector mobject to convert
            </args>
            <returns>
                pathops.Path - A Skia path representation of the VMobject
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="_convert_skia_path_to_vmobject">
            <description>
                Converts a Skia path back to a VMobject
            </description>
            <args>
                path: pathops.Path - The Skia path to convert
                vmobject: VMobject - The target VMobject to populate
            </args>
            <returns>
                VMobject - The converted vector mobject
            </returns>
            <side-effects>
                Modifies the input vmobject by adding paths and points
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    Exception raised for unsupported path verbs
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements boolean operations (Union, Difference, Intersection, Exclusion) for 2D mobjects in Manim. It uses the Skia graphics library through pathops to perform these operations. The file contains utility functions to convert between VMobjects and Skia paths, and classes that implement each boolean operation. The code is borrowed from the ManimCommunity project.
    </file-summary></file>
      <file name="changing.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            numpy as np
            typing (TYPE_CHECKING, Callable, List, Iterable)
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports color constants (BLUE_B, BLUE_D, BLUE_E, GREY_BROWN, WHITE)</description>
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports base Mobject class</description>
            <filepath>manimlib.mobject.types.vectorized_mobject</filepath>
            <description>Imports VGroup and VMobject classes</description>
            <filepath>manimlib.utils.rate_functions</filepath>
            <description>Imports smooth function for animation timing</description>
            <filepath>manimlib.typing</filepath>
            <description>Imports custom types (ManimColor, Vect3, Self)</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__ (AnimatedBoundary)">
            <description>Initializes an AnimatedBoundary object that creates an animated boundary effect around a VMobject</description>
            <args>
                vmobject: VMobject
                colors: List[ManimColor] - default colors list
                max_stroke_width: float - default 3.0
                cycle_rate: float - default 0.5
                back_and_forth: bool - default True
                draw_rate_func: Callable - default smooth
                fade_rate_func: Callable - default smooth
            </args>
            <returns />
            <side-effects>
                Initializes instance variables and adds boundary copies as children
                Sets up an updater function
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="update_boundary_copies">
            <description>Updates the animated boundary effect over time</description>
            <args>
                dt: float - time delta
            </args>
            <returns>Self</returns>
            <side-effects>
                Updates the appearance of boundary copies
                Increments total_time
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="full_family_become_partial">
            <description>Makes one mobject's family partially become another mobject's family</description>
            <args>
                mob1: VMobject
                mob2: VMobject
                a: float - start ratio
                b: float - end ratio
            </args>
            <returns>Self</returns>
            <side-effects>
                Modifies mob1's family members to partially match mob2's
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="__init__ (TracedPath)">
            <description>Initializes a TracedPath object that creates a path following a point</description>
            <args>
                traced_point_func: Callable[[], Vect3]
                time_traced: float - default np.inf
                time_per_anchor: float - default 1.0/15
                stroke_width: float | Iterable[float] - default 2.0
                stroke_color: ManimColor - default WHITE
            </args>
            <returns />
            <side-effects>
                Initializes instance variables
                Sets up an updater function
                Sets stroke properties
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="update_path">
            <description>Updates the traced path over time</description>
            <args>
                dt: float - time delta
            </args>
            <returns>Self</returns>
            <side-effects>
                Updates traced points list
                Updates path appearance
                Increments time
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="__init__ (TracingTail)">
            <description>Initializes a TracingTail object, which is a specialized TracedPath that creates a fading tail effect</description>
            <args>
                mobject_or_func: Mobject | Callable[[], np.ndarray]
                time_traced: float - default 1.0
                stroke_width: float | Iterable[float] - default (0, 3)
                stroke_opacity: float | Iterable[float] - default (0, 1)
                stroke_color: ManimColor - default WHITE
            </args>
            <returns />
            <side-effects>
                Initializes parent TracedPath
                Sets up stroke updater
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements classes for creating visual effects in Manim animations. It includes AnimatedBoundary for creating animated borders around objects, TracedPath for creating paths that follow points, and TracingTail for creating fading tail effects behind moving objects.
    </file-summary></file>
      <file name="coordinate_systems.py"><declarations>
        <constants>
            EPSILON = 1e-8
            DEFAULT_X_RANGE = (-8.0, 8.0, 1.0)
            DEFAULT_Y_RANGE = (-4.0, 4.0, 1.0)
        </constants>
    </declarations>
    <dependencies>
        <external>
            - abc (ABC, abstractmethod)
            - numbers
            - numpy (np)
            - itertools (it)
            - typing (various type hints)
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports various constants for colors, directions, and layout</description>
            <filepath>manimlib.mobject.*</filepath>
            <description>Imports various mobject classes for geometric shapes and visualization</description>
            <filepath>manimlib.utils.*</filepath>
            <description>Imports utility functions for calculations and operations</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="coords_to_point">
            <description>Abstract method to convert coordinates to points in the coordinate system</description>
            <args>*coords: float | VectN</args>
            <returns>Vect3 | Vect3Array</returns>
            <side-effects>None</side-effects>
            <errors-and-exceptions>
                <handled>None</handled>
                <unhandled>Raises Exception if not implemented</unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_graph">
            <description>Creates a parametric curve representing a function graph</description>
            <args>
                - function: Callable[[float], float]
                - x_range: Optional[Sequence[float]]
                - bind: bool
                - **kwargs
            </args>
            <returns>ParametricCurve</returns>
            <side-effects>
                - Binds graph to function if bind=True
            </side-effects>
            <errors-and-exceptions>
                <handled>None</handled>
                <unhandled>None</unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines coordinate system classes for the Manim animation library. It includes:
        - Abstract CoordinateSystem base class
        - Axes class for 2D coordinate systems
        - ThreeDAxes for 3D coordinate systems
        - NumberPlane for 2D grids
        - ComplexPlane for complex number visualization
        
        The classes provide functionality for:
        - Converting between coordinates and points
        - Drawing graphs of functions
        - Creating axis labels and gridlines
        - Handling geometric transformations
        - Supporting mathematical visualizations
    </file-summary></file>
      <file name="frame.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            <dependency>typing</dependency>
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports BLACK, GREY_E, and FRAME_HEIGHT constants used for default values in rectangle classes</description>
            <filepath>manimlib.mobject.geometry</filepath>
            <description>Imports Rectangle class which is the parent class for ScreenRectangle</description>
            <filepath>manimlib.typing</filepath>
            <description>Imports ManimColor type for type hinting</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__ (ScreenRectangle)">
            <description>Initializes a ScreenRectangle with specified aspect ratio and height</description>
            <args>
                aspect_ratio: float = 16.0/9.0
                height: float = 4
                **kwargs: additional keyword arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Initializes instance attributes through parent class Rectangle
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="__init__ (FullScreenRectangle)">
            <description>Initializes a FullScreenRectangle with default screen height and styling</description>
            <args>
                height: float = FRAME_HEIGHT
                fill_color: ManimColor = GREY_E
                fill_opacity: float = 1
                stroke_width: float = 0
                **kwargs: additional keyword arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Initializes instance attributes through parent class ScreenRectangle
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="__init__ (FullScreenFadeRectangle)">
            <description>Initializes a FullScreenFadeRectangle with semi-transparent black fill</description>
            <args>
                stroke_width: float = 0.0
                fill_color: ManimColor = BLACK
                fill_opacity: float = 0.7
                **kwargs: additional keyword arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Initializes instance attributes through parent class FullScreenRectangle
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines three rectangle classes used for screen and overlay effects in Manim animations. ScreenRectangle provides a basic rectangle with configurable aspect ratio, FullScreenRectangle extends it to cover the full frame, and FullScreenFadeRectangle provides a semi-transparent overlay effect. All classes inherit from Rectangle and build upon each other through inheritance.
    </file-summary></file>
      <file name="functions.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            isosurfaces.plot_isoline
            numpy
            typing (Callable, Sequence, Tuple, TYPE_CHECKING)
        </external>
        <internal>
            <filepath>
                manimlib.constants (FRAME_X_RADIUS, FRAME_Y_RADIUS, YELLOW)
                manimlib.mobject.types.vectorized_mobject (VMobject)
                manimlib.typing (ManimColor, Vect3)
            </filepath>
            <description>
                Imports constants for frame dimensions and colors, base VMobject class for vector graphics, and custom typing definitions for colors and 3D vectors
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_point_from_function">
            <description>
                Converts a parameter t to a point in 3D space using the curve's function
            </description>
            <args>
                t: float - Parameter value
            </args>
            <returns>
                Vect3 - 3D point coordinates
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="init_points">
            <description>
                Initializes the points of the parametric curve, handling discontinuities
            </description>
            <args>
            </args>
            <returns>
                self - Returns the instance for method chaining
            </returns>
            <side-effects>
                Modifies the object's points and paths
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_t_func">
            <description>
                Returns the parametric function of the curve
            </description>
            <args>
            </args>
            <returns>
                Callable - The parametric function
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_function">
            <description>
                Returns the underlying function if it exists
            </description>
            <args>
            </args>
            <returns>
                Callable or None
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_x_range">
            <description>
                Returns the x range of the function if it exists
            </description>
            <args>
            </args>
            <returns>
                Tuple[float, float, float] or None
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines classes for creating mathematical function visualizations in Manim. It includes ParametricCurve for parametric equations, FunctionGraph for regular functions, and ImplicitFunction for implicit equations. Each class extends VMobject and provides methods for generating points and handling various function types.
    </file-summary></file>
      <file name="geometry.py"><declarations>
        <constants>
            DEFAULT_DOT_RADIUS = 0.08
            DEFAULT_SMALL_DOT_RADIUS = 0.04
            DEFAULT_DASH_LENGTH = 0.05
            DEFAULT_ARROW_TIP_LENGTH = 0.35
            DEFAULT_ARROW_TIP_WIDTH = 0.35
        </constants>
    </declarations>
    <dependencies>
        <external>
            math
            numbers
            numpy
            typing
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports various geometric constants and colors used throughout the file</description>
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports base Mobject class</description>
            <filepath>manimlib.mobject.types.vectorized_mobject</filepath>
            <description>Imports vector-based mobject classes</description>
            <filepath>manimlib.utils.bezier</filepath>
            <description>Imports bezier curve utilities for path calculations</description>
            <filepath>manimlib.utils.space_ops</filepath>
            <description>Imports spatial operation utilities for geometric calculations</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>Constructor for TipableVMobject class that initializes basic geometric shapes that can have tips</description>
            <args>
                tip_config: dict - Configuration for tip styling
            </args>
            <returns />
            <side-effects>
                Initializes instance variables
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="add_tip">
            <description>Adds a tip to a TipableVMobject instance</description>
            <args>
                at_start: bool - Whether to add tip at start
                **kwargs - Additional tip configuration
            </args>
            <returns>Self reference</returns>
            <side-effects>
                Modifies the mobject by adding a tip
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains geometric shape definitions for the Manim animation library. It defines various basic shapes like lines, circles, polygons, arrows etc. as vector-based mobjects. The shapes support features like tips, dashing, rounding of corners etc. The file makes heavy use of vector mathematics and bezier curves for shape construction and manipulation.
    </file-summary></file>
      <file name="interactive.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            numpy as np
            pyglet.window.key as PygletWindowKeys
            typing (TYPE_CHECKING, Callable)
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports various constants for dimensions, directions, colors, and spacing</description>
            
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports base Mobject and Group classes</description>
            
            <filepath>manimlib.mobject.geometry</filepath>
            <description>Imports geometric shape classes like Circle, Line, Rectangle</description>
            
            <filepath>manimlib.utils.color</filepath>
            <description>Imports color utility functions</description>
            
            <filepath>manimlib.utils.space_ops</filepath>
            <description>Imports spatial operation utilities</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="mob_on_mouse_drag">
            <description>Handles mouse drag events for MotionMobject</description>
            <args>mob: Mobject, event_data: dict[str, np.ndarray]</args>
            <returns>bool</returns>
            <side-effects>Updates mobject position</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="assert_value">
            <description>Validates value for control mobjects</description>
            <args>value: float/bool (depending on control type)</args>
            <returns />
            <side-effects />
            <errors-and-exceptions>
                <handled>AssertionError for invalid values</handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="set_value_anim">
            <description>Updates visual representation when control value changes</description>
            <args>value: float/bool/str (depending on control type)</args>
            <returns />
            <side-effects>Updates visual elements of controls</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements interactive UI controls for Manim animations. It includes classes for draggable objects (MotionMobject), buttons (Button), and various controls like checkboxes, sliders, color pickers, and text input boxes. The file also implements a control panel to organize and manage these interactive elements. The controls use event listeners for mouse and keyboard interaction and maintain state through ValueTracker objects.
    </file-summary></file>
      <file name="matrix.py"><declarations>
        <external>
            StringMatrixType = Union[Sequence[Sequence[str]], np.ndarray[int, np.dtype[np.str_]]]
            FloatMatrixType = Union[Sequence[Sequence[float]], VectNArray]
            VMobjectMatrixType = Sequence[Sequence[VMobject]]
            GenericMatrixType = Union[FloatMatrixType, StringMatrixType, VMobjectMatrixType]
        </external>
    </declarations>
    <dependencies>
        <external>
            itertools
            numpy
            typing
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports constants like DOWN, LEFT, RIGHT, ORIGIN, DEGREES for positioning and rotation</description>
            <filepath>manimlib.mobject.numbers</filepath>
            <description>Imports DecimalNumber for number representation</description>
            <filepath>manimlib.mobject.svg.tex_mobject</filepath>
            <description>Imports Tex for LaTeX rendering</description>
            <filepath>manimlib.mobject.types.vectorized_mobject</filepath>
            <description>Imports VGroup and VMobject base classes</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="Matrix.__init__">
            <description>Constructor for Matrix class that creates a visual matrix representation</description>
            <args>
                matrix: GenericMatrixType - The matrix data
                v_buff: float - Vertical buffer between elements
                h_buff: float - Horizontal buffer between elements
                bracket_h_buff: float - Horizontal buffer for brackets
                bracket_v_buff: float - Vertical buffer for brackets
                height: float | None - Optional height of matrix
                element_config: dict - Configuration for matrix elements
                element_alignment_corner: Vect3 - Alignment corner for elements
                ellipses_row: Optional[int] - Row for ellipsis
                ellipses_col: Optional[int] - Column for ellipsis
            </args>
            <returns />
            <side-effects>
                Initializes matrix object with visual elements
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="Matrix.create_mobject_matrix">
            <description>Creates and organizes the matrix of visual mobjects</description>
            <args>
                matrix: GenericMatrixType - Input matrix
                v_buff: float - Vertical buffer
                h_buff: float - Horizontal buffer
                aligned_corner: Vect3 - Alignment corner
                **element_config - Additional configuration
            </args>
            <returns>VMobjectMatrixType - Matrix of visual objects</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements various matrix classes for the Manim animation library. The main Matrix class provides functionality to create visual representations of matrices with customizable formatting, including support for numbers, text, and other visual objects. It includes specialized subclasses like DecimalMatrix, IntegerMatrix, TexMatrix, and MobjectMatrix for specific use cases. The implementation handles matrix creation, element positioning, bracket rendering, and special features like ellipsis insertion.
    </file-summary></file>
      <file name="mobject.py"><declarations>
        
        SubmobjectType = TypeVar('SubmobjectType', bound='Mobject')
    </declarations>
    <dependencies>
        <external>
            moderngl
            numpy
            copy
            functools
            itertools
            os
            pickle
            random
            sys
            numbers
            typing
        </external>
        <internal>
            <filepath>manimlib/constants.py</filepath>
            <description>Imports various constants used for positioning and default values</description>
            
            <filepath>manimlib/event_handler</filepath>
            <description>Event handling functionality for mobject interactions</description>
            
            <filepath>manimlib/logger.py</filepath>
            <description>Logging utilities</description>
            
            <filepath>manimlib/shader_wrapper.py</filepath>
            <description>Shader management functionality</description>
            
            <filepath>manimlib/utils/</filepath>
            <description>Various utility functions for colors, iterables, bezier curves, paths, shaders and space operations</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>Constructor for base Mobject class that initializes core properties</description>
            <args>
                color: ManimColor = WHITE
                opacity: float = 1.0
                shading: Tuple[float, float, float] = (0.0, 0.0, 0.0)
                texture_paths: dict[str, str] | None = None
                is_fixed_in_frame: bool = False
                depth_test: bool = False
                z_index: int = 0
            </args>
            <returns />
            <side-effects>
                Initializes internal state of the mobject including data, uniforms, updaters and event listeners
            </side-effects>
        </function>

        <function name="add">
            <description>Adds submobjects to this mobject</description>
            <args>*mobjects: Mobject</args>
            <returns>Self</returns>
            <side-effects>
                Modifies submobjects list and parent references
            </side-effects>
        </function>

        <function name="set_color">
            <description>Sets the color of the mobject</description>
            <args>
                color: ManimColor | Iterable[ManimColor] | None
                opacity: float | Iterable[float] | None = None
                recurse: bool = True
            </args>
            <returns>Self</returns>
            <side-effects>
                Modifies color data of mobject and optionally submobjects
            </side-effects>
        </function>
    </function-defs>
    <file-summary>
        This file defines the core Mobject class which is the base class for all mathematical objects in manim. It provides functionality for:
        - Object transformation (scaling, rotation, position)
        - Color and appearance management
        - Event handling
        - Shader management
        - Animation support
        - Hierarchical object relationships (parent/child)
        
        The file also includes supporting classes like Group and Point.
    </file-summary></file>
      <file name="mobject_update_utils.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            inspect
            typing (TYPE_CHECKING, Callable)
            numpy (imported conditionally)
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports DEGREES and RIGHT constants for animation parameters</description>
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports Mobject class which is core to the utility functions</description>
            <filepath>manimlib.utils.simple_functions</filepath>
            <description>Imports clip function for animation timing control</description>
            <filepath>manimlib.animation.animation</filepath>
            <description>Imports Animation class (conditionally) for type hints</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="assert_is_mobject_method">
            <description>Validates that a given method belongs to a Mobject instance</description>
            <args>method: A method to validate</args>
            <returns />
            <side-effects />
            <errors-and-exceptions>
                <handled>AssertionError if method is not a method or not from Mobject</handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="always">
            <description>Adds a permanent updater to a mobject that calls the given method with specified arguments</description>
            <args>method: Mobject method, *args: Variable arguments, **kwargs: Keyword arguments</args>
            <returns>Mobject: The modified mobject</returns>
            <side-effects>Adds an updater to the mobject</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="f_always">
            <description>Functional version of always that takes argument generators instead of direct arguments</description>
            <args>method: Mobject method, *arg_generators: Functions that generate arguments, **kwargs: Keyword arguments</args>
            <returns>Mobject: The modified mobject</returns>
            <side-effects>Adds an updater to the mobject</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="always_redraw">
            <description>Creates a mobject that continuously redraws itself using the provided function</description>
            <args>func: Callable returning a Mobject, *args: Arguments for func, **kwargs: Keyword arguments for func</args>
            <returns>Mobject: The continuously updating mobject</returns>
            <side-effects>Adds an updater that redraws the mobject</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="always_shift">
            <description>Makes a mobject continuously shift in a specified direction</description>
            <args>mobject: Mobject, direction: np.ndarray = RIGHT, rate: float = 0.1</args>
            <returns>Mobject: The continuously shifting mobject</returns>
            <side-effects>Adds an updater that shifts the mobject</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="always_rotate">
            <description>Makes a mobject continuously rotate</description>
            <args>mobject: Mobject, rate: float = 20 * DEGREES, **kwargs: Additional rotation parameters</args>
            <returns>Mobject: The continuously rotating mobject</returns>
            <side-effects>Adds an updater that rotates the mobject</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="turn_animation_into_updater">
            <description>Converts an animation into an updater function that can be applied to a mobject</description>
            <args>animation: Animation, cycle: bool = False, **kwargs: Animation parameters</args>
            <returns>Mobject: The mobject with the animation updater</returns>
            <side-effects>Adds an updater that applies the animation, Modifies animation state</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="cycle_animation">
            <description>Creates a cycling animation updater</description>
            <args>animation: Animation, **kwargs: Animation parameters</args>
            <returns>Mobject: The mobject with the cycling animation updater</returns>
            <side-effects>Adds a cycling animation updater to the mobject</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file provides utility functions for updating Mobject instances in the Manim library. It includes functions for adding continuous updates, transforming animations into updaters, and creating perpetual movements like rotation and shifting. The utilities are essential for creating dynamic animations and continuous transformations in Manim animations.
    </file-summary></file>
      <file name="number_line.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            numpy as np
            typing (TYPE_CHECKING, Iterable, Optional)
        </external>
        <internal>
            <filepath>
                manimlib.constants
                manimlib.mobject.geometry
                manimlib.mobject.numbers
                manimlib.mobject.types.vectorized_mobject
                manimlib.utils.bezier
                manimlib.utils.dict_ops
                manimlib.utils.simple_functions
                manimlib.typing
            </filepath>
            <description>
                Imports various constants, geometric objects, number handling, vector operations, and utility functions needed for number line visualization and manipulation
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>
                Initializes a NumberLine object with customizable properties like range, color, ticks, and numbers
            </description>
            <args>
                x_range: RangeSpecifier - Range specification for the number line
                color: ManimColor - Color of the line
                stroke_width: float - Width of the line
                unit_size: float - Size of one unit in spatial distance
                width: Optional[float] - Overall width of the line
                Various other parameters for ticks, numbers, and visual configuration
            </args>
            <returns>
            </returns>
            <side-effects>
                Initializes instance variables and creates visual elements of the number line
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    Index errors if x_range is empty
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_tick_range">
            <description>
                Generates an array of positions where ticks should be placed on the number line
            </description>
            <args>
            </args>
            <returns>
                np.ndarray of tick positions
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="add_ticks">
            <description>
                Adds tick marks to the number line at specified intervals
            </description>
            <args>
            </args>
            <returns>
            </returns>
            <side-effects>
                Modifies the number line by adding tick marks
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_tick">
            <description>
                Creates a single tick mark at a specified position
            </description>
            <args>
                x: float - Position on the number line
                size: float | None - Size of the tick mark
            </args>
            <returns>
                Line object representing the tick mark
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="number_to_point">
            <description>
                Converts a number to its corresponding point on the number line
            </description>
            <args>
                number: float | VectN - Number to convert
            </args>
            <returns>
                Vect3 | Vect3Array - Point coordinates
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="point_to_number">
            <description>
                Converts a point to its corresponding number on the number line
            </description>
            <args>
                point: Vect3 | Vect3Array - Point coordinates
            </args>
            <returns>
                float | VectN - Corresponding number
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    Division by zero if line has zero length
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        Implements a NumberLine class for creating and manipulating number lines in mathematical animations. The class extends Line and provides functionality for adding ticks, numbers, and customizing various visual aspects of the number line. Also includes a specialized UnitInterval class for representing the interval [0,1].
    </file-summary></file>
      <file name="numbers.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            numpy
            functools.lru_cache
            typing (TYPE_CHECKING, TypeVar)
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports directional constants (DOWN, LEFT, RIGHT, UP) and color constant WHITE</description>
            <filepath>manimlib.mobject.svg.tex_mobject</filepath>
            <description>Imports Tex class for text rendering</description>
            <filepath>manimlib.mobject.svg.text_mobject</filepath>
            <description>Imports Text class for text rendering</description>
            <filepath>manimlib.mobject.types.vectorized_mobject</filepath>
            <description>Imports VMobject base class</description>
            <filepath>manimlib.utils.paths</filepath>
            <description>Imports straight_path function for interpolation</description>
            <filepath>manimlib.utils.bezier</filepath>
            <description>Imports interpolate function for animation</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="char_to_cahced_mob">
            <description>Creates and caches Text mobjects for individual characters</description>
            <args>
                char: str - The character to convert to a mobject
                **text_config - Configuration options for text rendering
            </args>
            <returns>Text mobject representing the character</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="DecimalNumber">
            <description>A class for displaying decimal numbers as mobjects</description>
            <args>
                number: float | complex - The number to display
                Multiple configuration parameters for appearance and formatting
            </args>
            <returns>DecimalNumber instance</returns>
            <side-effects>
                Creates and manages submobjects for displaying numbers
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="Integer">
            <description>A specialized version of DecimalNumber for displaying integers</description>
            <args>
                number: int - The integer to display
                num_decimal_places: int - Number of decimal places (defaults to 0)
                **kwargs - Additional configuration parameters
            </args>
            <returns>Integer instance</returns>
            <side-effects>
                Inherits from DecimalNumber with integer-specific behavior
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements classes for displaying numbers in Manim animations. It includes DecimalNumber for floating-point and complex numbers, and Integer for whole numbers. The implementation includes sophisticated formatting options and caching mechanisms for performance optimization.
    </file-summary></file>
      <file name="probability.py"><declarations>
        <constant>EPSILON = 0.0001</constant>
    </declarations>
    <dependencies>
        <external>
            numpy
            typing (TYPE_CHECKING, Iterable)
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports various constants for colors, directions, and spacing</description>
            <filepath>manimlib.mobject.geometry</filepath>
            <description>Imports Line and Rectangle classes for geometric shapes</description>
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports base Mobject class</description>
            <filepath>manimlib.mobject.svg.brace</filepath>
            <description>Imports Brace class for annotations</description>
            <filepath>manimlib.mobject.svg.tex_mobject</filepath>
            <description>Imports Tex and TexText for text rendering</description>
            <filepath>manimlib.mobject.types.vectorized_mobject</filepath>
            <description>Imports VGroup for grouping objects</description>
            <filepath>manimlib.utils.color</filepath>
            <description>Imports color_gradient for color transitions</description>
            <filepath>manimlib.utils.iterables</filepath>
            <description>Imports listify utility function</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__ (SampleSpace)">
            <description>Initializes a SampleSpace object with customizable visual properties</description>
            <args>
                width: float = 3
                height: float = 3
                fill_color: ManimColor = GREY_D
                fill_opacity: float = 1
                stroke_width: float = 0.5
                stroke_color: ManimColor = GREY_B
                default_label_scale_val: float = 1
            </args>
            <returns />
            <side-effects>
                Initializes instance attributes
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="complete_p_list">
            <description>Completes a probability list by adding the remaining probability if sum is less than 1</description>
            <args>p_list: list[float]</args>
            <returns>list[float]</returns>
            <side-effects>None</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_division_along_dimension">
            <description>Creates divisions in the sample space along a specified dimension based on probabilities</description>
            <args>
                p_list: list[float]
                dim: int
                colors: Iterable[ManimColor]
                vect: np.ndarray
            </args>
            <returns>VGroup</returns>
            <side-effects>None</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements probability-related visualization classes for the Manim library. It contains two main classes:
        1. SampleSpace: A rectangle-based visualization for probability spaces with methods for divisions and labels
        2. BarChart: A visualization class for creating animated bar charts with customizable properties
        
        The file provides functionality for creating visual representations of probability concepts and statistical data.
    </file-summary></file>
      <file name="shape_matchers.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            from __future__ import annotations
            from colour import Color
            from typing import TYPE_CHECKING, Sequence
        </external>
        <internal>
            <filepath>
                from manimlib.constants import BLACK, RED, YELLOW, WHITE
                from manimlib.constants import DL, DOWN, DR, LEFT, RIGHT, UL, UR
                from manimlib.constants import SMALL_BUFF
                from manimlib.mobject.geometry import Line, Rectangle
                from manimlib.mobject.types.vectorized_mobject import VGroup, VMobject
                from manimlib.utils.customization import get_customization
            </filepath>
            <description>
                Imports various constants, geometric primitives, and utility functions needed for shape matching and manipulation
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="SurroundingRectangle.__init__">
            <description>
                Initializes a rectangle that surrounds a given mobject with specified properties
            </description>
            <args>
                mobject: Mobject - object to surround
                buff: float - padding around the mobject (default: SMALL_BUFF)
                color: ManimColor - color of rectangle (default: YELLOW)
                **kwargs: additional arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Sets up the surrounding rectangle and fixes it in frame if the mobject is fixed
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="SurroundingRectangle.surround">
            <description>
                Updates the rectangle to surround a given mobject
            </description>
            <args>
                mobject: Mobject - object to surround
                buff: Optional[float] - padding around the mobject
            </args>
            <returns>
                Self - returns the instance for method chaining
            </returns>
            <side-effects>
                Modifies the rectangle's position and size
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="BackgroundRectangle.__init__">
            <description>
                Creates a background rectangle behind a mobject with customizable properties
            </description>
            <args>
                mobject: Mobject - object to create background for
                color: Optional[ManimColor] - background color
                stroke_width: float - width of stroke (default: 0)
                stroke_opacity: float - opacity of stroke (default: 0)
                fill_opacity: float - opacity of fill (default: 0.75)
                buff: float - padding around mobject (default: 0)
                **kwargs: additional arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates a background rectangle with specified properties
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="Cross.__init__">
            <description>
                Creates a cross (X) shape over a given mobject
            </description>
            <args>
                mobject: Mobject - object to cross out
                stroke_color: ManimColor - color of cross (default: RED)
                stroke_width: float | Sequence[float] - width of stroke lines
                **kwargs: additional arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates two crossing lines with specified properties
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="Underline.__init__">
            <description>
                Creates an underline beneath a given mobject
            </description>
            <args>
                mobject: Mobject - object to underline
                buff: float - space between object and underline (default: SMALL_BUFF)
                stroke_color: ManimColor - color of underline (default: WHITE)
                stroke_width: float | Sequence[float] - width of stroke
                stretch_factor: float - how much to stretch underline relative to object width
                **kwargs: additional arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates an underline with specified properties
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines classes for creating visual annotations around mobjects in Manim animations, including surrounding rectangles, background rectangles, crosses (X marks), and underlines. Each class provides customization options for appearance and positioning relative to the target mobject.
    </file-summary></file>
      <directory name="svg">
        <directory-summary>The svg directory in manimlib/mobject/svg contains core classes and utilities for handling SVG-based visual elements in Manim animations. This directory provides several key functionalities:

1. SVG Handling:
- Base SVG parsing and rendering (svg_mobject.py)
- Conversion of SVG paths to Manim vector objects
- Caching mechanisms for improved performance

2. Text and TeX Rendering:
- LaTeX rendering through Tex and TexText classes (tex_mobject.py)
- Modern text rendering using Pango (text_mobject.py)
- Legacy TeX support (old_tex_mobject.py)
- String manipulation base classes (string_mobject.py)

3. Common Visual Elements:
- Braces and brackets (brace.py)
- Special text formatting like titles and bullet lists (special_tex.py)
- Pre-made drawings and icons (drawings.py) including:
  - Common symbols (checkmarks, X marks)
  - Objects (lightbulbs, laptops)
  - Speech bubbles
  - Interface elements

This directory is fundamental for creating text-based and vector graphics animations in Manim, providing both low-level SVG handling and high-level convenience classes for common animation elements. Users typically interact with the high-level classes (like Text, Tex, or SVGMobject) while the underlying implementation handles complex SVG parsing and rendering.</directory-summary><file name="__init__.py"><file-summary>This is an empty __init__.py file in the manim/manimlib/mobject/svg directory. Its presence marks the directory as a Python package, allowing its contents to be imported. The file contains no actual code or declarations.</file-summary></file>
        <file name="brace.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            math
            copy
            numpy
            typing
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports various constants used for positioning and spacing</description>
            <filepath>manimlib.animation.composition</filepath>
            <description>Imports AnimationGroup for combining animations</description>
            <filepath>manimlib.animation.fading</filepath>
            <description>Imports FadeIn animation</description>
            <filepath>manimlib.animation.growing</filepath>
            <description>Imports GrowFromCenter animation</description>
            <filepath>manimlib.mobject.svg.tex_mobject</filepath>
            <description>Imports Tex and TexText classes for LaTeX rendering</description>
            <filepath>manimlib.mobject.svg.text_mobject</filepath>
            <description>Imports Text class for text rendering</description>
            <filepath>manimlib.mobject.types.vectorized_mobject</filepath>
            <description>Imports VGroup and VMobject base classes</description>
            <filepath>manimlib.utils.iterables</filepath>
            <description>Imports listify utility function</description>
            <filepath>manimlib.utils.space_ops</filepath>
            <description>Imports get_norm for vector operations</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>Initializes a Brace object that creates a curly brace under a given mobject</description>
            <args>
                mobject: Mobject - The object to put the brace under
                direction: Vect3 - Direction vector for brace placement (default: DOWN)
                buff: float - Buffer space (default: 0.2)
                tex_string: str - LaTeX string for brace (default: R"\underbrace{\qquad}")
                **kwargs - Additional keyword arguments
            </args>
            <returns />
            <side-effects>
                Modifies the position and rotation of the mobject and brace
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="set_initial_width">
            <description>Sets the initial width of the brace</description>
            <args>
                width: float - Target width for the brace
            </args>
            <returns>
                Returns self (Brace instance)
            </returns>
            <side-effects>
                Modifies the width of the brace object
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="put_at_tip">
            <description>Places a mobject at the tip of the brace</description>
            <args>
                mob: Mobject - The mobject to place at the tip
                use_next_to: bool - Whether to use next_to method (default: True)
                **kwargs - Additional keyword arguments
            </args>
            <returns>
                Returns self (Brace instance)
            </returns>
            <side-effects>
                Modifies the position of the input mobject
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements the Brace class and related classes (BraceLabel, BraceText) for creating and manipulating curly braces in mathematical animations. The Brace class extends Tex to create customizable braces that can be placed relative to other objects, with methods for positioning and sizing. BraceLabel and BraceText provide additional functionality for adding labels to braces.
    </file-summary></file>
        <file name="drawings.py"><declarations>
        
        file_name = "lightbulb" (in Lightbulb class)
        file_name = "video_icon" (in VideoIcon class)
        file_name = "Bubbles_speech.svg" (in Bubble class)
        file_name = "earth" (in VectorizedEarth class)
        bubble_center_adjustment_factor = 0.125 (in Bubble class)
    </declarations>
    <dependencies>
        <external>
            numpy as np
            itertools as it
            random
            typing (TYPE_CHECKING, Tuple, Sequence, Callable)
        </external>
        <internal>
            <filepath>manimlib.animation.composition</filepath>
            <description>Imports AnimationGroup for animation composition</description>
            <filepath>manimlib.constants</filepath>
            <description>Imports various constants for colors, directions, and measurements</description>
            <filepath>manimlib.mobject.*</filepath>
            <description>Imports various mobject classes for geometric shapes and SVG handling</description>
            <filepath>manimlib.utils.*</filepath>
            <description>Imports utility functions for bezier curves, iterables, rate functions and space operations</description>
        </internal>
    </dependencies>
    <function-defs>
        
    </function-defs>
    <file-summary>
        This file contains various drawing classes for creating visual elements in Manim animations. It includes implementations for:
        - Basic symbols (Checkmark, Exmark)
        - Common objects (Lightbulb, Laptop, Clock)
        - Interface elements (VideoIcon, VideoSeries)
        - Speech and thought bubbles
        - Specialized objects (Piano, Dartboard, DieFace)
        
        Each class extends basic Manim mobjects (VMobject, SVGMobject, etc.) and provides customization options through their constructors.
    </file-summary></file>
        <file name="old_tex_mobject.py"><declarations>
        SCALE_FACTOR_PER_FONT_POINT = 0.001
    </declarations>
    <dependencies>
        <external>
            functools.reduce
            operator
            re
            typing
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports BLACK and WHITE color constants</description>
            <filepath>manimlib.mobject.svg.svg_mobject</filepath>
            <description>Imports SVGMobject as base class</description>
            <filepath>manimlib.mobject.types.vectorized_mobject</filepath>
            <description>Imports VGroup for grouping mobjects</description>
            <filepath>manimlib.utils.tex_file_writing</filepath>
            <description>Imports tex_content_to_svg_file for converting TeX to SVG</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>Constructor for SingleStringTex class that initializes a TeX string as an SVG mobject</description>
            <args>
                tex_string: str - The TeX string to render
                height: float | None - Optional height override
                fill_color: ManimColor - Color to fill the text
                fill_opacity: float - Opacity of the fill
                stroke_width: float - Width of the stroke
                Additional configuration parameters for SVG and TeX rendering
            </args>
            <returns />
            <side-effects>
                Initializes instance variables and calls parent constructor
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_modified_expression">
            <description>Modifies a TeX string to handle special cases and ensure valid TeX syntax</description>
            <args>
                tex_string: str - The TeX string to modify
            </args>
            <returns>
                str - Modified TeX string
            </returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="balance_braces">
            <description>Ensures TeX string has balanced braces by adding missing ones</description>
            <args>
                tex: str - TeX string to balance
            </args>
            <returns>
                str - Balanced TeX string
            </returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="break_up_tex_strings">
            <description>Breaks up TeX strings based on substrings to isolate</description>
            <args>
                tex_strings: Iterable[str] - TeX strings to break up
                substrings_to_isolate: List[str] - Substrings to isolate in the breaking process
            </args>
            <returns>
                Iterable[str] - Broken up TeX strings
            </returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines classes for rendering TeX expressions in Manim animations. The main classes are SingleStringTex for rendering single TeX expressions, OldTex for handling multiple TeX expressions with color mapping and isolation capabilities, and OldTexText for text-mode TeX rendering. The classes handle TeX string preprocessing, SVG conversion, and provide utilities for manipulating and styling TeX mobjects.
    </file-summary></file>
        <file name="special_tex.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            <dependency>typing</dependency>
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports various constants for spacing, colors, and directions used in text formatting and layout</description>
            <filepath>manimlib.mobject.geometry</filepath>
            <description>Imports Line class for underline functionality in Title class</description>
            <filepath>manimlib.mobject.types.vectorized_mobject</filepath>
            <description>Imports VGroup class which BulletedList inherits from</description>
            <filepath>manimlib.mobject.svg.tex_mobject</filepath>
            <description>Imports TexText class which is used as base class for custom text classes</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__ (BulletedList)">
            <description>Constructor for BulletedList class that creates a formatted bullet-point list</description>
            <args>
                *items: str - Variable number of string items for the list
                buff: float - Space between items (default: MED_LARGE_BUFF)
                aligned_edge: Vect3 - Edge to align items to (default: LEFT)
                **kwargs - Additional keyword arguments
            </args>
            <returns />
            <side-effects>
                Initializes the VGroup with formatted text items
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="fade_all_but">
            <description>Fades all items in the bullet list except for the specified index</description>
            <args>
                index: int - Index of item to remain unfaded
                opacity: float - Opacity level for faded items (default: 0.25)
            </args>
            <returns />
            <side-effects>
                Modifies the opacity of items in the list
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    IndexError if index is out of range
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="__init__ (TexTextFromPresetString)">
            <description>Constructor for TexTextFromPresetString that creates text with preset string and color</description>
            <args>
                **kwargs - Keyword arguments for customization
            </args>
            <returns />
            <side-effects>
                Creates a TexText object with preset configurations
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="__init__ (Title)">
            <description>Constructor for Title class that creates a title with optional underline</description>
            <args>
                *text_parts: str - Variable number of text parts
                font_size: int - Size of the font (default: 72)
                include_underline: bool - Whether to include underline (default: True)
                underline_width: float - Width of underline
                match_underline_width_to_text: bool - Whether underline matches text width
                underline_buff: float - Space between text and underline
                underline_style: dict - Style properties for underline
                **kwargs - Additional keyword arguments
            </args>
            <returns />
            <side-effects>
                Creates a title object with specified formatting and optional underline
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines special text-related classes for the Manim library, including BulletedList for creating bullet-point lists, TexTextFromPresetString for preset text configurations, and Title for creating formatted titles with optional underlines. These classes extend basic text functionality with specific formatting and animation capabilities.
    </file-summary></file>
        <file name="string_mobject.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            abc
            itertools
            re
            scipy.optimize
            scipy.spatial.distance
            typing
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports WHITE color constant</description>
            <filepath>manimlib.logger</filepath>
            <description>Imports logging functionality</description>
            <filepath>manimlib.mobject.svg.svg_mobject</filepath>
            <description>Imports SVGMobject base class</description>
            <filepath>manimlib.mobject.types.vectorized_mobject</filepath>
            <description>Imports VMobject and VGroup classes</description>
            <filepath>manimlib.utils.color</filepath>
            <description>Imports color utility functions</description>
            <filepath>manimlib.typing</filepath>
            <description>Imports type hints</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>Initializes a StringMobject with given string and styling parameters</description>
            <args>
                string: str
                fill_color: ManimColor = WHITE
                fill_border_width: float = 0.5
                stroke_color: ManimColor = WHITE 
                stroke_width: float = 0
                base_color: ManimColor = WHITE
                isolate: Selector = ()
                protect: Selector = ()
                use_labelled_svg: bool = False
                **kwargs
            </args>
            <returns />
            <side-effects>
                Initializes instance attributes and calls parent class initialization
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>

        <function name="get_file_path">
            <description>Gets the file path for the SVG file</description>
            <args>
                is_labelled: bool = False
            </args>
            <returns>str - File path</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>

        <function name="assign_labels_by_color">
            <description>Assigns numerical labels to mobjects based on their fill colors</description>
            <args>
                mobjects: list[VMobject]
            </args>
            <returns />
            <side-effects>
                Modifies the label attribute of input mobjects
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    Handles unrecognizable colors by setting label to 0 and logging warning
                </handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines the StringMobject abstract base class which serves as a parent class for Tex and MarkupText objects in Manim. It provides functionality for handling text-based SVG objects with support for substring isolation, color labeling, and pattern matching. The class includes methods for parsing strings, managing SVG files, and manipulating text segments with various selectors.
    </file-summary></file>
        <file name="svg_mobject.py"><declarations>
        <variable>SVG_HASH_TO_MOB_MAP: dict[int, list[VMobject]] = {}</variable>
        <variable>PATH_TO_POINTS: dict[str, Vect3Array] = {}</variable>
    </declarations>
    <dependencies>
        <external>
            numpy
            svgelements
            xml.etree.ElementTree
            io
            os
            typing
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports RIGHT constant for orientation</description>
            
            <filepath>manimlib.logger</filepath>
            <description>Imports logging functionality</description>
            
            <filepath>manimlib.mobject.geometry</filepath>
            <description>Imports geometric primitives like Circle, Line, Polygon, etc.</description>
            
            <filepath>manimlib.mobject.types.vectorized_mobject</filepath>
            <description>Imports VMobject base class</description>
            
            <filepath>manimlib.utils.directories</filepath>
            <description>Imports utility for getting mobject data directory</description>
            
            <filepath>manimlib.utils.images</filepath>
            <description>Imports utility for handling vector image paths</description>
            
            <filepath>manimlib.utils.iterables</filepath>
            <description>Imports hashing utilities</description>
            
            <filepath>manimlib.utils.simple_functions</filepath>
            <description>Imports string hashing functionality</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="_convert_point_to_3d">
            <description>Converts 2D coordinates to 3D by adding a zero z-coordinate</description>
            <args>
                x: float - x coordinate
                y: float - y coordinate
            </args>
            <returns>numpy.ndarray - 3D point array</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        
        <function name="SVGMobject.__init__">
            <description>Initializes an SVG mobject with various style and dimension options</description>
            <args>
                file_name: str - Path to SVG file
                should_center: bool - Whether to center the mobject
                height: float - Target height
                width: float - Target width
                Various style parameters (color, fill, stroke, etc.)
            </args>
            <returns />
            <side-effects>
                Initializes the SVG mobject's properties and appearance
                Modifies the object's position and dimensions
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Could fail if SVG file is invalid or not found
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements SVG parsing and rendering functionality for Manim. It defines two main classes:
        1. SVGMobject: Main class for converting SVG files into Manim mobjects
        2. VMobjectFromSVGPath: Helper class for converting SVG paths into vector mobjects
        
        The file handles SVG parsing, transformation, and conversion of various SVG elements (paths, lines, rectangles, etc.) into Manim's geometric primitives. It includes caching mechanisms for both parsed SVGs and path points to improve performance.
    </file-summary></file>
        <file name="tex_mobject.py"><declarations>
        SCALE_FACTOR_PER_FONT_POINT = 0.001
    </declarations>
    <dependencies>
        <external>
            re
            typing
        </external>
        <internal>
            <filepath>
                manimlib.mobject.svg.string_mobject
                manimlib.mobject.types.vectorized_mobject
                manimlib.utils.color
                manimlib.utils.tex_file_writing
                manimlib.utils.tex
                manimlib.logger
                manimlib.typing
            </filepath>
            <description>
                Imports various mobject types, color utilities, tex processing utilities, and typing support for creating and manipulating tex-based visual elements
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>
                Constructor for Tex class that initializes a tex-based mobject with various styling and formatting options
            </description>
            <args>
                tex_strings: str - One or more tex strings to render
                font_size: int = 48 - Size of the font
                alignment: str = R"\centering" - Tex alignment
                template: str = "" - Template for tex content
                additional_preamble: str = "" - Additional tex preamble content
                tex_to_color_map: dict = dict() - Mapping of tex to colors
                t2c: dict = dict() - Alias for tex_to_color_map
                isolate: Selector = [] - Elements to isolate
                use_labelled_svg: bool = True - Whether to use labelled SVG
                **kwargs - Additional keyword arguments
            </args>
            <returns />
            <side-effects>
                Initializes instance variables and scales the mobject
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_command_matches">
            <description>
                Static method that parses tex commands and their matching braces from a string
            </description>
            <args>
                string: str - The tex string to parse
            </args>
            <returns>
                list[re.Match] - List of regex matches for commands and braces
            </returns>
            <side-effects />
            <errors-and-exceptions>
                <handled>
                    ValueError - For mismatched braces
                </handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="make_number_changeable">
            <description>
                Converts a number in the tex string to a DecimalNumber mobject that can be animated
            </description>
            <args>
                value: float | int | str - The number to make changeable
                index: int = 0 - Which occurrence of the number to change
                replace_all: bool = False - Whether to replace all occurrences
                **config - Additional configuration for DecimalNumber
            </args>
            <returns>
                VMobject or VGroup - The created decimal number mobject(s)
            </returns>
            <side-effects>
                Modifies the underlying mobject structure and string representation
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    Logs warnings for value not found or invalid index
                </handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines the Tex and TexText classes for rendering LaTeX content in Manim animations. The Tex class extends StringMobject to handle LaTeX-specific formatting, styling, and manipulation, including color mapping and number animations. It includes methods for parsing tex commands, handling braces, and converting numbers to animatable DecimalNumber objects.
    </file-summary></file>
        <file name="text_mobject.py"><declarations>
        <variable>TEXT_MOB_SCALE_FACTOR = 0.0076</variable>
        <variable>DEFAULT_LINE_SPACING_SCALE = 0.6</variable>
        <variable>DEFAULT_CANVAS_WIDTH = 16384</variable>
        <variable>DEFAULT_CANVAS_HEIGHT = 16384</variable>
    </declarations>
    <dependencies>
        <external>
            manimpango
            pygments
            contextlib
            os
            pathlib
            re
            typing
        </external>
        <internal>
            <filepath>manimlib/constants</filepath>
            <description>Imports constants like DEFAULT_PIXEL_WIDTH, FRAME_WIDTH, NORMAL</description>
            <filepath>manimlib/logger</filepath>
            <description>Imports logging functionality</description>
            <filepath>manimlib/mobject/svg/string_mobject</filepath>
            <description>Imports base StringMobject class</description>
            <filepath>manimlib/utils/customization</filepath>
            <description>Imports customization utilities</description>
            <filepath>manimlib/utils/color</filepath>
            <description>Imports color conversion utilities</description>
            <filepath>manimlib/utils/directories</filepath>
            <description>Imports directory path utilities</description>
            <filepath>manimlib/utils/simple_functions</filepath>
            <description>Imports hash_string utility</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="register_font">
            <description>Context manager to temporarily add a font file to Pango's search path</description>
            <args>
                font_file: str | Path - Path to the font file to register
            </args>
            <returns>
                Context manager yield
            </returns>
            <side-effects>
                Temporarily modifies Pango's font search path
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    FileNotFoundError - If font file not found
                    AttributeError - If used on macOS with older ManimPango
                </handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements text rendering functionality for Manim using Pango. It defines three main classes:
        - MarkupText: Base class for rendering Pango markup text
        - Text: Simplified text rendering without markup
        - Code: Specialized text class for syntax-highlighted code
        The file handles font management, text styling, and SVG generation for text objects.
    </file-summary></file>
      </directory>
      <file name="three_dimensions.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            math
            numpy
            typing (TYPE_CHECKING, Tuple, TypeVar)
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports various constants like BLUE, BLUE_D, BLUE_E, GREY_A, BLACK, IN, ORIGIN, OUT, RIGHT, PI, TAU</description>
            
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports base Mobject class</description>
            
            <filepath>manimlib.mobject.types.surface</filepath>
            <description>Imports SGroup and Surface classes for 3D surface handling</description>
            
            <filepath>manimlib.mobject.types.vectorized_mobject</filepath>
            <description>Imports VGroup and VMobject for vector-based objects</description>
            
            <filepath>manimlib.mobject.geometry</filepath>
            <description>Imports Polygon and Square classes</description>
            
            <filepath>manimlib.utils.bezier</filepath>
            <description>Imports interpolate function for bezier curves</description>
            
            <filepath>manimlib.utils.iterables</filepath>
            <description>Imports adjacent_pairs utility function</description>
            
            <filepath>manimlib.utils.space_ops</filepath>
            <description>Imports spatial operation utilities</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="square_to_cube_faces">
            <description>Converts a square into six faces of a cube by creating copies and rotating them appropriately</description>
            <args>square: T (TypeVar bound to Mobject)</args>
            <returns>list[T] - List of six square faces positioned to form a cube</returns>
            <side-effects>None</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements various 3D geometric shapes and utilities for the Manim animation library. It includes classes for creating 3D surfaces (SurfaceMesh), basic 3D shapes (Sphere, Torus, Cylinder, Cube, etc.), and vector-based 3D objects (VCube, VPrism, Dodecahedron). The file provides functionality for creating and manipulating 3D objects with customizable properties like color, opacity, and shading.
    </file-summary></file>
      <directory name="types">
        <directory-summary>The `types` directory in manimlib/mobject contains core classes for different types of visual objects (mobjects) in Manim. It includes:

1. Dot Cloud Objects (`dot_cloud.py`): Classes for creating and manipulating collections of dots in 3D space, with features like grid arrangement and glow effects.

2. Image Objects (`image_mobject.py`): Handles displaying and manipulating images in animations through the ImageMobject class, supporting operations like resizing and opacity control.

3. Point Cloud Objects (`point_cloud_mobject.py`): Implements PMobject and PGroup classes for point-based graphics, providing functionality for point manipulation and color handling.

4. Surface Objects (`surface.py`): Defines classes for creating and manipulating 3D surfaces, including parametric and textured surfaces, with support for proper 3D rendering.

5. Vectorized Objects (`vectorized_mobject.py`): Contains the fundamental VMobject class that represents shapes using bezier curves, forming the basis for most geometric animations in Manim.

This directory provides the foundational object types that can be used to create various visual elements in Manim animations. Each type is optimized for different use cases: VMobjects for geometric shapes, PMobjects for point-based graphics, Surfaces for 3D objects, ImageMobjects for images, and DotClouds for particle-like effects.</directory-summary><file name="__init__.py"><file-summary>This is an empty __init__.py file in the manimlib/mobject/types directory. Its presence marks this directory as a Python package, allowing its modules to be imported. The file contains no actual code or declarations.</file-summary></file>
        <file name="dot_cloud.py"><declarations>
        DEFAULT_DOT_RADIUS = 0.05
        DEFAULT_GLOW_DOT_RADIUS = 0.2
        DEFAULT_GRID_HEIGHT = 6
        DEFAULT_BUFF_RATIO = 0.5
    </declarations>
    <dependencies>
        <external>
            moderngl
            numpy
            typing
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports constants like GREY_C, YELLOW, ORIGIN, NULL_POINTS for default values and positioning</description>
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports base Mobject class for inheritance</description>
            <filepath>manimlib.mobject.types.point_cloud_mobject</filepath>
            <description>Imports PMobject for point cloud functionality</description>
            <filepath>manimlib.utils.iterables</filepath>
            <description>Imports resize_with_interpolation utility function</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>Constructor for DotCloud class initializing a point cloud with specified attributes</description>
            <args>
                points: Vect3Array - Array of 3D points
                color: ManimColor - Color of dots
                opacity: float - Opacity value
                radius: float - Dot radius
                glow_factor: float - Glow effect intensity
                anti_alias_width: float - Anti-aliasing width
            </args>
            <returns />
            <side-effects>
                Initializes instance variables and calls parent constructor
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="to_grid">
            <description>Arranges dots in a grid pattern</description>
            <args>
                n_rows: int - Number of rows
                n_cols: int - Number of columns
                n_layers: int - Number of layers
                buff_ratio: float - Buffer ratio
                h_buff_ratio: float - Horizontal buffer ratio
                v_buff_ratio: float - Vertical buffer ratio
                d_buff_ratio: float - Depth buffer ratio
                height: float - Grid height
            </args>
            <returns>Self - Returns the modified instance</returns>
            <side-effects>
                Modifies the points arrangement of the dot cloud
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="set_radii">
            <description>Sets the radii of all dots in the cloud</description>
            <args>
                radii: npt.ArrayLike - Array of radius values
            </args>
            <returns>Self - Returns the modified instance</returns>
            <side-effects>
                Modifies the radius data of the dot cloud
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements dot cloud visualization classes for Manim. The main class DotCloud inherits from PMobject and provides functionality for creating and manipulating collections of dots in 3D space. It includes features for setting dot properties like radius, color, and glow effects. The file also includes specialized classes TrueDot, GlowDots, and GlowDot for specific dot visualization needs.
    </file-summary></file>
        <file name="image_mobject.py"><declarations>
        shader_folder: str = "image"
        data_dtype: Sequence[Tuple[str, type, Tuple[int]]]
        render_primitive: int = moderngl.TRIANGLES
    </declarations>
    <dependencies>
        <external>
            numpy
            moderngl
            PIL.Image
            typing
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports directional constants (DL, DR, UL, UR) for positioning</description>
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports base Mobject class that ImageMobject extends</description>
            <filepath>manimlib.utils.bezier</filepath>
            <description>Imports inverse_interpolate for color sampling calculations</description>
            <filepath>manimlib.utils.images</filepath>
            <description>Imports utility for getting full image path</description>
            <filepath>manimlib.utils.iterables</filepath>
            <description>Imports list manipulation utilities</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>Constructor for ImageMobject class that initializes an image with specified dimensions</description>
            <args>
                filename: str - path to the image file
                height: float = 4.0 - desired height of the image
                **kwargs - additional keyword arguments
            </args>
            <returns />
            <side-effects>
                Sets instance variables and loads image file
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    File not found or invalid image file errors
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="init_data">
            <description>Initializes the data structure for the image mobject with points and coordinates</description>
            <args />
            <returns>None</returns>
            <side-effects>
                Modifies internal data arrays for points, image coordinates, and opacity
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="init_points">
            <description>Sets up the initial dimensions of the image while maintaining aspect ratio</description>
            <args />
            <returns>None</returns>
            <side-effects>
                Modifies object dimensions
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="set_opacity">
            <description>Sets the opacity of the image</description>
            <args>
                opacity: float - opacity value to set
                recurse: bool = True - whether to apply recursively
            </args>
            <returns>self - returns the modified object</returns>
            <side-effects>
                Modifies opacity data array
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="set_color">
            <description>Placeholder method that does nothing (images maintain their own colors)</description>
            <args>
                color - color value
                opacity=None - opacity value
                recurse=None - recursion flag
            </args>
            <returns>self</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="point_to_rgb">
            <description>Converts a point in space to an RGB color value from the image</description>
            <args>
                point: Vect3 - 3D point coordinates
            </args>
            <returns>numpy array of RGB values normalized to [0,1]</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Exception when point is outside image bounds
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines the ImageMobject class, which is used to display and manipulate images in Manim animations. It handles image loading, sizing, opacity control, and color sampling. The class uses OpenGL (via moderngl) for rendering and supports various image transformations while maintaining aspect ratio.
    </file-summary></file>
        <file name="point_cloud_mobject.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            numpy as np
            typing (TYPE_CHECKING, Callable)
        </external>
        <internal>
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports Mobject base class for inheritance</description>
            <filepath>manimlib.utils.color</filepath>
            <description>Imports color_gradient and color_to_rgba for color handling</description>
            <filepath>manimlib.utils.iterables</filepath>
            <description>Imports resize_with_interpolation for array manipulation</description>
            <filepath>manimlib.typing</filepath>
            <description>Imports custom type hints for Manim-specific types</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="set_points">
            <description>Sets points for the PMobject and resizes them</description>
            <args>points: Vect3Array - 3D vector array of points</args>
            <returns>Self - returns the modified instance</returns>
            <side-effects>Modifies the object's points data</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="add_points">
            <description>Adds multiple points to the PMobject with optional color data</description>
            <args>
                points: Vect3Array - Points to add
                rgbas: Vect4Array | None - Color data
                color: ManimColor | None - Color value
                opacity: float | None - Opacity value
            </args>
            <returns>Self - returns the modified instance</returns>
            <side-effects>Modifies object's points and color data</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="add_point">
            <description>Adds a single point to the PMobject</description>
            <args>
                point: Vect3 - Point to add
                rgba: Optional color data
                color: Optional color value
                opacity: Optional opacity value
            </args>
            <returns>Self - returns the modified instance</returns>
            <side-effects>Modifies object's points and color data</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="set_color_by_gradient">
            <description>Sets colors of points using a gradient between given colors</description>
            <args>*colors: ManimColor - Variable number of colors for gradient</args>
            <returns>Self - returns the modified instance</returns>
            <side-effects>Modifies object's color data</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="match_colors">
            <description>Matches colors with another PMobject</description>
            <args>pmobject: PMobject - Object to match colors with</args>
            <returns>Self - returns the modified instance</returns>
            <side-effects>Modifies object's color data</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="filter_out">
            <description>Filters out points based on a condition</description>
            <args>condition: Callable[[np.ndarray], bool] - Function to filter points</args>
            <returns>Self - returns the modified instance</returns>
            <side-effects>Modifies object's point data</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="sort_points">
            <description>Sorts points based on a given function</description>
            <args>function: Callable[[Vect3], None] - Function to sort points by</args>
            <returns>Self - returns the modified instance</returns>
            <side-effects>Modifies order of points</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="ingest_submobjects">
            <description>Combines data from all submobjects into this object</description>
            <args />
            <returns>Self - returns the modified instance</returns>
            <side-effects>Modifies object's data by combining submobject data</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="point_from_proportion">
            <description>Gets a point at a given proportion of total points</description>
            <args>alpha: float - Proportion value between 0 and 1</args>
            <returns>np.ndarray - The point at the given proportion</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="pointwise_become_partial">
            <description>Takes a portion of another PMobject's points</description>
            <args>
                pmobject: PMobject - Source object
                a: float - Start proportion
                b: float - End proportion
            </args>
            <returns>Self - returns the modified instance</returns>
            <side-effects>Modifies object's data</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines two classes: PMobject and PGroup for handling point cloud-based mobjects in Manim. PMobject extends the base Mobject class with point-specific functionality, including point manipulation, color handling, and various transformation methods. PGroup is a container class for grouping multiple PMobjects together.
    </file-summary></file>
        <file name="surface.py"><declarations>
        
        render_primitive = moderngl.TRIANGLES
        shader_folder = "surface"
        data_dtype = numpy structured dtype for point, du_point, dv_point, rgba
        pointlike_data_keys = ['point', 'du_point', 'dv_point']
    </declarations>
    <dependencies>
        <external>
            moderngl
            numpy
            typing
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports GREY and OUT constants for default colors and vectors</description>
            
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports base Mobject class that Surface inherits from</description>
            
            <filepath>manimlib.utils.bezier</filepath>
            <description>Imports interpolation utilities for surface calculations</description>
            
            <filepath>manimlib.utils.images</filepath>
            <description>Imports image path utilities for textured surfaces</description>
            
            <filepath>manimlib.utils.iterables</filepath>
            <description>Imports list manipulation utilities</description>
            
            <filepath>manimlib.utils.space_ops</filepath>
            <description>Imports vector operations for normal calculations</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="uv_func">
            <description>Base function to be implemented by subclasses that maps UV coordinates to 3D points</description>
            <args>
                u: float - U coordinate
                v: float - V coordinate
            </args>
            <returns>tuple[float, float, float] - 3D point coordinates</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        
        <function name="init_points">
            <description>Initializes the surface points based on UV coordinates</description>
            <args />
            <returns />
            <side-effects>
                Modifies the surface's point data
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        
        <function name="compute_triangle_indices">
            <description>Computes indices for triangulating the surface</description>
            <args />
            <returns>numpy.ndarray - Array of triangle indices</returns>
            <side-effects>
                Sets self.triangle_indices
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines the Surface class hierarchy for Manim, including base Surface, ParametricSurface, SGroup, and TexturedSurface classes. It provides functionality for creating and manipulating 3D surfaces with optional texturing. The surfaces are rendered using moderngl and support operations like partial creation, normal calculation, and face sorting for proper 3D rendering.
    </file-summary></file>
        <file name="vectorized_mobject.py"><declarations>
        <variable>DEFAULT_STROKE_COLOR = GREY_A</variable>
        <variable>DEFAULT_FILL_COLOR = GREY_C</variable>
        <type>SubVmobjectType = TypeVar('SubVmobjectType', bound='VMobject')</type>
    </declarations>
    <dependencies>
        <external>
            <import>moderngl</import>
            <import>numpy</import>
            <import>operator</import>
            <import>itertools</import>
            <import>functools.wraps</import>
            <import>typing</import>
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports various constants used for colors, angles, and default values</description>
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports base Mobject classes</description>
            <filepath>manimlib.utils.bezier</filepath>
            <description>Imports bezier curve utilities for path calculations</description>
            <filepath>manimlib.utils.color</filepath>
            <description>Imports color manipulation utilities</description>
            <filepath>manimlib.utils.iterables</filepath>
            <description>Imports array manipulation utilities</description>
            <filepath>manimlib.utils.space_ops</filepath>
            <description>Imports geometric operation utilities</description>
            <filepath>manimlib.shader_wrapper</filepath>
            <description>Imports shader wrapper classes for rendering</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="triggers_refresh">
            <description>Decorator that triggers refreshing of joint angles and unit normals after modifying points</description>
            <args>func: Callable - The function to decorate</args>
            <returns>Decorated function that refreshes geometry data after execution</returns>
            <side-effects>Refreshes joint angles and unit normals</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_triangulation">
            <description>Calculates triangulation of the shape for rendering</description>
            <args>self</args>
            <returns>numpy array of triangle indices</returns>
            <side-effects>None</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_joint_angles">
            <description>Calculates angles between tangent vectors at curve joints</description>
            <args>self, refresh: bool = False</args>
            <returns>numpy array of joint angles</returns>
            <side-effects>Updates joint angle data</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements vectorized mobjects (VMobject) which are the core graphics primitives in Manim. VMobjects represent shapes through quadratic bezier curves and support styling (colors, stroke width), transformations, and shader-based rendering. The file includes the main VMobject class along with utility classes like VGroup for grouping VMobjects and specialized types like VectorizedPoint and DashedVMobject.
    </file-summary></file>
      </directory>
      <file name="value_tracker.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            numpy as np
            typing (TYPE_CHECKING)
        </external>
        <internal>
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports Mobject base class for ValueTracker inheritance</description>
            <filepath>manimlib.utils.iterables</filepath>
            <description>Imports listify utility function for array conversion</description>
            <filepath>manimlib.typing</filepath>
            <description>Imports Self type for type hinting</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>Constructor for ValueTracker class that initializes the value attribute</description>
            <args>
                value: float | complex | np.ndarray (default=0)
                **kwargs: Additional keyword arguments passed to parent class
            </args>
            <returns />
            <side-effects>
                Sets instance attribute 'value'
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="init_uniforms">
            <description>Initializes uniform values for the tracker, converting the value to a numpy array</description>
            <args />
            <returns>None</returns>
            <side-effects>
                Sets uniforms["value"] with numpy array of the value
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_value">
            <description>Retrieves the current value from the uniforms dictionary</description>
            <args />
            <returns>float | complex | np.ndarray</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="set_value">
            <description>Sets a new value in the uniforms dictionary</description>
            <args>value: float | complex | np.ndarray</args>
            <returns>Self (instance of ValueTracker)</returns>
            <side-effects>
                Modifies uniforms["value"]
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="increment_value">
            <description>Increments the current value by a given amount</description>
            <args>d_value: float | complex</args>
            <returns>None</returns>
            <side-effects>
                Modifies the tracked value through set_value
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines three classes for tracking numerical values in animations:
        1. ValueTracker: A basic tracker that stores and manipulates numerical values
        2. ExponentialValueTracker: A tracker that handles values in exponential space
        3. ComplexValueTracker: A tracker specifically for complex numbers
        
        These classes are not meant to be displayed but rather used to encode numbers that other animations can reference and update.
    </file-summary></file>
      <file name="vector_field.py"><declarations>
        None at file level
    </declarations>
    <dependencies>
        <external>
            numpy
            itertools
            typing
        </external>
        <internal>
            <filepath>manimlib/constants</filepath>
            <description>Imports various constants like FRAME_HEIGHT, FRAME_WIDTH, colors, and ORIGIN</description>
            <filepath>manimlib/animation/indication</filepath>
            <description>Imports VShowPassingFlash for animations</description>
            <filepath>manimlib/mobject/geometry</filepath>
            <description>Imports Arrow class for vector visualization</description>
            <filepath>manimlib/utils/*</filepath>
            <description>Imports various utility functions for bezier curves, colors, dictionaries, etc.</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_vectorized_rgb_gradient_function">
            <description>Creates a function that maps values to RGB colors using a color map</description>
            <args>
                min_value: T - Minimum value for gradient
                max_value: T - Maximum value for gradient 
                color_map: str - Name of color map to use
            </args>
            <returns>Callable function that converts values to RGB colors</returns>
            <side-effects>None</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="move_along_vector_field">
            <description>Adds an updater to move a mobject along a vector field</description>
            <args>
                mobject: Mobject - Object to move
                func: Callable - Vector field function
            </args>
            <returns>Modified mobject with updater</returns>
            <side-effects>Modifies the input mobject by adding an updater</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements vector field visualization in Manim. It contains classes and functions for creating and animating vector fields, including VectorField for static fields, TimeVaryingVectorField for dynamic fields, and StreamLines for flow visualization. The code provides utilities for mapping vector magnitudes to colors, moving objects along vector fields, and creating smooth animations of field lines.
    </file-summary></file>
    </directory>
    <directory name="scene">
      <directory-summary>The manimlib/scene/scene directory contains the core scene management functionality for the Manim animation engine. It consists of three main components:

1. scene.py - Contains the primary Scene class that serves as the foundation for creating mathematical animations. It handles animation playback, scene setup, and interactive features. This is the main class that users inherit from when creating their own animations.

2. interactive_scene.py - Provides the InteractiveScene class, extending Scene with real-time manipulation capabilities. It enables users to interact with mobjects during playback through mouse and keyboard controls, offering features like selection, movement, resizing, and color modification.

3. scene_file_writer.py - Manages all output operations through the SceneFileWriter class, handling video rendering, frame writing, image saving, and audio processing. It works closely with the Scene class to produce the final animation outputs.

Together, these files form the backbone of Manim's scene management system, providing both programmatic and interactive ways to create mathematical animations while handling all necessary input/output operations. Users typically interact with this directory's components by inheriting from Scene or InteractiveScene when creating their own animation scripts.</directory-summary><file name="__init__.py"><file-summary>This is an empty __init__.py file in the manimlib/scene directory. Its presence marks the directory as a Python package, allowing its contents to be imported. The file contains no actual code or declarations.</file-summary></file>
      <file name="interactive_scene.py"><declarations>
        
        SELECT_KEY = 's'
        UNSELECT_KEY = 'u'
        GRAB_KEY = 'g'
        X_GRAB_KEY = 'h'
        Y_GRAB_KEY = 'v'
        GRAB_KEYS = [GRAB_KEY, X_GRAB_KEY, Y_GRAB_KEY]
        RESIZE_KEY = 't'
        COLOR_KEY = 'c'
        INFORMATION_KEY = 'i'
        CURSOR_KEY = 'k'
        COPY_FRAME_POSITION_KEY = 'p'
    </declarations>
    <dependencies>
        <external>
            itertools
            numpy
            pyperclip
            IPython.core.getipython
            typing
        </external>
        <internal>
            <filepath>
                manimlib.animation.fading
                manimlib.constants
                manimlib.mobject.geometry
                manimlib.mobject.mobject
                manimlib.mobject.numbers
                manimlib.mobject.svg.tex_mobject
                manimlib.mobject.svg.text_mobject
                manimlib.mobject.types.dot_cloud
                manimlib.mobject.types.vectorized_mobject
                manimlib.scene.scene
                manimlib.utils.family_ops
                manimlib.utils.space_ops
                manimlib.utils.tex_file_writing
            </filepath>
            <description>
                Imports various Manim components for scene management, mobjects, animations, and utilities needed for interactive scene functionality
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="InteractiveScene">
            <description>
                A Scene subclass that enables interactive manipulation of mobjects through mouse and keyboard controls
            </description>
            <args>
                Inherits from Scene class
            </args>
            <returns>
                None
            </returns>
            <side-effects>
                Creates an interactive scene with selection, manipulation and other interactive capabilities
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    LatexError when pasting invalid LaTeX
                    ValueError when parsing clipboard content
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements an interactive scene class for Manim that allows real-time manipulation of mobjects through mouse and keyboard controls. It provides functionality for selecting, moving, resizing, copying, and modifying mobjects interactively during scene playback. The class includes features like selection highlighting, color palette, information display, and various transformation controls.
    </file-summary></file>
      <file name="scene.py"><declarations>
        PAN_3D_KEY = 'd'
        FRAME_SHIFT_KEY = 'f'
        RESET_FRAME_KEY = 'r'
        QUIT_KEY = 'q'
    </declarations>
    <dependencies>
        <external>
            collections.OrderedDict
            inspect
            os
            platform
            pyperclip
            random
            time
            re
            functools.wraps
            IPython.terminal
            numpy
            tqdm.auto
            typing
        </external>
        <internal>
            <filepath>manimlib/animation/animation.py</filepath>
            <description>Imports animation preparation utilities and base Animation class</description>
            
            <filepath>manimlib/camera/camera.py</filepath>
            <description>Imports Camera class for scene rendering</description>
            
            <filepath>manimlib/constants.py</filepath>
            <description>Imports various constants used throughout the scene</description>
            
            <filepath>manimlib/event_handler/</filepath>
            <description>Imports event handling functionality for interactive scenes</description>
            
            <filepath>manimlib/mobject/</filepath>
            <description>Imports core mobject classes and utilities</description>
            
            <filepath>manimlib/scene/scene_file_writer.py</filepath>
            <description>Imports SceneFileWriter for saving animations</description>
            
            <filepath>manimlib/utils/</filepath>
            <description>Imports various utility functions</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>Initializes a new Scene instance with configuration for animations, camera, window and file writing</description>
            <args>
                window_config: dict - Configuration for display window
                camera_config: dict - Configuration for scene camera
                file_writer_config: dict - Configuration for writing files
                skip_animations: bool - Whether to skip animation rendering
                always_update_mobjects: bool - Whether to update mobjects every frame
                start_at_animation_number: int - Animation number to start from
                end_at_animation_number: int - Animation number to end at
                leave_progress_bars: bool - Whether to leave progress bars after completion
                preview: bool - Whether to show preview window
                presenter_mode: bool - Whether to enable presenter mode
                show_animation_progress: bool - Whether to show animation progress
                embed_exception_mode: str - Exception handling mode for embedded shell
                embed_error_sound: bool - Whether to play sound on embed errors
            </args>
            <returns />
            <side-effects>
                Initializes scene state and configuration
                Creates window if preview is enabled
                Sets up camera and file writer
            </side-effects>
        </function>

        <function name="play">
            <description>Plays one or more animations in sequence</description>
            <args>
                *proto_animations: Animation objects to play
                run_time: float - Duration of animations
                rate_func: function - Rate function for animations
                lag_ratio: float - Lag ratio between animations
            </args>
            <returns />
            <side-effects>
                Updates scene state
                Renders animations to screen/file
                Increments animation counter
            </side-effects>
        </function>

        <function name="wait">
            <description>Pauses scene for specified duration</description>
            <args>
                duration: float - Time to wait
                stop_condition: function - Optional condition to stop waiting
                note: str - Optional note for presenter mode
                ignore_presenter_mode: bool - Whether to ignore presenter mode
            </args>
            <returns />
            <side-effects>
                Updates scene state
                Renders frames during wait period
            </side-effects>
        </function>
    </function-defs>
    <file-summary>
        This file implements the core Scene class that manages the rendering and animation of mathematical objects in manim. It handles scene setup, animation playback, interactive development features, and event handling for user input. The Scene class serves as the base for creating mathematical animations and presentations.
    </file-summary></file>
      <file name="scene_file_writer.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            numpy
            pydub
            tqdm
            PIL
        </external>
        <internal>
            <filepath>manimlib/constants.py</filepath>
            <description>Imports FFMPEG_BIN constant for video processing</description>
            
            <filepath>manimlib/logger.py</filepath>
            <description>Imports logging functionality</description>
            
            <filepath>manimlib/mobject/mobject.py</filepath>
            <description>Imports Mobject class for scene objects</description>
            
            <filepath>manimlib/utils/file_ops.py</filepath>
            <description>Imports utility functions for file operations</description>
            
            <filepath>manimlib/utils/sounds.py</filepath>
            <description>Imports sound utility functions</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>Initializes the SceneFileWriter with configuration for video/image output</description>
            <args>
                scene: Scene object
                write_to_movie: bool
                break_into_partial_movies: bool
                save_pngs: bool
                png_mode: str
                save_last_frame: bool
                movie_file_extension: str
                input_file_path: str
                output_directory: str|None
                file_name: str|None
                and other configuration parameters
            </args>
            <returns />
            <side-effects>
                Initializes instance variables
                Creates output directories
                Initializes audio settings
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>

        <function name="write_frame">
            <description>Writes a single frame to the movie file</description>
            <args>camera: Camera - The camera object containing frame data</args>
            <returns />
            <side-effects>
                Writes raw frame data to the movie file
                Updates progress display
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>

        <function name="combine_movie_files">
            <description>Combines partial movie files into a single output file</description>
            <args />
            <returns />
            <side-effects>
                Creates a file list of partial movies
                Combines movies using ffmpeg
                Creates final output file
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        The SceneFileWriter class handles all video and image output operations for Manim scenes. It manages writing frames to video files, combining partial videos, handling audio, and saving final images. It provides functionality for both video and image output with various configuration options and progress tracking.
    </file-summary></file>
    </directory>
    <file name="shader_wrapper.py"><declarations>
        None at file level
    </declarations>
    <dependencies>
        <external>
            OpenGL.GL
            moderngl
            numpy
            functools.lru_cache
            typing
        </external>
        <internal>
            <filepath>manimlib.config</filepath>
            <description>Used for parsing CLI arguments and getting configuration</description>
            <filepath>manimlib.utils.iterables</filepath>
            <description>Used for array resizing operations</description>
            <filepath>manimlib.utils.shaders</filepath>
            <description>Provides shader utility functions for code loading, program creation, and texture handling</description>
            <filepath>manimlib.typing</filepath>
            <description>Custom type definitions</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>Constructor for ShaderWrapper class that initializes shader program and related OpenGL objects</description>
            <args>
                ctx: moderngl.context.Context
                vert_data: np.ndarray
                shader_folder: Optional[str]
                mobject_uniforms: Optional[UniformDict]
                texture_paths: Optional[dict[str, str]]
                depth_test: bool
                render_primitive: int
                code_replacements: dict[str, str]
            </args>
            <returns />
            <side-effects>
                Initializes multiple instance attributes and OpenGL objects
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Potential OpenGL errors during program/texture creation
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="init_program_code">
            <description>Initializes shader program code by loading from files</description>
            <args>self</args>
            <returns>None</returns>
            <side-effects>
                Sets self.program_code dictionary
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    File IO errors when loading shader code
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="render">
            <description>Renders the shader program using vertex array objects</description>
            <args>self</args>
            <returns>None</returns>
            <side-effects>
                Performs OpenGL rendering operations
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    OpenGL rendering errors
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements shader wrapper classes (ShaderWrapper and VShaderWrapper) that handle OpenGL shader program management, including initialization, uniform setting, texture management, and rendering. The classes provide an abstraction layer for working with shaders in the Manim animation library, supporting both basic shader operations and specialized vector graphics rendering.
    </file-summary></file>
    <directory name="shaders">
      <directory-summary>The shaders directory contains the core GLSL shader implementations used throughout Manim for various rendering tasks. It is organized into several key subdirectories:

1. image/ - Contains shaders for image rendering with proper texture sampling and opacity handling.

2. inserts/ - Houses reusable GLSL code snippets that are included in other shaders via a custom #INSERT directive system. Contains core functionality like complex math, position emission, and color processing.

3. mandelbrot_fractal/ - Implements shaders for rendering Mandelbrot and Julia set fractals with customizable coloring and parameters.

4. newton_fractal/ - Contains shaders for visualizing Newton fractals, showing convergence to polynomial roots with interactive coloring.

5. quadratic_bezier/ - Houses shaders for rendering quadratic Bezier curves, split into three sub-components:
   - depth/ - For proper 3D depth handling
   - fill/ - For filling shapes bounded by Bezier curves
   - stroke/ - For rendering curve strokes with various joint types

6. surface/ - Implements shaders for rendering 3D surfaces with proper lighting and normal calculations.

7. textured_surface/ - Contains shaders for rendering textured 3D surfaces with support for light/dark texture mixing.

8. true_dot/ - Implements high-quality dot rendering with glow effects and proper 3D perspective.

The directory also includes simple_vert.glsl, a basic vertex shader used as a starting point for simpler rendering tasks. All shaders are written in GLSL 330 and form the foundation of Manim's graphics rendering pipeline, enabling high-quality mathematical animations and visualizations.</directory-summary><directory name="image">
        <directory-summary>This directory contains the GLSL shader files specifically designed for image rendering in the Manim library. It consists of two key shader files:

1. vert.glsl - A vertex shader that handles the initial processing of image vertices. It takes vertex positions, texture coordinates, and opacity values as inputs, and prepares this data for the fragment shader stage. It relies on an external position emission function.

2. frag.glsl - A fragment shader that performs the actual texture sampling and color output. It uses the texture coordinates and opacity values passed from the vertex shader to sample the image texture and apply the proper transparency.

Together, these shaders form the core of Manim's image rendering pipeline, enabling the library to display and manipulate images with proper positioning and opacity. The shaders are written in GLSL 3.30 and are designed to work as a pair, with the vertex shader preparing the necessary attributes that the fragment shader needs to properly render image textures.</directory-summary><file name="frag.glsl"><declarations>
        uniform sampler2D Texture;
        in vec2 v_im_coords;
        in float v_opacity;
        out vec4 frag_color;
    </declarations>
    <dependencies>
        <external>
            OpenGL GLSL 3.30
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Fragment shader main function that samples a texture at given coordinates and applies opacity
            </description>
            <args>
            </args>
            <returns>
            </returns>
            <side-effects>
                Sets the frag_color output variable with the sampled texture color modified by opacity
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL fragment shader file that handles texture sampling and opacity for image rendering. It takes texture coordinates and an opacity value as inputs, samples a texture at the given coordinates, and outputs the final color with the applied opacity. The shader is part of Manim's image rendering pipeline.
    </file-summary></file>
        <file name="vert.glsl"><declarations>
        <variable>uniform sampler2D Texture</variable>
        <variable>in vec3 point</variable>
        <variable>in vec2 im_coords</variable>
        <variable>in float opacity</variable>
        <variable>out vec2 v_im_coords</variable>
        <variable>out float v_opacity</variable>
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>emit_gl_Position.glsl</filepath>
            <description>
                Included via #INSERT directive, likely contains the implementation of emit_gl_Position function used for vertex positioning
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Main vertex shader function that processes vertex attributes and prepares data for fragment shader
            </description>
            <args>
                
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Sets v_im_coords to input im_coords
                Sets v_opacity to input opacity
                Calls emit_gl_Position with point parameter
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    
                </handled>
                <unhandled>
                    
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a vertex shader written in GLSL version 330. It's designed to process image-related vertex data, taking in texture coordinates and opacity values, and passing them to the fragment shader. It uses a custom position emission function included from another file. The shader is part of Manim's image rendering pipeline.
    </file-summary></file>
      </directory>
      <directory name="inserts">
        <directory-summary>The "inserts" directory contains GLSL shader code snippets that are designed to be included in other shader files using Manim's custom #INSERT directive system. These files provide core shader functionality for the Manim animation engine:

1. NOTE.md explains the shader inclusion mechanism and warns about uniform declaration conflicts.

2. complex_functions.glsl provides essential complex number operations (multiplication, division, power) implemented using vec2 for graphics calculations.

3. emit_gl_Position.glsl handles the crucial vertex transformation pipeline, converting 3D positions to clip space coordinates with support for frame-fixed objects and custom clipping planes.

4. finalize_color.glsl manages color processing and lighting calculations, including colormap interpolation and light effect application.

5. get_unit_normal.glsl computes unit normal vectors from three points, handling various geometric edge cases.

6. get_xyz_to_uv.glsl contains geometric transformation utilities, particularly for mapping bezier curves to parabolas and creating various transformation matrices.

These files serve as building blocks for Manim's shader system, providing reusable functionality that can be inserted into other shaders using the #INSERT directive. They handle core graphics operations like coordinate transformations, lighting, color processing, and geometric calculations necessary for rendering mathematical animations.</directory-summary><file name="NOTE.md"><file-summary>This file explains the shader code inclusion mechanism used in Manim. Since OpenGL shaders lack a direct equivalent to C++'s #include directive, Manim implements a custom solution using #INSERT directives. When a line contains "#INSERT &lt;file_name&gt;", it gets replaced with the contents of the corresponding file from the inserts folder. The note also warns that since these inserted files may contain uniform declarations, users should avoid redeclaring these uniforms in the surrounding context to prevent conflicts.</file-summary></file>
        <file name="complex_functions.glsl"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            
        </internal>
    </dependencies>
    <function-defs>
        <function name="complex_mult">
            <description>
                Performs complex number multiplication of two 2D vectors representing complex numbers
            </description>
            <args>
                vec2 z: First complex number as a 2D vector (real, imaginary)
                vec2 w: Second complex number as a 2D vector (real, imaginary)
            </args>
            <returns>
                vec2: Result of complex multiplication (real, imaginary)
            </returns>
            <side-effects>
                
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    
                </handled>
                <unhandled>
                    
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="complex_div">
            <description>
                Performs complex number division of two 2D vectors representing complex numbers
            </description>
            <args>
                vec2 z: Numerator complex number as a 2D vector (real, imaginary)
                vec2 w: Denominator complex number as a 2D vector (real, imaginary)
            </args>
            <returns>
                vec2: Result of complex division (real, imaginary)
            </returns>
            <side-effects>
                
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    
                </handled>
                <unhandled>
                    Division by zero when w is (0,0)
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="complex_pow">
            <description>
                Calculates the nth power of a complex number represented as a 2D vector
            </description>
            <args>
                vec2 z: Base complex number as a 2D vector (real, imaginary)
                int n: Power to raise the complex number to
            </args>
            <returns>
                vec2: Result of complex number raised to power n
            </returns>
            <side-effects>
                
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    
                </handled>
                <unhandled>
                    Potential infinite loop if n is negative
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        A GLSL shader file that implements basic complex number operations (multiplication, division, and power) using 2D vectors to represent complex numbers. Each component of the vec2 represents the real and imaginary parts of the complex number.
    </file-summary></file>
        <file name="emit_gl_Position.glsl"><declarations>
        <variable>uniform float is_fixed_in_frame</variable>
        <variable>uniform mat4 view</variable>
        <variable>uniform float focal_distance</variable>
        <variable>uniform vec3 frame_rescale_factors</variable>
        <variable>uniform vec4 clip_plane</variable>
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            
        </internal>
    </dependencies>
    <function-defs>
        <function name="emit_gl_Position">
            <description>
                Transforms and projects a 3D point to clip space coordinates, handling frame-fixed objects and clipping planes
            </description>
            <args>
                vec3 point - 3D position to be transformed
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Sets gl_Position with the transformed position
                Sets gl_ClipDistance[0] if a clip plane is defined
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    
                </handled>
                <unhandled>
                    
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        A GLSL shader file that handles the transformation and projection of 3D points to clip space coordinates. It supports objects that can be fixed in frame space, applies view transformations, handles frame rescaling, and implements custom clipping planes. This is a crucial part of the rendering pipeline that determines the final screen position of vertices.
    </file-summary></file>
        <file name="finalize_color.glsl"><declarations>
        <variable>uniform vec3 light_position</variable>
        <variable>uniform vec3 camera_position</variable>
        <variable>uniform vec3 shading</variable>
    </declarations>
    <dependencies>
        <external>
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="float_to_color">
            <description>
                Converts a float value to a color by interpolating between colors in a colormap
            </description>
            <args>
                float value: The value to convert
                float min_val: Minimum value of the range
                float max_val: Maximum value of the range
                vec3[9] colormap_data: Array of colors defining the colormap
            </args>
            <returns>
                vec3: Interpolated color from the colormap
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="add_light">
            <description>
                Applies lighting effects to a color based on point position and normal
            </description>
            <args>
                vec4 color: Original color
                vec3 point: Position in 3D space
                vec3 unit_normal: Normal vector at the point
            </args>
            <returns>
                vec4: Color with lighting effects applied
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="finalize_color">
            <description>
                Final color processing function that applies lighting effects and any custom color modifications
            </description>
            <args>
                vec4 color: Original color
                vec3 point: Position in 3D space
                vec3 unit_normal: Normal vector at the point
            </args>
            <returns>
                vec4: Final processed color
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This GLSL shader file contains functions for color processing and lighting calculations. It includes functionality for converting float values to colors using a colormap, applying lighting effects based on surface normals and light position, and a final color processing function that can be customized with additional color modifications.
    </file-summary></file>
        <file name="get_unit_normal.glsl"><declarations>
    </declarations>
    <dependencies>
        <external>
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_unit_normal">
            <description>
                Calculates a unit normal vector from three points in 3D space. If the points form a triangle, returns the normal to that triangle. If they form a line, finds a normal vector to that line.
            </description>
            <args>
                vec3 p0: First point in 3D space
                vec3 p1: Second point in 3D space
                vec3 p2: Third point in 3D space
            </args>
            <returns>
                vec3: A unit normal vector
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    Handles degenerate cases where points are collinear or align with z-axis by providing alternative normal vector calculations
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This GLSL shader file contains a function that computes unit normal vectors from three input points. It handles various geometric cases including regular triangles, collinear points, and points aligned with the z-axis. The function uses a small tolerance value to handle numerical precision issues.
    </file-summary></file>
        <file name="get_xyz_to_uv.glsl"><declarations>
    </declarations>
    <dependencies>
        <external>
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="xs_on_clean_parabola">
            <description>
                Calculates two x-values where a section of the parabola y = x^2 is isometric to a given quadratic bezier curve
            </description>
            <args>
                vec3 b0, vec3 b1, vec3 b2 - Three control points for a quadratic bezier curve
            </args>
            <returns>
                vec2 - Two x-values (x0, x2) defining the parabola section
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="map_triangles">
            <description>
                Creates an affine transformation matrix that maps one triangle onto another
            </description>
            <args>
                vec3 src0, vec3 src1, vec3 src2 - Source triangle vertices
                vec3 dst0, vec3 dst1, vec3 dst2 - Destination triangle vertices
            </args>
            <returns>
                mat4 - Affine transformation matrix
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="rotation">
            <description>
                Creates a 4x4 rotation matrix around a given axis with a given cosine angle
            </description>
            <args>
                vec3 axis - Axis of rotation
                float cos_angle - Cosine of rotation angle
            </args>
            <returns>
                mat4 - Rotation matrix
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="map_onto_x_axis">
            <description>
                Creates a transformation matrix that maps a line segment onto the x-axis
            </description>
            <args>
                vec3 src0, vec3 src1 - Start and end points of the line segment
            </args>
            <returns>
                mat4 - Transformation matrix
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_xyz_to_uv">
            <description>
                Creates a transformation matrix that maps quadratic bezier control points to align with y = x^2
            </description>
            <args>
                vec3 b0, vec3 b1, vec3 b2 - Bezier control points
                float threshold - Maximum x-value threshold
                out bool exceeds_threshold - Output parameter indicating if threshold is exceeded
            </args>
            <returns>
                mat4 - Transformation matrix
            </returns>
            <side-effects>
                Sets the exceeds_threshold output parameter
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        A GLSL shader file containing utility functions for geometric transformations, particularly focused on mapping bezier curves onto parabolas and handling coordinate transformations. The file includes functions for calculating parabola parameters, creating affine transformations between triangles, and generating rotation matrices.
    </file-summary></file>
      </directory>
      <directory name="mandelbrot_fractal">
        <directory-summary>This directory contains the GLSL shader files necessary for rendering Mandelbrot and Julia set fractals in Manim. It consists of two main shader files:

1. frag.glsl - A fragment shader that handles the actual fractal computation and coloring. It:
   - Can render either Mandelbrot or Julia sets based on a uniform parameter
   - Uses an iterative process to determine if points are in the set
   - Implements a sophisticated coloring system using 9 color uniforms for gradient effects
   - Supports opacity control and custom color processing

2. vert.glsl - A vertex shader that handles the geometric setup for the fractal rendering. It:
   - Transforms input coordinates using scale and offset parameters
   - Prepares the coordinate space for the fragment shader
   - Integrates with Manim's position emission system

Together, these shaders form a complete system for GPU-accelerated fractal visualization, allowing Manim to efficiently render these mathematical structures with customizable colors, scale, and position. The implementation supports up to 5th-degree polynomial iterations (MAX_DEGREE = 5) and includes complex number arithmetic operations through dependencies on other shader utilities.</directory-summary><file name="frag.glsl"><declarations>
        <external>
            uniform vec2 parameter
            uniform float opacity
            uniform float n_steps
            uniform float mandelbrot
            uniform vec3 color0-8 (9 color uniforms)
            in vec3 xyz_coords
            out vec4 frag_color
            const int MAX_DEGREE = 5
        </external>
    </declarations>
    <dependencies>
        <internal>
            <filepath>finalize_color.glsl</filepath>
            <description>Provides finalize_color function for final color processing</description>
        </internal>
        <internal>
            <filepath>complex_functions.glsl</filepath>
            <description>Provides complex number arithmetic functions like complex_mult</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Fragment shader main function that implements Mandelbrot/Julia set visualization with color mapping
            </description>
            <args>
                
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Sets the frag_color output variable with the calculated color for the current fragment
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL fragment shader file that renders either the Mandelbrot set or Julia set based on the mandelbrot uniform variable. It implements the iterative process for determining if a point is in the set, with color mapping based on escape time. The shader uses 9 color uniforms for creating a gradient color scheme and includes functionality for opacity and final color processing.
    </file-summary></file>
        <file name="vert.glsl"><declarations>
        <variables>
            - in vec3 point
            - out vec3 xyz_coords
            - uniform float scale_factor
            - uniform vec3 offset
        </variables>
    </declarations>
    <dependencies>
        <external>
            - OpenGL GLSL 3.30
        </external>
        <internal>
            <filepath>emit_gl_Position.glsl</filepath>
            <description>
                Included via #INSERT directive, likely contains the implementation of emit_gl_Position function used in main
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Vertex shader main function that transforms input coordinates and sets gl_Position
            </description>
            <args>
                
            </args>
            <returns>
                
            </returns>
            <side-effects>
                - Sets xyz_coords output variable
                - Calls emit_gl_Position which likely sets gl_Position
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        A GLSL vertex shader file that appears to be part of a Mandelbrot fractal rendering system. It transforms input coordinates using scale and offset uniforms, and sets up the vertex position using an externally defined emit_gl_Position function.
    </file-summary></file>
      </directory>
      <directory name="newton_fractal">
        <directory-summary>This directory contains GLSL shader files that implement Newton fractal visualization in the Manim library. The two key components are:

1. frag.glsl - A fragment shader that implements the core Newton fractal visualization algorithm. It:
   - Evaluates complex polynomials and their derivatives
   - Uses Newton's method to find polynomial roots
   - Colors pixels based on root convergence
   - Supports features like Julia set highlighting and parameter space visualization
   - Handles up to 5th degree polynomials

2. vert.glsl - A vertex shader that handles the geometric transformations needed for rendering, including:
   - Coordinate transformations with scaling and offset
   - Position calculations for the rendering pipeline
   - Passing transformed coordinates to the fragment shader

Together, these shaders enable Manim to render interactive and visually appealing Newton fractals - mathematical visualizations that show how different points in the complex plane converge to the roots of a polynomial under Newton's method iteration. The implementation supports various customization options through uniform variables like coloring, saturation, and special highlighting effects.</directory-summary><file name="frag.glsl"><declarations>
        <uniform-variables>
            vec4 color0-4
            vec2 coef0-5
            vec2 root0-4
            float n_roots
            float n_steps
            float julia_highlight
            float saturation_factor
            float black_for_cycles
            float is_parameter_space
        </uniform-variables>
        <constants>
            int MAX_DEGREE = 5
            float CLOSE_ENOUGH = 1e-3
        </constants>
        <in-variables>
            vec3 xyz_coords
        </in-variables>
        <out-variables>
            vec4 frag_color
        </out-variables>
    </declarations>
    <dependencies>
        <external>
            finalize_color.glsl
            complex_functions.glsl
        </external>
        <internal />
    </dependencies>
    <function-defs>
        <function name="poly">
            <description>
                Evaluates a polynomial at point z using given coefficients
            </description>
            <args>
                vec2 z - complex number input
                vec2[MAX_DEGREE + 1] coefs - array of polynomial coefficients
            </args>
            <returns>
                vec2 - complex number result of polynomial evaluation
            </returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="dpoly">
            <description>
                Evaluates derivative of polynomial at point z using given coefficients
            </description>
            <args>
                vec2 z - complex number input
                vec2[MAX_DEGREE + 1] coefs - array of polynomial coefficients
            </args>
            <returns>
                vec2 - complex number result of polynomial derivative evaluation
            </returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="seek_root">
            <description>
                Implements Newton's method to find a root of the polynomial
            </description>
            <args>
                vec2 z - initial guess
                vec2[MAX_DEGREE + 1] coefs - polynomial coefficients
                int max_steps - maximum iterations
                out float n_iters - number of iterations taken
            </args>
            <returns>
                vec2 - found root position
            </returns>
            <side-effects>
                Modifies the out parameter n_iters
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="main">
            <description>
                Main shader function that implements Newton fractal visualization
            </description>
            <args />
            <returns />
            <side-effects>
                Sets frag_color output variable
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL fragment shader that implements Newton fractal visualization. It uses Newton's method to find roots of complex polynomials and colors the result based on which root each point converges to. It includes features for parameter space visualization and Julia set highlighting.
    </file-summary></file>
        <file name="vert.glsl"><declarations>
        <variables>
            - in vec3 point
            - out vec3 xyz_coords
            - uniform float scale_factor
            - uniform vec3 offset
        </variables>
    </declarations>
    <dependencies>
        <external>
            - OpenGL GLSL 3.30
        </external>
        <internal>
            <filepath>emit_gl_Position.glsl</filepath>
            <description>
                Included via #INSERT directive, likely contains the implementation of emit_gl_Position function used in main
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Entry point for the vertex shader that transforms input coordinates and sets the vertex position
            </description>
            <args>
                
            </args>
            <returns>
                
            </returns>
            <side-effects>
                - Sets xyz_coords output variable
                - Sets gl_Position through emit_gl_Position function
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL vertex shader file used in the Newton fractal visualization. It takes input vertex positions, applies scaling and offset transformations, and outputs transformed coordinates. The shader uses an external function emit_gl_Position to set the final vertex position. The shader is part of the graphics pipeline for rendering Newton fractals in the Manim library.
    </file-summary></file>
      </directory>
      <directory name="quadratic_bezier">
        <directory-summary>This directory contains the core GLSL shader implementations for rendering quadratic Bezier curves in Manim, organized into three main subdirectories:

1. depth/ - Contains shaders for handling proper depth rendering of Bezier curves in 3D space, ensuring correct occlusion and depth testing.

2. fill/ - Implements shaders for filling shapes bounded by quadratic Bezier curves, with support for:
   - Orientation-based filling
   - Alpha blending and transparency
   - Special handling for curve endings and full fill cases

3. stroke/ - Provides shaders for rendering stroked Bezier curves with features including:
   - Multiple joint types (none, auto, bevel, miter)
   - Anti-aliased edges
   - Variable stroke widths
   - Both 2D and 3D stroke rendering

Each subdirectory contains a complete shader pipeline (vertex, geometry, and fragment shaders) that work together to handle their specific rendering tasks. The shaders are written in GLSL 330 and form a crucial part of Manim's vector graphics rendering system, enabling high-quality mathematical animations and visualizations with proper curve rendering, filling, and stroking capabilities.</directory-summary><directory name="depth">
          <directory-summary>This directory contains a set of GLSL shader files that work together to handle depth rendering for quadratic Bezier curves in 3D space. The shader pipeline consists of three stages:

1. vert.glsl - A vertex shader that processes initial vertex attributes (positions and normals) and prepares them for the geometry stage.

2. geom.glsl - A geometry shader that generates triangle strips from the input vertices, specifically handling quadratic Bezier curves by emitting two triangles per input set. It includes logic for curve termination and proper vertex positioning.

3. frag.glsl - A fragment shader that handles depth values by outputting the z-coordinate of each fragment's position for proper depth testing in 3D rendering.

These shaders are designed to work as part of Manim's 3D rendering pipeline, specifically for rendering quadratic Bezier curves with proper depth handling. The shaders ensure that curves are correctly rendered in 3D space with appropriate depth testing and occlusion.</directory-summary><file name="frag.glsl"><declarations>
        <variable>out float frag_depth</variable>
    </declarations>
    <dependencies>
        <external>
            OpenGL GLSL version 330
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Fragment shader main function that sets the fragment depth value
            </description>
            <args>
            </args>
            <returns>
            </returns>
            <side-effects>
                Sets the frag_depth output variable to the z-coordinate of the fragment's position
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL fragment shader file that handles depth values for quadratic Bezier curves. It simply outputs the z-coordinate of each fragment's position as the depth value, which is used for depth testing in 3D rendering.
    </file-summary></file>
          <file name="geom.glsl"><declarations>
        <variable>layout (triangles) in</variable>
        <variable>layout (triangle_strip, max_vertices = 6) out</variable>
        <variable>in vec3 verts[3]</variable>
        <variable>in vec3 v_base_point[3]</variable>
        <variable>out float depth</variable>
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>emit_gl_Position.glsl</filepath>
            <description>
                Included via #INSERT directive, likely contains the implementation of emit_gl_Position function used in this shader
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="emit_triangle">
            <description>
                Emits a triangle by processing three points and emitting vertices
            </description>
            <args>
                vec3 points[3] - Array of three 3D vectors representing triangle vertices
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Emits vertices and primitives using EmitVertex() and EndPrimitive()
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    
                </handled>
                <unhandled>
                    
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="main">
            <description>
                Main entry point for the geometry shader that processes quadratic bezier curves
            </description>
            <args>
                
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Emits two triangles based on input vertices and base points
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    Handles case where curve is ended (verts[0] == verts[1])
                </handled>
                <unhandled>
                    
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL geometry shader file that processes triangles and outputs triangle strips. It's designed to handle quadratic bezier curves by emitting two triangles for each input set. The shader includes early termination for ended curves and uses an external function for position emission.
    </file-summary></file>
          <file name="vert.glsl"><declarations>
        <variable>in vec3 point</variable>
        <variable>in vec3 base_normal</variable>
        <variable>out vec3 verts</variable>
        <variable>out vec3 v_base_point</variable>
    </declarations>
    <dependencies>
        <external>
            OpenGL GLSL version 330
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Main vertex shader function that assigns input vertex attributes to output variables
            </description>
            <args>
            </args>
            <returns>
            </returns>
            <side-effects>
                Sets output variables verts and v_base_point based on input attributes
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL vertex shader file that handles the processing of vertex attributes for quadratic bezier curves. It takes input vertex position (point) and normal (base_normal) and passes them through to the fragment shader stage via output variables. The shader is written in GLSL 330 syntax.
    </file-summary></file>
        </directory>
        <directory name="fill">
          <directory-summary>This directory contains a set of GLSL shader files that work together to render filled quadratic Bezier curves in Manim. The shader pipeline consists of three stages:

1. A vertex shader (vert.glsl) that processes initial vertex data including points, colors, and normals
2. A geometry shader (geom.glsl) that generates appropriate triangles for the Bezier curves, handling both main fill and edge cases
3. A fragment shader (frag.glsl) that implements sophisticated alpha blending and determines final pixel colors

The shaders implement a specialized rendering technique that:
- Supports proper orientation-based filling
- Handles transparency and alpha blending
- Uses quadratic function tests to determine which fragments to render
- Provides special handling for full fill cases and curve endings

These shaders are designed to work as part of Manim's graphics pipeline specifically for filling shapes bounded by quadratic Bezier curves. They handle both the geometric construction and the visual appearance of filled curves, ensuring proper rendering of mathematical animations and visualizations.</directory-summary><file name="frag.glsl"><declarations>
        <variable>uniform bool winding</variable>
        <variable>in vec4 color</variable>
        <variable>in float fill_all</variable>
        <variable>in float orientation</variable>
        <variable>in vec2 uv_coords</variable>
        <variable>out vec4 frag_color</variable>
    </declarations>
    <dependencies>
        <external>
            OpenGL GLSL 330
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Fragment shader main function that handles the coloring and alpha blending of quadratic bezier curves, with special handling for orientation-based alpha blending.
            </description>
            <args>
            </args>
            <returns>
            </returns>
            <side-effects>
                Sets the output fragment color (frag_color)
                May discard fragments based on conditions
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL fragment shader file used in Manim for rendering quadratic bezier curves. It implements a sophisticated alpha blending system that allows for cancellation between positively and negatively oriented triangles. The shader also implements a quadratic function test (y = x²) to determine which fragments should be rendered. The shader handles transparency and includes special logic for full fill cases.
    </file-summary></file>
          <file name="geom.glsl"><declarations>
        <variables>
            in vec3 verts[3];
            in vec4 v_color[3];
            in vec3 v_base_normal[3];
            out vec4 color;
            out float fill_all;
            out float orientation;
            out vec2 uv_coords;
        </variables>
        <constants>
            const vec2 SIMPLE_QUADRATIC[3] = vec2[3](
                vec2(0.0, 0.0),
                vec2(0.5, 0),
                vec2(1.0, 1.0)
            );
        </constants>
    </declarations>
    <dependencies>
        <external>
            OpenGL GLSL 330
        </external>
        <internal>
            <filepath>emit_gl_Position.glsl</filepath>
            <description>Included file for emitting GL positions</description>
        </internal>
        <internal>
            <filepath>finalize_color.glsl</filepath>
            <description>Included file for finalizing color calculations</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="emit_triangle">
            <description>Emits a triangle primitive with specified points, colors, and normal</description>
            <args>
                vec3 points[3] - Array of 3D points forming the triangle
                vec4 v_color[3] - Array of colors for each vertex
                vec3 unit_normal - Normal vector for the triangle
            </args>
            <returns>
                void
            </returns>
            <side-effects>
                Sets global variables orientation, uv_coords, color
                Emits vertices and primitives to the graphics pipeline
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="main">
            <description>Main geometry shader function that processes triangles for quadratic bezier curves</description>
            <args>
            </args>
            <returns>
                void
            </returns>
            <side-effects>
                Emits two triangles for each input triangle if conditions are met
                Sets fill_all value for different triangle types
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    Early returns for zero alpha colors or when curve is marked as ended
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL geometry shader file that processes triangles for quadratic bezier curves. It takes triangles as input and outputs triangle strips. The shader handles the generation of both main and edge triangles, with proper color handling and normal calculations. It includes special handling for curve endings and zero-fill cases.
    </file-summary></file>
          <file name="vert.glsl"><declarations>
        <in>
            vec3 point
            vec4 fill_rgba
            vec3 base_normal
        </in>
        <out>
            vec3 verts
            vec4 v_color
            vec3 v_base_normal
        </out>
    </declarations>
    <dependencies>
        <external>
            OpenGL GLSL 330
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Main vertex shader function that assigns input attributes to output variables for fragment shader processing
            </description>
            <args>
            </args>
            <returns>
            </returns>
            <side-effects>
                Assigns values to output variables verts, v_color, and v_base_normal
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL vertex shader file used for quadratic Bezier curve filling in Manim. It takes in point coordinates, fill color (RGBA), and base normal vectors as inputs, and passes them through to the fragment shader as varying variables. The shader is written in GLSL version 330 and is part of Manim's rendering pipeline for filled shapes with quadratic Bezier curves.
    </file-summary></file>
        </directory>
        <directory name="stroke">
          <directory-summary>This directory contains a set of GLSL shader files that work together to render strokes for quadratic Bezier curves in Manim. The shader pipeline consists of three main components:

1. vert.glsl - A vertex shader that handles initial processing of curve vertices, including position, color, stroke width, and normal vectors. It applies necessary transformations and scaling for frame-based rendering.

2. geom.glsl - A geometry shader that generates the actual stroke geometry. It supports multiple joint types (none, auto, bevel, miter) and creates triangle strips along the Bezier curves. It handles both flat and 3D strokes with sophisticated joint handling and curve interpolation.

3. frag.glsl - A fragment shader that handles the final rendering with anti-aliasing. It calculates alpha values for smooth stroke edges based on distance to the curve and stroke width.

Together, these shaders provide a complete pipeline for high-quality rendering of stroked quadratic Bezier curves with various styling options, anti-aliasing, and proper handling of curve joints. This is a core component of Manim's vector graphics rendering system.</directory-summary><file name="frag.glsl"><declarations>
        <variable>in float dist_to_aaw</variable>
        <variable>in float half_width_to_aaw</variable>
        <variable>in vec4 color</variable>
        <variable>out vec4 frag_color</variable>
    </declarations>
    <dependencies>
        <external>
            OpenGL GLSL 330
        </external>
        <internal />
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Fragment shader main function that calculates the alpha value for antialiased stroke rendering of quadratic bezier curves
            </description>
            <args />
            <returns />
            <side-effects>
                Sets the output fragment color (frag_color) based on input parameters and distance calculations
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL fragment shader file used for rendering strokes of quadratic bezier curves with antialiasing. It takes input variables for distance to the curve and curve width (normalized by antialiasing width), and a color. It calculates the alpha value for smooth edges using these distances and applies it to the output color. The file includes a placeholder comment for additional color modifications that can be inserted by VShaderWrapper.
    </file-summary></file>
          <file name="geom.glsl"><declarations>
        
        const int NO_JOINT = 0
        const int AUTO_JOINT = 1
        const int BEVEL_JOINT = 2
        const int MITER_JOINT = 3
        const float COS_THRESHOLD = 0.999
        const float POLYLINE_FACTOR = 100
        const int MAX_STEPS = 32
        const float MITER_COS_ANGLE_THRESHOLD = -0.9

        
        uniform float anti_alias_width
        uniform float flat_stroke_float
        uniform float pixel_size
        uniform float joint_type
        uniform float frame_scale

        
        in vec3 verts[3]
        in float v_joint_angle[3]
        in float v_stroke_width[3]
        in vec4 v_color[3]
        in vec3 v_unit_normal[3]
        out vec4 color
        out float dist_to_aaw
        out float half_width_to_aaw
    </declarations>
    <dependencies>
        <external>
            #version 330
        </external>
        <internal>
            <filepath>emit_gl_Position.glsl</filepath>
            <description>Included for emit_gl_Position functionality</description>
            <filepath>finalize_color.glsl</filepath>
            <description>Included for finalize_color functionality</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="point_on_quadratic">
            <description>Calculates a point on a quadratic bezier curve at parameter t</description>
            <args>float t, vec3 c0, vec3 c1, vec3 c2</args>
            <returns>vec3 point on the curve</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="tangent_on_quadratic">
            <description>Calculates the tangent vector at a point on a quadratic bezier curve</description>
            <args>float t, vec3 c1, vec3 c2</args>
            <returns>vec3 tangent vector</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="project">
            <description>Projects a vector onto a plane perpendicular to a given unit normal</description>
            <args>vec3 vect, vec3 unit_normal</args>
            <returns>vec3 projected vector</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="rotate_vector">
            <description>Rotates a vector around a unit normal by a given angle</description>
            <args>vec3 vect, vec3 unit_normal, float angle</args>
            <returns>vec3 rotated vector</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="step_to_corner">
            <description>Calculates the step vector for creating stroke width, handling different joint types</description>
            <args>vec3 point, vec3 tangent, vec3 unit_normal, float joint_angle, bool inside_curve, bool flat_stroke</args>
            <returns>vec3 step vector</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="emit_point_with_width">
            <description>Emits two vertices for creating a triangle strip around a curve point</description>
            <args>vec3 point, vec3 tangent, float joint_angle, float width, vec4 joint_color, bool inside_curve, bool flat_stroke</args>
            <returns />
            <side-effects>Emits vertices to the geometry shader output</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="main">
            <description>Main geometry shader function that processes quadratic bezier curves and creates triangle strips for stroke rendering</description>
            <args />
            <returns />
            <side-effects>Generates geometry for rendering strokes</side-effects>
            <errors-and-exceptions>
                <handled>Checks for null strokes and ended curves</handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL geometry shader file that handles the rendering of quadratic bezier curves with various stroke styles and joint types. It processes triangles and outputs triangle strips, supporting different joint types (none, auto, bevel, miter) and handling both flat and 3D strokes with anti-aliasing.
    </file-summary></file>
          <file name="vert.glsl"><declarations>
        <variables>
            uniform float frame_scale;
            uniform float is_fixed_in_frame;
            in vec3 point;
            in vec4 stroke_rgba;
            in float stroke_width;
            in float joint_angle;
            in vec3 unit_normal;
            out vec3 verts;
            out vec4 v_color;
            out float v_stroke_width;
            out float v_joint_angle;
            out vec3 v_unit_normal;
        </variables>
        <constants>
            const float STROKE_WIDTH_CONVERSION = 0.01;
        </constants>
    </declarations>
    <dependencies>
        <external>
            OpenGL GLSL 330
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Main shader function that processes vertex attributes and passes them to the fragment shader with necessary transformations
            </description>
            <args>
                
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Sets output variables verts, v_color, v_stroke_width, v_joint_angle, and v_unit_normal
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL vertex shader file used for rendering quadratic Bezier curves. It processes vertex attributes including position, color, stroke width, joint angle, and normal vectors. The shader applies frame scaling and fixed-in-frame transformations to the stroke width. It's part of the stroke rendering pipeline for Bezier curves in Manim.
    </file-summary></file>
        </directory>
      </directory>
      <file name="simple_vert.glsl"><declarations>
        <variable>in vec3 point</variable>
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>emit_gl_Position.glsl</filepath>
            <description>
                Included via #INSERT directive, contains the emit_gl_Position function implementation
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Entry point for the vertex shader that processes vertex positions
            </description>
            <args>
                
            </args>
            <returns>
                
            </returns>
            <side-effects>
                <effect>Calls emit_gl_Position which affects the gl_Position built-in variable</effect>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        A simple vertex shader that takes a 3D point as input and processes it through emit_gl_Position function to set the final vertex position. This is a basic GLSL shader file that serves as part of the graphics pipeline in Manim.
    </file-summary></file>
      <directory name="surface">
        <directory-summary>This directory contains GLSL shader files used for rendering 3D surfaces in Manim. It consists of two main shader files:

1. vert.glsl - A vertex shader that:
   - Processes surface vertex data including positions and colors
   - Computes surface normals using derivative points (du_point, dv_point)
   - Transforms vertices and prepares them for rendering
   - Relies on several included shader utilities for position, normal, and color calculations

2. frag.glsl - A simple fragment shader that:
   - Acts as a pass-through shader for color information
   - Takes the interpolated vertex color and applies it to the final fragment output

Together, these shaders form the graphics pipeline for rendering 3D surfaces in Manim, handling both the geometric transformations and color rendering. The shaders are written in GLSL 330 and are designed to work with OpenGL-based rendering. The modular design with separate included utilities (emit_gl_Position.glsl, get_unit_normal.glsl, finalize_color.glsl) suggests good code organization and reusability within the Manim shader system.</directory-summary><file name="frag.glsl"><declarations>
        <variable>in vec4 v_color</variable>
        <variable>out vec4 frag_color</variable>
    </declarations>
    <dependencies>
        <external>
            OpenGL GLSL version 330
        </external>
        <internal />
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Fragment shader main function that sets the output fragment color to the input vertex color
            </description>
            <args>
            </args>
            <returns>
            </returns>
            <side-effects>
                Sets the output variable frag_color
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a simple GLSL fragment shader file that takes an input vertex color (v_color) and assigns it directly to the output fragment color (frag_color). It's a basic pass-through shader that maintains the color information from the vertex shader stage to the final rendered output.
    </file-summary></file>
        <file name="vert.glsl"><declarations>
        <variables>
            in vec3 point
            in vec3 du_point
            in vec3 dv_point
            in vec4 rgba
            out vec4 v_color
        </variables>
    </declarations>
    <dependencies>
        <external>
            OpenGL GLSL 3.30
        </external>
        <internal>
            <filepath>emit_gl_Position.glsl</filepath>
            <description>Contains function for setting gl_Position</description>
        </internal>
        <internal>
            <filepath>get_unit_normal.glsl</filepath>
            <description>Contains function for normal vector calculations</description>
        </internal>
        <internal>
            <filepath>finalize_color.glsl</filepath>
            <description>Contains function for final color computation</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Main shader function that processes vertex data and computes vertex color
            </description>
            <args>
            </args>
            <returns>
            </returns>
            <side-effects>
                Sets gl_Position through emit_gl_Position
                Sets v_color output variable
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL vertex shader file that processes surface vertices. It takes input vertex positions and color data, computes surface normals, and outputs transformed vertex positions and colors. The shader uses three included files for position emission, normal calculation, and color finalization. It's designed to work with 3D surface rendering in Manim.
    </file-summary></file>
      </directory>
      <directory name="textured_surface">
        <directory-summary>This directory contains GLSL shader files for rendering textured surfaces in Manim. It consists of two main shader files:

1. frag.glsl - A fragment shader that handles:
   - Mixing between light and dark textures
   - Lighting calculations based on surface normals
   - Opacity handling
   - Final color processing

2. vert.glsl - A vertex shader that processes:
   - Vertex positions
   - Normal vector calculations
   - Texture coordinate mapping
   - Opacity pass-through

Together, these shaders enable the rendering of 3D surfaces with texture mapping and lighting effects in Manim. The system supports both single and dual texture modes (controlled by num_textures uniform), allowing for dynamic light/dark texture transitions based on surface orientation. The shaders are designed to work with OpenGL GLSL 3.30 and rely on several helper functions (finalize_color, emit_gl_Position, get_unit_normal) that are included from external files.

These shaders would typically be used when creating textured 3D surfaces or objects in Manim animations where sophisticated texture mapping and lighting effects are needed.</directory-summary><file name="frag.glsl"><declarations>
        <variables>
            uniform sampler2D LightTexture;
            uniform sampler2D DarkTexture;
            uniform float num_textures;
            in vec3 v_point;
            in vec3 v_unit_normal;
            in vec2 v_im_coords;
            in float v_opacity;
            out vec4 frag_color;
            const float dark_shift = 0.2;
        </variables>
    </declarations>
    <dependencies>
        <external>
            finalize_color.glsl
        </external>
        <internal />
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Fragment shader main function that handles texture mixing and color finalization based on lighting conditions
            </description>
            <args>
                
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Sets the global frag_color output variable with the final color calculation
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL fragment shader file that handles texture mixing and lighting calculations. It takes two textures (light and dark) and interpolates between them based on the lighting direction and surface normal. The shader supports both single and dual texture modes, controlled by the num_textures uniform variable. The final color is processed through an external finalize_color function and includes opacity handling.
    </file-summary></file>
        <file name="vert.glsl"><declarations>
        <in>
            - vec3 point: Input vertex position
            - vec3 du_point: Derivative point in u direction
            - vec3 dv_point: Derivative point in v direction
            - vec2 im_coords: Image coordinates
            - float opacity: Opacity value
        </in>
        <out>
            - vec3 v_point: Output vertex position
            - vec3 v_unit_normal: Output unit normal vector
            - vec2 v_im_coords: Output image coordinates
            - float v_opacity: Output opacity value
        </out>
    </declarations>
    <dependencies>
        <external>
            - OpenGL GLSL 3.30
        </external>
        <internal>
            <filepath>
                - emit_gl_Position.glsl
                - get_unit_normal.glsl
            </filepath>
            <description>
                These files are included using the #INSERT directive and likely contain helper functions for position and normal calculations
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Main vertex shader function that processes vertex attributes and computes output values
            </description>
            <args>
                
            </args>
            <returns>
                
            </returns>
            <side-effects>
                - Sets v_point to input point
                - Computes and sets v_unit_normal using cross product of normalized direction vectors
                - Passes through im_coords to v_im_coords
                - Passes through opacity to v_opacity
                - Calls emit_gl_Position with point parameter
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    - Potential division by zero in normalize operations
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL vertex shader file that processes vertices for a textured surface. It handles position, normal calculation, and texture coordinate processing. The shader takes input vertex attributes and computes corresponding outputs including position, normal vector, texture coordinates, and opacity. It relies on two external includes for position emission and normal calculations.
    </file-summary></file>
      </directory>
      <directory name="true_dot">
        <directory-summary>The true_dot directory contains a set of GLSL shader files that work together to implement high-quality dot rendering in Manim with support for glow effects, anti-aliasing, and proper 3D perspective. The shader pipeline consists of three stages:

1. vert.glsl - A vertex shader that handles the initial processing of dot attributes (position, radius, color), passing them through to later stages.

2. geom.glsl - A geometry shader that transforms input points into triangle strips, generating the actual geometry for each dot. It handles calculations for proper screen-space sizing and sets up parameters for anti-aliasing.

3. frag.glsl - A fragment shader that performs the final rendering of each dot, implementing glow effects, shading, and anti-aliasing. It uses the parameters calculated in previous stages to determine the final color of each fragment.

These shaders are designed to work as a unit to render dots that maintain consistent apparent size regardless of camera position, with smooth edges and optional glow effects. The implementation supports 3D perspective and includes optimizations for proper depth handling and anti-aliasing. This shader set is fundamental to Manim's ability to render high-quality dots and points in its mathematical animations.</directory-summary><file name="frag.glsl"><declarations>
        <variables>
            uniform float glow_factor
            uniform mat4 perspective
            in vec4 color
            in float scaled_aaw
            in vec3 point
            in vec3 to_cam
            in vec3 center
            in float radius
            in vec2 uv_coords
            out vec4 frag_color
        </variables>
    </declarations>
    <dependencies>
        <external>
            finalize_color.glsl
        </external>
        <internal>
            <filepath>
                #INSERT finalize_color.glsl
            </filepath>
            <description>
                Includes declaration of uniform vec3 shading and presumably the finalize_color function implementation
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Fragment shader main function that handles dot rendering with glow effects and shading
            </description>
            <args>
                
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Sets frag_color output variable
                May discard fragments
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    
                </handled>
                <unhandled>
                    
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL fragment shader file that handles the rendering of dots with glow effects and shading. It processes input variables including color, position, and various parameters to compute the final fragment color. The shader supports glow effects controlled by glow_factor and includes shading calculations based on normal vectors. It also implements anti-aliasing through the scaled_aaw parameter.
    </file-summary></file>
        <file name="geom.glsl"><declarations>
        <variables>
            layout (points) in;
            layout (triangle_strip, max_vertices = 4) out;
            uniform float pixel_size;
            uniform float anti_alias_width;
            uniform float frame_scale;
            uniform vec3 camera_position;
            in vec3 v_point[1];
            in float v_radius[1];
            in vec4 v_rgba[1];
            out vec4 color;
            out float scaled_aaw;
            out vec3 point;
            out vec3 to_cam;
            out vec3 center;
            out float radius;
            out vec2 uv_coords;
        </variables>
    </declarations>
    <dependencies>
        <external>
            #version 330
        </external>
        <internal>
            <filepath>#INSERT emit_gl_Position.glsl</filepath>
            <description>Includes functionality for emitting gl_Position values</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Geometry shader main function that processes input points and generates triangle strips for rendering dots
            </description>
            <args>
                
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Sets various output variables including color, radius, center, scaled_aaw, etc.
                Emits vertices for triangle strip generation
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL geometry shader file that transforms input points into triangle strips for rendering dots. It handles the geometry processing stage of the graphics pipeline, taking in point data and outputting vertices for triangle strips. The shader includes calculations for position, color, and various parameters needed for dot rendering with anti-aliasing support.
    </file-summary></file>
        <file name="vert.glsl"><declarations>
        <variables>
            in vec3 point
            in float radius
            in vec4 rgba
            out vec3 v_point
            out float v_radius
            out vec4 v_rgba
        </variables>
    </declarations>
    <dependencies>
        <external>
            OpenGL GLSL version 330
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Vertex shader main function that passes through vertex attributes to fragment shader
            </description>
            <args>
                
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Sets output variables v_point, v_radius, and v_rgba based on input attributes
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL vertex shader file that implements a simple pass-through shader for dot rendering. It takes vertex attributes (point position, radius, and color) as input and passes them to the fragment shader as varying variables. The shader is used in the Manim library for rendering dots or points in animations.
    </file-summary></file>
      </directory>
    </directory>
    <file name="tex_templates.yml"><file-summary>This file contains a comprehensive collection of TeX templates for use in Manim. It defines various LaTeX configurations with different fonts, styles, and mathematical typesetting options. The templates are organized into several categories:

        1. Classical TeX templates (default, ctex)
        2. Simplified TeX templates (basic, basic_ctex, empty, empty_ctex)
        3. Font-specific templates (a large collection of templates for different fonts)

        Each template specifies:
        - A description
        - The TeX compiler to use (latex, xelatex, or lualatex)
        - A preamble containing LaTeX package imports and configurations

        The templates support various use cases from standard mathematical typesetting to specialized fonts and Chinese text support. Many templates use the mathastext package to maintain consistent font usage between text and mathematical expressions.</file-summary></file>
    <file name="typing.py"><declarations>
        ManimColor = Union[str, Color, None]
        RangeSpecifier = Tuple[float, float, float] | Tuple[float, float]
        Span = tuple[int, int]
        SingleSelector = Union[str, re.Pattern, tuple[Union[int, None], Union[int, None]]]
        Selector = Union[SingleSelector, Iterable[SingleSelector]]
        UniformDict = Dict[str, float | bool | np.ndarray | tuple]
        FloatArray = np.ndarray[int, np.dtype[np.float64]]
        Vect2 = Annotated[FloatArray, Literal[2]]
        Vect3 = Annotated[FloatArray, Literal[3]]
        Vect4 = Annotated[FloatArray, Literal[4]]
        VectN = Annotated[FloatArray, Literal["N"]]
        Matrix3x3 = Annotated[FloatArray, Literal[3, 3]]
        Vect2Array = Annotated[FloatArray, Literal["N", 2]]
        Vect3Array = Annotated[FloatArray, Literal["N", 3]]
        Vect4Array = Annotated[FloatArray, Literal["N", 4]]
        VectNArray = Annotated[FloatArray, Literal["N", "M"]]
    </declarations>
    <dependencies>
        <external>
            typing
            typing_extensions
            colour
            numpy
            re
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
    </function-defs>
    <file-summary>
        This file defines custom type annotations for the Manim library. It includes type definitions for colors, array shapes, selectors, and other common data structures used throughout the codebase. The file uses conditional imports for type checking and provides fallback for Self type using typing_extensions. It particularly focuses on numpy array shape specifications through type annotations, though these are currently used primarily for documentation and future-proofing rather than runtime checking.
    </file-summary></file>
    <directory name="utils">
      <directory-summary>The manimlib/utils directory contains core utility functions and helpers that support the main Manim animation library functionality. Key components include:

1. Mathematical Operations:
- bezier.py: Bezier curve calculations and interpolation
- space_ops.py: Vector/matrix operations and spatial transformations
- simple_functions.py: Basic math utilities like sigmoid, clipping, etc.

2. Color &amp; Visual Processing:
- color.py: Color manipulation, conversion, and gradient generation
- images.py: Image loading and processing utilities
- shaders.py: Shader program management and GLSL code handling

3. File &amp; Resource Management:
- directories.py: Directory path management for various asset types
- file_ops.py: File operations and path handling
- sounds.py: Sound file location and management
- customization.py: User configuration management

4. TeX &amp; Text Processing:
- tex.py, tex_file_writing.py, tex_to_symbol_count.py: TeX rendering support, file generation, and symbol counting

5. Data Structure Utilities:
- dict_ops.py: Dictionary manipulation functions
- iterables.py: Collection/sequence operations
- family_ops.py: Mobject family relationship handling

6. Debug &amp; Development:
- debug.py: Debugging utilities for mobject inspection
- init_config.py: Configuration initialization

The directory serves as a foundation layer, providing essential utilities that higher-level Manim components rely on for animation creation, rendering, and resource management. These utilities are designed to be internal implementation details rather than part of the public API.</directory-summary><file name="__init__.py"><file-summary>This is an empty __init__.py file in the manimlib/utils directory. Its presence marks the utils directory as a Python package, allowing its modules to be imported, but it contains no code or declarations itself.</file-summary></file>
      <file name="bezier.py"><declarations>
        <constant>CLOSED_THRESHOLD = 0.001</constant>
    </declarations>
    <dependencies>
        <external>
            numpy
            scipy.linalg
            fontTools.cu2qu.cu2qu
            typing
        </external>
        <internal>
            <filepath>manimlib.logger</filepath>
            <description>Used for logging debug information</description>
            <filepath>manimlib.utils.simple_functions</filepath>
            <description>Imports choose function for bezier calculations</description>
            <filepath>manimlib.utils.space_ops</filepath>
            <description>Imports various spatial operation functions for vector calculations</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="bezier">
            <description>Creates a bezier curve function from a sequence of points</description>
            <args>points: Sequence[float | FloatArray] | VectNArray - Control points for the curve</args>
            <returns>Callable function that takes a float parameter t and returns a point on the curve</returns>
            <errors-and-exceptions>
                <handled>Exception when points list is empty</handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="partial_bezier_points">
            <description>Returns points describing a portion of a bezier curve between parameters a and b</description>
            <args>
                points: Sequence[Scalable] - Original bezier curve points
                a: float - Start parameter (0-1)
                b: float - End parameter (0-1)
            </args>
            <returns>list[Scalable] - New set of control points</returns>
            <side-effects />
        </function>
        <function name="interpolate">
            <description>Linearly interpolates between two values based on alpha parameter</description>
            <args>
                start: Scalable - Starting value
                end: Scalable - Ending value 
                alpha: float | VectN - Interpolation parameter
            </args>
            <returns>Scalable - Interpolated value</returns>
            <errors-and-exceptions>
                <handled>TypeError with debug logging</handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements bezier curve functionality and various interpolation utilities for the Manim animation library. It includes functions for creating and manipulating bezier curves, calculating curve points, smoothing paths, and performing various types of interpolation. The code makes heavy use of numpy for numerical operations and includes type hints for better code clarity.
    </file-summary></file>
      <file name="color.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            - colour (Color, hex2rgb, rgb2hex)
            - numpy
            - random
            - matplotlib.cm (imported within function)
            - typing (TYPE_CHECKING, Iterable, Sequence)
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports COLORMAP_3B1B and WHITE constants for color operations</description>
            <filepath>manimlib.utils.bezier</filepath>
            <description>Imports interpolate function for color interpolation</description>
            <filepath>manimlib.utils.iterables</filepath>
            <description>Imports resize_with_interpolation for color map operations</description>
            <filepath>manimlib.typing</filepath>
            <description>Imports custom type hints for Manim colors and vectors</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="color_to_rgb">
            <description>Converts various color formats to RGB values</description>
            <args>color: ManimColor (string or Color object)</args>
            <returns>Vect3 (numpy array of RGB values)</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled>Exception for invalid color type</handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="color_to_rgba">
            <description>Converts color to RGBA values with optional alpha</description>
            <args>
                color: ManimColor
                alpha: float = 1.0
            </args>
            <returns>Vect4 (numpy array of RGBA values)</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="rgb_to_color">
            <description>Converts RGB values to Color object</description>
            <args>rgb: Vect3 or Sequence[float]</args>
            <returns>Color object</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled>ValueError - returns WHITE color on invalid RGB values</handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="color_gradient">
            <description>Creates a gradient between multiple reference colors</description>
            <args>
                reference_colors: Iterable[ManimColor]
                length_of_output: int
            </args>
            <returns>list[Color]</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_colormap_list">
            <description>Returns a list of colors from specified colormap</description>
            <args>
                map_name: str = "viridis"
                n_colors: int = 9
            </args>
            <returns>Vect3Array (numpy array of RGB values)</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled>Potential KeyError if invalid map_name provided</unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file provides comprehensive color manipulation utilities for the Manim library. It includes functions for color conversion between different formats (RGB, RGBA, hex), color interpolation, gradient generation, and colormap handling. The file implements various color operations needed for animation creation and manipulation in Manim.
    </file-summary></file>
      <file name="customization.py"><declarations>
        <variable>CUSTOMIZATION = {}</variable>
    </declarations>
    <dependencies>
        <external>
            <dependency>os</dependency>
            <dependency>tempfile</dependency>
        </external>
        <internal>
            <filepath>manimlib.config</filepath>
            <description>
                Imports get_custom_config and get_manim_dir functions to handle configuration settings and directory paths
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_customization">
            <description>
                Retrieves and initializes customization settings, including directory configurations for temporary storage and shaders
            </description>
            <args>
                
            </args>
            <returns>
                Returns the CUSTOMIZATION dictionary containing configuration settings
            </returns>
            <side-effects>
                Updates the global CUSTOMIZATION dictionary if it's empty
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    Potential file system related errors when accessing directories
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file manages customization settings for the Manim library. It provides a mechanism to store and retrieve configuration settings, particularly focusing on directory paths for temporary storage and shader files. The file uses a singleton pattern with a global CUSTOMIZATION dictionary that is lazily initialized when first accessed.
    </file-summary></file>
      <file name="debug.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            <import>typing.TYPE_CHECKING</import>
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports BLACK color constant</description>
            <filepath>manimlib.logger</filepath>
            <description>Imports log utility for debugging output</description>
            <filepath>manimlib.mobject.numbers</filepath>
            <description>Imports Integer class for creating numerical labels</description>
            <filepath>manimlib.mobject.types.vectorized_mobject</filepath>
            <description>Imports VGroup for grouping visual elements</description>
            <filepath>manimlib.mobject.mobject</filepath>
            <description>Imports Mobject type for type checking</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="print_family">
            <description>
                Debug utility function that prints a hierarchical representation of a mobject and its submobjects
            </description>
            <args>
                mobject: Mobject - The object to print
                n_tabs: int = 0 - Number of tabs for indentation
            </args>
            <returns>
                None
            </returns>
            <side-effects>
                Prints debug information to the log
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="index_labels">
            <description>
                Creates numerical labels for each submobject in a mobject
            </description>
            <args>
                mobject: Mobject - The object to label
                label_height: float = 0.15 - Height of the label
            </args>
            <returns>
                VGroup - A group containing all the created labels
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file provides debugging utilities for the Manim library, specifically for visualizing and labeling mobject hierarchies. It contains two main functions: print_family for debugging output of mobject structures, and index_labels for creating visual numerical labels on mobjects.
    </file-summary></file>
      <file name="dict_ops.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            <package>itertools</package>
            <package>numpy</package>
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="merge_dicts_recursively">
            <description>
                Creates a dictionary by merging multiple input dictionaries, with later dictionaries having higher priority. For dictionary values, merging is done recursively.
            </description>
            <args>
                *dicts: Variable number of dictionary arguments to merge
            </args>
            <returns>
                Dictionary: A new merged dictionary containing all keys from input dictionaries
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    KeyError if accessing non-existent keys
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="soft_dict_update">
            <description>
                Updates the first dictionary with key-value pairs from the second dictionary, but only for keys that don't already exist in the first dictionary
            </description>
            <args>
                d1: First dictionary to be updated
                d2: Second dictionary whose values will be used to update d1
            </args>
            <returns>
            </returns>
            <side-effects>
                Modifies the first dictionary (d1) in place
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="dict_eq">
            <description>
                Compares two dictionaries for equality, with special handling for numpy arrays
            </description>
            <args>
                d1: First dictionary to compare
                d2: Second dictionary to compare
            </args>
            <returns>
                Boolean: True if dictionaries are equal, False otherwise
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    KeyError if a key exists in d1 but not in d2
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        A utility module providing dictionary manipulation functions including recursive merging, soft updating, and equality comparison with special handling for numpy arrays.
    </file-summary></file>
      <file name="directories.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            os
        </external>
        <internal>
            <filepath>
                manimlib.utils.customization
                manimlib.utils.file_ops
            </filepath>
            <description>
                Uses customization module to get directory configurations and file_ops for directory existence checks
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_directories">
            <description>
                Retrieves the directory configuration dictionary from customization settings
            </description>
            <args>
            </args>
            <returns>
                dict[str, str] - Dictionary containing directory configurations
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_temp_dir">
            <description>
                Gets the temporary storage directory path
            </description>
            <args>
            </args>
            <returns>
                str - Path to temporary storage directory
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_tex_dir">
            <description>
                Gets and ensures existence of Tex directory within temp directory
            </description>
            <args>
            </args>
            <returns>
                str - Path to Tex directory
            </returns>
            <side-effects>
                May create directory if it doesn't exist
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_text_dir">
            <description>
                Gets and ensures existence of Text directory within temp directory
            </description>
            <args>
            </args>
            <returns>
                str - Path to Text directory
            </returns>
            <side-effects>
                May create directory if it doesn't exist
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_mobject_data_dir">
            <description>
                Gets and ensures existence of mobject_data directory within temp directory
            </description>
            <args>
            </args>
            <returns>
                str - Path to mobject_data directory
            </returns>
            <side-effects>
                May create directory if it doesn't exist
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_downloads_dir">
            <description>
                Gets and ensures existence of manim_downloads directory within temp directory
            </description>
            <args>
            </args>
            <returns>
                str - Path to downloads directory
            </returns>
            <side-effects>
                May create directory if it doesn't exist
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_output_dir">
            <description>
                Gets and ensures existence of output directory
            </description>
            <args>
            </args>
            <returns>
                str - Path to output directory
            </returns>
            <side-effects>
                May create directory if it doesn't exist
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_raster_image_dir">
            <description>
                Gets the raster images directory path
            </description>
            <args>
            </args>
            <returns>
                str - Path to raster images directory
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_vector_image_dir">
            <description>
                Gets the vector images directory path
            </description>
            <args>
            </args>
            <returns>
                str - Path to vector images directory
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_sound_dir">
            <description>
                Gets the sounds directory path
            </description>
            <args>
            </args>
            <returns>
                str - Path to sounds directory
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_shader_dir">
            <description>
                Gets the shaders directory path
            </description>
            <args>
            </args>
            <returns>
                str - Path to shaders directory
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file provides utility functions for accessing various directory paths used by the Manim library. It includes functions to get paths for temporary storage, TeX files, text files, mobject data, downloads, output, images, sounds, and shaders. Some functions ensure the directories exist before returning their paths.
    </file-summary></file>
      <file name="family_ops.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            from __future__ import annotations
            from typing import TYPE_CHECKING, Iterable, List, Set, Tuple
        </external>
        <internal>
            <filepath>
                from manimlib.mobject.mobject import Mobject
            </filepath>
            <description>
                Imports the Mobject class which is used as a type annotation and for mobject family operations
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="extract_mobject_family_members">
            <description>
                Extracts all family members from a list of mobjects, with an option to exclude pointless mobjects
            </description>
            <args>
                mobject_list: Iterable[Mobject] - List of mobjects to process
                exclude_pointless: bool - Flag to exclude mobjects without points (default False)
            </args>
            <returns>
                list[Mobject] - List of all family members from the input mobjects
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="recursive_mobject_remove">
            <description>
                Recursively removes specified mobjects from a list while preserving the family structure
            </description>
            <args>
                mobjects: List[Mobject] - List of mobjects to process
                to_remove: Set[Mobject] - Set of mobjects to remove
            </args>
            <returns>
                Tuple[List[Mobject], bool] - Returns a tuple containing the processed list and a boolean indicating if removals were made
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file provides utility functions for handling mobject family operations in Manim. It includes functions for extracting family members from mobjects and recursively removing mobjects while maintaining family relationships. The file is focused on manipulating collections of mobjects in a way that respects their hierarchical structure.
    </file-summary></file>
      <file name="file_ops.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            os
            numpy as np
            validators
            typing (TYPE_CHECKING, Iterable)
        </external>
        <internal>
            <filepath>manimlib.utils.directories</filepath>
            <description>Imports get_downloads_dir function for handling file downloads</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="add_extension_if_not_present">
            <description>Adds a file extension to a filename if it's not already present</description>
            <args>
                file_name: str - The name of the file
                extension: str - The extension to add
            </args>
            <returns>str - The filename with the extension</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="guarantee_existence">
            <description>Ensures a directory path exists, creating it if necessary</description>
            <args>path: str - The directory path to check/create</args>
            <returns>str - The absolute path to the directory</returns>
            <side-effects>Creates directories if they don't exist</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>Potential permission errors when creating directories</unhandled>
            </errors-and-exceptions>
        </function>
        <function name="find_file">
            <description>Locates a file by searching multiple locations and handles URLs</description>
            <args>
                file_name: str - The name or URL of the file to find
                directories: Iterable[str] | None - Directories to search in
                extensions: Iterable[str] | None - File extensions to try
            </args>
            <returns>str - The path to the found file</returns>
            <side-effects>Downloads files if URL is provided</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Network errors during URL download
                    IOError when file is not found
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_sorted_integer_files">
            <description>Gets a sorted list of files with integer names from a directory</description>
            <args>
                directory: str - The directory to search in
                min_index: float - Minimum index to include
                max_index: float - Maximum index to include
                remove_non_integer_files: bool - Whether to delete non-integer named files
                remove_indices_greater_than: float | None - Maximum index threshold
                extension: str | None - File extension filter
            </args>
            <returns>list[str] - Sorted list of file paths</returns>
            <side-effects>Can delete files if remove_non_integer_files is True or remove_indices_greater_than is set</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Permission errors when removing files
                    Directory access errors
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        A utility module for file operations in Manim, providing functions for file path manipulation, file searching, and directory management. It includes functionality for handling both local files and URLs, and specialized functions for working with numerically named files.
    </file-summary></file>
      <file name="images.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            numpy
            PIL.Image
            typing (TYPE_CHECKING, Iterable)
        </external>
        <internal>
            <filepath>
                manimlib.utils.directories
                manimlib.utils.file_ops
            </filepath>
            <description>
                Uses directories module for getting image directory paths
                Uses file_ops module for file finding functionality
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_full_raster_image_path">
            <description>
                Gets the full file path for a raster image file
            </description>
            <args>
                image_file_name: str - Name of the image file to locate
            </args>
            <returns>
                str - Full path to the raster image file
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    File not found scenarios
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_full_vector_image_path">
            <description>
                Gets the full file path for a vector image file
            </description>
            <args>
                image_file_name: str - Name of the image file to locate
            </args>
            <returns>
                str - Full path to the vector image file
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    File not found scenarios
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="invert_image">
            <description>
                Inverts the colors of an image by subtracting pixel values from 255
            </description>
            <args>
                image: Iterable - Input image to be inverted
            </args>
            <returns>
                Image.Image - Inverted PIL Image object
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    Invalid image format or array conversion errors
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file provides utility functions for handling image files in the Manim library. It includes functionality for locating both raster and vector images in specific directories and image color inversion operations. The file implements type checking and uses both PIL and numpy for image processing.
    </file-summary></file>
      <file name="init_config.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            importlib
            inspect
            os
            yaml
            rich.box
            rich.console
            rich.prompt
            rich.rule
            rich.table
            typing
        </external>
        <internal>
            <filepath>manimlib</filepath>
            <description>Used to locate the manim directory and access module functionality</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_manim_dir">
            <description>Gets the absolute path to the manim directory by finding the manimlib module location</description>
            <args />
            <returns>str - Absolute path to the manim directory</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    ImportError if manimlib module cannot be imported
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="remove_empty_value">
            <description>Recursively removes empty string values from a dictionary</description>
            <args>dictionary: dict[str, Any] - Dictionary to clean up</args>
            <returns />
            <side-effects>Modifies the input dictionary by removing empty string values</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="init_customization">
            <description>Interactive configuration setup for manim, allowing users to set various preferences and paths</description>
            <args />
            <returns />
            <side-effects>
                Creates and writes to a configuration file (either global or local)
                Prints information to console
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    KeyboardInterrupt - Handles user interruption during configuration
                </handled>
                <unhandled>
                    IOError when writing to configuration file
                    YAMLError when dumping configuration
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file provides functionality for initializing and managing manim configuration settings. It includes utilities for locating the manim directory, cleaning configuration dictionaries, and an interactive configuration setup process that allows users to specify various settings like output directories, styling preferences, and camera qualities. The configuration can be saved either globally or locally in YAML format.
    </file-summary></file>
      <file name="iterables.py"><declarations>
        <variable>T = TypeVar("T")</variable>
        <variable>S = TypeVar("S")</variable>
    </declarations>
    <dependencies>
        <external>
            from __future__ import annotations
            from colour import Color
            import numpy as np
            import random
            from typing import TYPE_CHECKING, Callable, Iterable, Sequence, TypeVar
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="remove_list_redundancies">
            <description>Removes duplicate elements from a sequence while preserving order, keeping the last occurrence of each element</description>
            <args>lst: Sequence[T] - Input sequence</args>
            <returns>list[T] - List with duplicates removed</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="list_update">
            <description>Combines two iterables while maintaining order and removing duplicates from the first iterable</description>
            <args>
                l1: Iterable[T] - First iterable
                l2: Iterable[T] - Second iterable
            </args>
            <returns>list[T] - Combined list with duplicates removed</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="list_difference_update">
            <description>Returns elements from first iterable that are not in second iterable</description>
            <args>
                l1: Iterable[T] - First iterable
                l2: Iterable[T] - Second iterable
            </args>
            <returns>list[T] - Filtered list</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="adjacent_n_tuples">
            <description>Creates tuples of n adjacent elements from a sequence</description>
            <args>
                objects: Sequence[T] - Input sequence
                n: int - Size of tuples
            </args>
            <returns>zip[tuple[T, ...]] - Iterator of adjacent tuples</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="adjacent_pairs">
            <description>Creates pairs of adjacent elements from a sequence</description>
            <args>objects: Sequence[T] - Input sequence</args>
            <returns>zip[tuple[T, T]] - Iterator of adjacent pairs</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="batch_by_property">
            <description>Groups items into batches based on a property function</description>
            <args>
                items: Iterable[T] - Items to batch
                property_func: Callable[[T], S] - Function to determine batching
            </args>
            <returns>list[tuple[T, S]] - List of batches with their properties</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="listify">
            <description>Converts an object into a list</description>
            <args>obj: object - Object to convert</args>
            <returns>list - Converted list</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled>TypeError when object is not iterable</handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="shuffled">
            <description>Returns a shuffled copy of an iterable</description>
            <args>iterable: Iterable - Input iterable</args>
            <returns>list - Shuffled list</returns>
            <side-effects>Uses random module for shuffling</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="resize_array">
            <description>Resizes a numpy array to a specified length</description>
            <args>
                nparray: np.ndarray - Input array
                length: int - Target length
            </args>
            <returns>np.ndarray - Resized array</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="resize_preserving_order">
            <description>Resizes array while maintaining relative ordering of elements</description>
            <args>
                nparray: np.ndarray - Input array
                length: int - Target length
            </args>
            <returns>np.ndarray - Resized array</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="resize_with_interpolation">
            <description>Resizes array using linear interpolation between values</description>
            <args>
                nparray: np.ndarray - Input array
                length: int - Target length
            </args>
            <returns>np.ndarray - Interpolated array</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="make_even">
            <description>Adjusts two sequences to have equal length through resampling</description>
            <args>
                iterable_1: Sequence[T] - First sequence
                iterable_2: Sequence[S] - Second sequence
            </args>
            <returns>tuple[Sequence[T], Sequence[S]] - Adjusted sequences</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="arrays_match">
            <description>Checks if two numpy arrays are identical in shape and content</description>
            <args>
                arr1: np.ndarray - First array
                arr2: np.ndarray - Second array
            </args>
            <returns>bool - Whether arrays match</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="array_is_constant">
            <description>Checks if all elements in array are equal</description>
            <args>arr: np.ndarray - Input array</args>
            <returns>bool - Whether array is constant</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="cartesian_product">
            <description>Computes cartesian product of input arrays</description>
            <args>*arrays: np.ndarray - Input arrays</args>
            <returns>np.ndarray - Cartesian product array</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="hash_obj">
            <description>Creates a hash for complex objects including dicts, sets, lists, tuples, and Colors</description>
            <args>obj: object - Object to hash</args>
            <returns>int - Hash value</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        A utility module providing various functions for handling iterables, arrays, and data structures. It includes functions for list manipulation, array resizing, sequence operations, and hashing complex objects.
    </file-summary></file>
      <file name="paths.py"><declarations>
        STRAIGHT_PATH_THRESHOLD = 0.01
    </declarations>
    <dependencies>
        <external>
            math
            numpy
            typing (TYPE_CHECKING, Callable)
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports OUT constant for default axis orientation</description>
            <filepath>manimlib.utils.bezier</filepath>
            <description>Imports interpolate function for straight path calculations</description>
            <filepath>manimlib.utils.space_ops</filepath>
            <description>Imports get_norm and rotation_matrix_transpose for path calculations</description>
            <filepath>manimlib.typing</filepath>
            <description>Imports type definitions Vect3 and Vect3Array</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="straight_path">
            <description>Creates a straight path between two sets of points using linear interpolation</description>
            <args>
                start_points: np.ndarray - Starting points array
                end_points: np.ndarray - Ending points array
                alpha: float - Interpolation parameter between 0 and 1
            </args>
            <returns>np.ndarray - Interpolated points between start and end points</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="path_along_arc">
            <description>Creates a function that generates a curved path between points along an arc with specified angle and axis</description>
            <args>
                arc_angle: float - Angle of the arc
                axis: Vect3 - Axis of rotation (defaults to OUT)
            </args>
            <returns>Callable[[Vect3Array, Vect3Array, float], Vect3Array] - Function that generates points along the arc</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled>Division by zero if arc_angle is pi and axis norm is 0</unhandled>
            </errors-and-exceptions>
        </function>
        <function name="clockwise_path">
            <description>Creates a clockwise circular path (negative pi angle)</description>
            <args />
            <returns>Callable[[Vect3Array, Vect3Array, float], Vect3Array] - Function that generates clockwise circular path</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="counterclockwise_path">
            <description>Creates a counterclockwise circular path (positive pi angle)</description>
            <args />
            <returns>Callable[[Vect3Array, Vect3Array, float], Vect3Array] - Function that generates counterclockwise circular path</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file provides utilities for creating various types of paths between points in 3D space, including straight paths and curved paths along arcs. It's primarily used for animations and transitions in the Manim library, allowing objects to move along different trajectories.
    </file-summary></file>
      <file name="rate_functions.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            numpy as np
            typing (Callable, TYPE_CHECKING)
            __future__ (annotations)
        </external>
        <internal>
            <filepath>manimlib.utils.bezier</filepath>
            <description>Imports bezier function used for creating smooth rate functions and transitions</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="linear">
            <description>Returns input value unchanged - linear rate function</description>
            <args>t: float - Time parameter between 0 and 1</args>
            <returns>float - Same value as input</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="smooth">
            <description>Creates a smooth transition with zero first and second derivatives at t=0 and t=1</description>
            <args>t: float - Time parameter between 0 and 1</args>
            <returns>float - Smoothed value</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="rush_into">
            <description>Creates accelerated smooth transition in first half</description>
            <args>t: float - Time parameter between 0 and 1</args>
            <returns>float - Modified smooth value</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="rush_from">
            <description>Creates accelerated smooth transition in second half</description>
            <args>t: float - Time parameter between 0 and 1</args>
            <returns>float - Modified smooth value</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="slow_into">
            <description>Creates square root based smooth transition</description>
            <args>t: float - Time parameter between 0 and 1</args>
            <returns>float - Square root smoothed value</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="double_smooth">
            <description>Creates two-part smooth transition split at t=0.5</description>
            <args>t: float - Time parameter between 0 and 1</args>
            <returns>float - Double smoothed value</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="there_and_back">
            <description>Creates smooth transition that goes forward then reverses</description>
            <args>t: float - Time parameter between 0 and 1</args>
            <returns>float - Forward and reverse smoothed value</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="there_and_back_with_pause">
            <description>Creates smooth transition that goes forward, pauses, then reverses</description>
            <args>t: float - Time parameter between 0 and 1
pause_ratio: float - Ratio of time spent pausing (default 1/3)</args>
            <returns>float - Forward, pause, and reverse smoothed value</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="running_start">
            <description>Creates transition with modified start using bezier curve</description>
            <args>t: float - Time parameter between 0 and 1
pull_factor: float - Controls curve shape (default -0.5)</args>
            <returns>float - Modified bezier curve value</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="overshoot">
            <description>Creates transition that overshoots target using bezier curve</description>
            <args>t: float - Time parameter between 0 and 1
pull_factor: float - Controls overshoot amount (default 1.5)</args>
            <returns>float - Bezier curve value with overshoot</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="not_quite_there">
            <description>Modifies a rate function to not reach its full value</description>
            <args>func: Callable[[float], float] - Base rate function (default smooth)
proportion: float - Maximum value to reach (default 0.7)</args>
            <returns>Callable[[float], float] - Modified rate function</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="wiggle">
            <description>Creates oscillating transition effect</description>
            <args>t: float - Time parameter between 0 and 1
wiggles: float - Number of oscillations (default 2)</args>
            <returns>float - Oscillating value</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="squish_rate_func">
            <description>Modifies rate function to only operate within specified time interval</description>
            <args>func: Callable[[float], float] - Base rate function
a: float - Start time (default 0.4)
b: float - End time (default 0.6)</args>
            <returns>Callable[[float], float] - Modified rate function</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="lingering">
            <description>Creates transition that lingers at start using squish_rate_func</description>
            <args>t: float - Time parameter between 0 and 1</args>
            <returns>float - Modified transition value</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="exponential_decay">
            <description>Creates exponential decay transition</description>
            <args>t: float - Time parameter between 0 and 1
half_life: float - Decay rate (default 0.1)</args>
            <returns>float - Exponential decay value</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains various rate functions used for animations in Manim. These functions transform a time parameter t (usually between 0 and 1) to create different types of transitions and easing effects. The functions include linear, smooth, accelerated, oscillating, and various other mathematical transformations that can be used to control the timing and feel of animations.
    </file-summary></file>
      <file name="shaders.py"><declarations>
        PROGRAM_UNIFORM_MIRRORS: dict[int, dict[str, float | tuple]] = dict()
    </declarations>
    <dependencies>
        <external>
            moderngl
            PIL (Image)
            numpy
            os
            re
            functools (lru_cache)
            typing
        </external>
        <internal>
            <filepath>manimlib.utils.directories</filepath>
            <description>Imports get_shader_dir for locating shader files</description>
            <filepath>manimlib.utils.file_ops</filepath>
            <description>Imports find_file for file operations</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="image_path_to_texture">
            <description>Converts an image file to a moderngl texture</description>
            <args>
                path: str - Path to the image file
                ctx: moderngl.Context - ModernGL context
            </args>
            <returns>moderngl.Texture - The created texture object</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Image loading failures
                    Invalid image format
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_shader_program">
            <description>Creates a shader program from provided shader code</description>
            <args>
                ctx: moderngl.context.Context - ModernGL context
                vertex_shader: str - Vertex shader code
                fragment_shader: Optional[str] - Fragment shader code
                geometry_shader: Optional[str] - Geometry shader code
            </args>
            <returns>moderngl.Program - The compiled shader program</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Shader compilation errors
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="set_program_uniform">
            <description>Sets a uniform value in a shader program while maintaining a cache to avoid redundant updates</description>
            <args>
                program: moderngl.Program - The shader program
                name: str - Name of the uniform
                value: float | tuple | np.ndarray - Value to set
            </args>
            <returns>bool - True if uniform was updated, False otherwise</returns>
            <side-effects>
                Modifies PROGRAM_UNIFORM_MIRRORS global dictionary
                Updates shader program uniforms
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    KeyError when uniform doesn't exist
                </handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_shader_code_from_file">
            <description>Reads and processes shader code from a file, handling includes via #INSERT directives</description>
            <args>
                filename: str - Name of the shader file
            </args>
            <returns>str | None - The shader code or None if file not found</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled>
                    IOError when file not found
                </handled>
                <unhandled>
                    File reading errors
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_colormap_code">
            <description>Generates GLSL code for a color map from RGB values</description>
            <args>
                rgb_list: Sequence[float] - List of RGB color values
            </args>
            <returns>str - GLSL code representing the color map</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Invalid RGB values
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file provides utilities for working with shaders in the Manim library. It includes functions for loading and managing shader programs, handling textures, setting uniform values, and processing shader code files. The file implements caching mechanisms to optimize performance and provides tools for working with color maps in shaders.
    </file-summary></file>
      <file name="simple_functions.py"><declarations>
        <external>
            Scalable = TypeVar("Scalable", float, FloatArray)
        </external>
    </declarations>
    <dependencies>
        <external>
            from __future__ import annotations
            from functools import lru_cache
            import hashlib
            import inspect
            import math
            import numpy as np
            from typing import TYPE_CHECKING, Callable, TypeVar, Iterable
        </external>
        <internal>
            <filepath>from manimlib.typing import FloatArray</filepath>
            <description>Imports FloatArray type for type hinting</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="sigmoid">
            <description>Computes the sigmoid function (1/(1 + e^-x))</description>
            <args>x: float | FloatArray - Input value or array</args>
            <returns>float | FloatArray - Sigmoid of the input</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="choose">
            <description>Calculates binomial coefficient (n choose k) with caching</description>
            <args>n: int, k: int - Parameters for combination calculation</args>
            <returns>int - Number of ways to choose k items from n items</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="gen_choose">
            <description>Alternative implementation of binomial coefficient calculation</description>
            <args>n: int, r: int - Parameters for combination calculation</args>
            <returns>int - Number of ways to choose r items from n items</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_num_args">
            <description>Returns the number of arguments a function takes</description>
            <args>function: Callable - Function to analyze</args>
            <returns>int - Number of arguments</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_parameters">
            <description>Returns the parameter names of a function</description>
            <args>function: Callable - Function to analyze</args>
            <returns>Iterable[str] - Iterator of parameter names</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="clip">
            <description>Clips a value between minimum and maximum bounds</description>
            <args>a: float, min_a: float, max_a: float - Value and bounds</args>
            <returns>float - Clipped value</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="arr_clip">
            <description>Clips array values between minimum and maximum bounds</description>
            <args>arr: np.ndarray, min_a: float, max_a: float - Array and bounds</args>
            <returns>np.ndarray - Clipped array</returns>
            <side-effects>Modifies input array in-place</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="fdiv">
            <description>Safe division with handling for zero division cases</description>
            <args>a: Scalable, b: Scalable, zero_over_zero_value: Scalable | None - Dividend, divisor, and optional value for 0/0 case</args>
            <returns>Scalable - Division result</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled>Zero division cases</handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="binary_search">
            <description>Performs binary search to find input that produces target output for given function</description>
            <args>function: Callable[[float], float], target: float, lower_bound: float, upper_bound: float, tolerance: float</args>
            <returns>float | None - Found value or None if search fails</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="hash_string">
            <description>Creates a truncated SHA256 hash of a string</description>
            <args>string: str - Input string to hash</args>
            <returns>str - First 16 characters of hexadecimal hash</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        A utility file containing various mathematical and helper functions including sigmoid, combinatorics calculations, function inspection utilities, clipping operations, safe division, binary search, and string hashing.
    </file-summary></file>
      <file name="sounds.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            <dependency>__future__.annotations</dependency>
        </external>
        <internal>
            <filepath>manimlib/utils/directories.py</filepath>
            <description>Imports get_sound_dir function to locate the sound directory</description>
            <filepath>manimlib/utils/file_ops.py</filepath>
            <description>Imports find_file function to search for sound files</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_full_sound_file_path">
            <description>
                Retrieves the full file path for a given sound file name by searching in the sound directory with supported extensions
            </description>
            <args>
                sound_file_name: str - The name of the sound file to locate
            </args>
            <returns>
                str - The full path to the found sound file
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    Could fail if the sound file is not found in the specified directory
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        A utility file that provides functionality to locate sound files in the Manim project. It contains a single function that helps resolve the full path of sound files by searching in the designated sound directory with supported audio file extensions (.wav, .mp3).
    </file-summary></file>
      <file name="space_ops.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            mapbox_earcut
            numpy
            scipy.spatial.transform
            tqdm.auto
            functools
            math
            operator
            platform
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports constant vectors (DOWN, OUT, RIGHT, UP) and mathematical constants (PI, TAU)</description>
            <filepath>manimlib.utils.iterables</filepath>
            <description>Imports adjacent_pairs utility function</description>
            <filepath>manimlib.utils.simple_functions</filepath>
            <description>Imports clip utility function</description>
            <filepath>manimlib.typing</filepath>
            <description>Imports type definitions for vectors and matrices</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="cross">
            <description>Computes cross product of two 3D vectors or arrays of vectors</description>
            <args>v1: Vect3 | List[float], v2: Vect3 | List[float], out: np.ndarray | None</args>
            <returns>Vect3 | Vect3Array - Cross product result</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_norm">
            <description>Calculates the Euclidean norm of a vector</description>
            <args>vect: VectN | List[float]</args>
            <returns>float - The norm of the vector</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="normalize">
            <description>Normalizes a vector to unit length</description>
            <args>vect: VectN | List[float], fall_back: VectN | List[float] | None</args>
            <returns>VectN - Normalized vector</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
    This file contains mathematical operations for handling vectors and spatial transformations in 3D space. It includes functions for vector operations (cross product, normalization), rotations (quaternions, rotation matrices), geometric calculations (intersections, triangulation), and various utility functions for 2D/3D transformations. The code is heavily dependent on numpy for efficient array operations and scipy for rotations.
    </file-summary></file>
      <file name="tex.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            <dependency>re</dependency>
        </external>
        <internal>
            <filepath>manimlib.utils.tex_to_symbol_count</filepath>
            <description>
                Imports TEX_TO_SYMBOL_COUNT constant which maps TeX commands to their symbol counts
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="num_tex_symbols">
            <description>
                Estimates the number of symbols that would be produced by a given TeX string
            </description>
            <args>
                tex: str - The TeX string to analyze
            </args>
            <returns>
                int - Estimated number of symbols in the TeX string
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    Could handle invalid TeX syntax or malformed input strings
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file provides functionality to analyze TeX strings and estimate how many symbols they would produce when rendered. It includes pattern matching to handle various TeX commands and special cases, using regular expressions to process the input string. The file is part of the Manim library's TeX processing utilities.
    </file-summary></file>
      <file name="tex_file_writing.py"><declarations>
        SAVED_TEX_CONFIG = {}
    </declarations>
    <dependencies>
        <external>
            yaml
            os
            re
            contextlib
        </external>
        <internal>
            <filepath>manimlib/config</filepath>
            <description>Imports get_custom_config and get_manim_dir for configuration management</description>
            <filepath>manimlib/logger</filepath>
            <description>Imports log for logging functionality</description>
            <filepath>manimlib/utils/directories</filepath>
            <description>Imports get_tex_dir for directory management</description>
            <filepath>manimlib/utils/simple_functions</filepath>
            <description>Imports hash_string for string hashing functionality</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_tex_template_config">
            <description>Retrieves TeX template configuration from a YAML file based on template name</description>
            <args>template_name: str - Name of the template to retrieve</args>
            <returns>dict[str, str] - Dictionary containing template configuration</returns>
            <side-effects>Logs warning if template not found</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>File reading errors, YAML parsing errors</unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_tex_config">
            <description>Returns or initializes TeX configuration settings</description>
            <args />
            <returns>dict[str, str] - Dictionary containing TeX configuration</returns>
            <side-effects>Updates SAVED_TEX_CONFIG global variable</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="tex_content_to_svg_file">
            <description>Converts TeX content to SVG file</description>
            <args>
                content: str - TeX content
                template: str - Template name
                additional_preamble: str - Additional TeX preamble
                short_tex: str - Short description for display
            </args>
            <returns>str - Path to generated SVG file</returns>
            <side-effects>Creates files on disk</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>File system errors</unhandled>
            </errors-and-exceptions>
        </function>
        <function name="create_tex_svg">
            <description>Creates SVG file from TeX content using specified compiler</description>
            <args>
                full_tex: str - Complete TeX content
                svg_file: str - Target SVG file path
                compiler: str - TeX compiler to use
            </args>
            <returns />
            <side-effects>Creates temporary files and final SVG file on disk</side-effects>
            <errors-and-exceptions>
                <handled>LatexError for compilation failures</handled>
                <unhandled>File system errors, OS command execution errors</unhandled>
            </errors-and-exceptions>
        </function>
        <function name="display_during_execution">
            <description>Context manager for displaying a message during execution</description>
            <args>message: str - Message to display</args>
            <returns />
            <side-effects>Prints to console</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>Terminal size retrieval errors</unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file handles the conversion of TeX content to SVG files in the Manim library. It provides functionality for managing TeX templates, configurations, and the compilation process using either latex or xelatex compilers. The file includes error handling for LaTeX compilation errors and utilities for displaying execution progress.
    </file-summary></file>
      <file name="tex_to_symbol_count.py"><declarations>
        <variable name="TEX_TO_SYMBOL_COUNT">
            Dictionary mapping LaTeX commands to their symbol count (integer values). This appears to be a constant dictionary used for tracking the number of symbols each LaTeX command represents.
        </variable>
    </declarations>
    <dependencies>
        <external>
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
    </function-defs>
    <file-summary>
        This file contains a single dictionary constant TEX_TO_SYMBOL_COUNT that maps LaTeX commands to their corresponding symbol counts. The dictionary includes various LaTeX commands like mathematical operators (sin, cos, tan), formatting commands (textbf, tiny, large), and special symbols. Many commands have a count of 0, indicating they don't contribute to the symbol count, while others have specific values (e.g., trigonometric functions typically have 3-4 symbols, \today has 15). This mapping is likely used for calculating text metrics or spacing in LaTeX-rendered content within Manim.
    </file-summary></file>
    </directory>
    <file name="window.py"><declarations>
        <variable name="fullscreen" type="bool" value="False" />
        <variable name="resizable" type="bool" value="True" />
        <variable name="gl_version" type="tuple[int, int]" value="(3, 3)" />
        <variable name="vsync" type="bool" value="True" />
        <variable name="cursor" type="bool" value="True" />
    </declarations>
    <dependencies>
        <external>
            numpy
            moderngl_window
            screeninfo
            functools
            typing
        </external>
        <internal>
            <filepath>manimlib.constants</filepath>
            <description>Imports FRAME_SHAPE constant for window calculations</description>
            <filepath>manimlib.utils.customization</filepath>
            <description>Imports get_customization for window positioning settings</description>
            <filepath>manimlib.scene.scene</filepath>
            <description>Type checking import for Scene class</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>Initializes the Window class with scene, size, and samples parameters</description>
            <args>
                scene: Scene - The scene to be displayed
                size: tuple[int, int] - Window dimensions (default: 1280x720)
                samples: int - Sample count (default: 0)
            </args>
            <returns />
            <side-effects>
                Initializes window properties and activates OpenGL context
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="to_default_position">
            <description>Resets window to its default position and size</description>
            <args />
            <returns />
            <side-effects>
                Modifies window position and size
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="find_initial_position">
            <description>Calculates initial window position based on customization settings</description>
            <args>
                size: tuple[int, int] - Window dimensions
            </args>
            <returns>tuple[int, int] - Calculated window position coordinates</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Index error if monitor index is invalid
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="pixel_coords_to_space_coords">
            <description>Converts pixel coordinates to scene space coordinates</description>
            <args>
                px: int - X pixel coordinate
                py: int - Y pixel coordinate
                relative: bool - Whether coordinates are relative
            </args>
            <returns>np.ndarray - Converted coordinates in scene space</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines a Window class that inherits from PygletWindow, providing window management functionality for the Manim animation library. It handles window initialization, positioning, and event management (mouse, keyboard, window events). The class serves as a bridge between the scene rendering and user interaction, converting screen coordinates to scene space coordinates and managing window state.
    </file-summary></file>
  </directory>
  <file name="pyproject.toml"><file-summary>This is a pyproject.toml configuration file that specifies the build system requirements for the Manim project. It indicates that the project uses setuptools and wheel for building and packaging. This is a standard Python project configuration file that follows PEP 518 specifications for specifying build system requirements.</file-summary></file>
  <file name="requirements.txt"><file-summary>This is a Python requirements.txt file that lists external package dependencies for the Manim project. It specifies required packages and their versions needed to run Manim. Key dependencies include graphics libraries (moderngl, PyOpenGL), mathematical packages (numpy, scipy, sympy), image processing libraries (Pillow, skia-pathops), and utility packages (tqdm, rich). Some notable version constraints include ipython&gt;=8.18.0, manimpango&gt;=0.4.0.post0,&lt;0.5.0, and svgelements&gt;=1.8.1. There's also a conditional dependency on typing-extensions for Python versions below 3.11.</file-summary></file>
  <file name="setup.cfg"><file-summary>This is a Python package configuration file (setup.cfg) for the Manim project. It contains metadata about the project including version (1.7.0), author information (Grant Sanderson), project description, and package dependencies. The file defines the project as a math animation engine, specifies its license (MIT), Python version compatibility (3.7-3.10), and lists required external dependencies. It also configures entry points for command-line interfaces 'manimgl' and 'manim-render'.</file-summary></file>
  <file name="setup.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            setuptools
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
    </function-defs>
    <file-summary>
        This is a minimal setup.py file that uses setuptools to configure the Python package. It simply imports setuptools and calls the setup() function without any explicit configuration parameters. This suggests that the actual package configuration is likely defined in another file (like setup.cfg) or using other mechanisms. The file serves as an entry point for Python's packaging and distribution system.
    </file-summary></file>
  <directory name="videos">
    <directory-summary>This directory (videos) contains the core animation content and supporting files for the Manim mathematical animation engine. The directory is organized into several key components:

1. License and Documentation:
- LICENSE.txt: CC BY-NC-SA 4.0 license text governing usage rights
- README.md: Documentation for the video project, including workflow instructions and Sublime Text setup

2. Main Content Directories (_2023, _2024):
- Mathematical animations and visualizations organized by year
- Each subdirectory focuses on specific topics (e.g., Central Limit Theorem, optics, transformers)
- Comprehensive implementations of complex mathematical concepts using Manim

3. External Content (outside_videos):
- Additional animations for various platforms and purposes
- Social media content, educational materials, and special presentations
- Includes specialized animations for platforms like Twitter

4. Development Tools (sublime_custom_commands):
- Sublime Text integration files for enhanced development workflow
- Custom commands for scene management and execution
- Terminal integration through Terminus

The directory serves as both a repository of mathematical animations and a development environment for creating new content. Users can:
1. Study existing animations as examples/references
2. Create new animations using the established framework
3. Utilize the development tools for efficient workflow
4. Build upon existing implementations for new content

The content is primarily focused on educational mathematics visualization, with extensive use of the Manim animation engine to create high-quality explanatory videos and demonstrations.

To use this directory:
1. Install required dependencies (Manim, Python libraries)
2. Set up development environment (Sublime Text + plugins if desired)
3. Study relevant examples in _2023/_2024 directories
4. Create new animations following established patterns
5. Use provided tools to streamline development process</directory-summary><file name="LICENSE.txt"><file-summary>This is the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Public License (CC BY-NC-SA 4.0) text. The license outlines terms and conditions for sharing and adapting creative works while requiring attribution, non-commercial use, and sharing adaptations under the same terms. It includes detailed sections on definitions, scope, conditions, database rights, warranties, liability, term and termination, and interpretation. The license ensures that derivative works must be shared under the same or compatible terms while prohibiting commercial use without explicit permission from the licensor.</file-summary></file>
    <file name="README.md"><file-summary>This is a README file for the 3Blue1Brown video project repository that explains:
        1. The purpose of the repository (generating math explanation videos)
        2. Its relationship with the Manim library
        3. Licensing information (Creative Commons Attribution-NonCommercial-ShareAlike 4.0)
        4. Detailed workflow instructions for using Manim with Sublime Text editor, including:
           - How to use interactive mode with manimgl
           - How to use checkpoint_paste() functionality
           - Setup instructions for Sublime Text including:
             * Installing Terminus
             * Adding custom commands
             * Setting up keyboard shortcuts
        The file contains no executable code, only configuration examples and documentation.</file-summary></file>
    
    <directory name="_2023">
      <directory-summary>This directory (_2023) contains multiple subdirectories implementing various mathematical animations and visualizations using the Manim animation engine. The key components are:

1. SoME3 - Contains code for generating video content for the Summer of Math Exposition 3 contest, including thumbnail reveals and winner announcements.

2. clt and clt_proof - Comprehensive implementations of Central Limit Theorem visualizations and proofs, featuring interactive demonstrations, Galton boards, and detailed mathematical explanations.

3. convolutions2 - Implements animations explaining convolutions and probability distributions, with both discrete and continuous examples.

4. gauss_int - Creates visualizations for Gaussian integrals and distributions, including 3D representations and interactive demonstrations.

5. moser_reboot - Animations explaining Moser's Circle Problem through geometric and combinatorial visualizations.

6. numberphile - Contains Numberphile-style animations focusing on prime number behavior and visualization.

7. optics_puzzles - Extensive collection of physics animations demonstrating wave behavior, optics, and electromagnetic phenomena.

8. standup_maths - Specialized visualizations for mathematics in sports and physics, including NBA shot analysis and pool table geometry.

The directory serves as a comprehensive library of mathematical animations for educational content creation. Each subdirectory is self-contained with its own specific focus, but they share common dependencies on the Manim animation engine and related mathematical libraries. The code is designed to be used for generating high-quality educational video content about various mathematical and physics concepts.

Users would typically:
1. Choose the relevant subdirectory for their topic
2. Run the Manim scripts to generate specific animations
3. Combine the outputs into educational videos or presentations

The code requires Manim and various scientific Python libraries (numpy, scipy, etc.) to function properly.</directory-summary><directory name="SoME3">
        <directory-summary>This directory contains code for generating video content related to the Summer of Math Exposition 3 (SoME3) contest using the Manim animation engine. The main.py file serves as the central script for creating various animated scenes including:

- Contest entry showcases
- Thumbnail reveals
- Winner announcements
- End credits

The code utilizes both Manim for animations and PIL (Python Imaging Library) for image processing. Key functionality includes:
- Creating and arranging thumbnail grids
- Animated reveals of contest entries
- Handling image loading and manipulation
- Organizing visual elements in scene compositions

This directory would be used when generating official video content for the SoME3 contest, such as announcement videos or highlight reels. Users would need both Manim and PIL installed to work with these scripts.</directory-summary><file name="main.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            manim_imports_ext
            PIL.ImageFilter
        </external>
        <internal>
            
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Main construction method for various scene classes that handle video creation for SoME3 contest entries
            </description>
            <args>
                self - Scene instance
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Creates and animates visual elements on screen
                Handles file I/O for thumbnail images
                Modifies scene state
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    
                </handled>
                <unhandled>
                    File I/O operations could fail
                    Image loading could fail
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="reveal">
            <description>
                Helper method to reveal thumbnails with animations
            </description>
            <args>
                self - Scene instance
                image - Image to reveal
                name - Name of the entry
                cover - Cover element to animate
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Modifies scene state with animations
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    
                </handled>
                <unhandled>
                    
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="create_triad">
            <description>
                Creates a group of three images arranged in a grid
            </description>
            <args>
                self - Scene instance
                im1, im2, im3 - Images to arrange
                to_replace - Rectangle to replace with arranged images
            </args>
            <returns>
                Group of arranged images
            </returns>
            <side-effects>
                
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    
                </handled>
                <unhandled>
                    
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains scene classes for creating video content related to the Summer of Math Exposition 3 (SoME3) contest. It includes classes for creating thumbnails, showing contest entries, displaying winners, and creating end credits. The file heavily uses manim for animations and PIL for image processing.
    </file-summary></file>
      </directory>
      <directory name="clt">
        <directory-summary>This directory contains a comprehensive implementation of Central Limit Theorem (CLT) visualizations using Manim. The directory consists of four main Python files that work together to create educational animations demonstrating various aspects of probability distributions and the CLT:

1. dice_sims.py - Implements interactive visualizations of dice roll distributions, showing how multiple dice rolls sum to approximate a normal distribution
2. galton_board.py - Creates an animated Galton Board simulation that physically demonstrates the CLT through balls falling through pegs
3. main.py - Contains core functionality for creating probability distribution charts and animations, including various predefined distributions (exponential, U-shaped)
4. wordy_scenes.py - Provides explanatory scenes with text, characters, and mathematical expressions to teach CLT concepts

The directory serves as a complete package for creating educational content about the Central Limit Theorem, with visualizations ranging from practical examples (dice, Galton board) to theoretical explanations. The code is designed to be used with the Manim animation engine to create high-quality mathematical animations for educational purposes.

Key features:
- Interactive probability simulations
- Physical demonstrations of CLT
- Various probability distribution visualizations
- Educational scenes with explanatory content
- Sound effects and animations for engagement</directory-summary><file name="dice_sims.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            numpy (as np)
            itertools (as it)
            math
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim core functionality</description>
            <filepath>_2023.clt.main</filepath>
            <description>Imports related functionality from the CLT (Central Limit Theorem) module</description>
        </internal>
    </dependencies>
    <function-defs>
        
    </function-defs>
    <file-summary>
        This file implements various dice simulation visualizations using Manim. The main class DiceSimulation and its variants create animations showing the distribution of sums when rolling multiple dice. The file includes several classes:

        1. DiceSimulation: Base class that handles the core simulation logic
        2. Multiple DiceSimulationAlt classes (1-5): Variations with different random seeds
        3. LargerDiceSimulation: Handles larger sample sizes
        4. SimulationWithUShapedDistribution: Shows simulations with U-shaped probability distributions
        5. Various other specialized simulation classes for different distributions and dice counts

        Each class creates interactive visualizations showing:
        - Individual die probability distributions
        - Accumulating sums of dice rolls
        - Visual representation of the distribution using stacked bricks
        - Running count of samples

        The simulations demonstrate various probability distributions and the Central Limit Theorem through visual animations.
    </file-summary></file>
        <file name="galton_board.py"><declarations>
        
        random_seed = 1
        pegs_per_row = 15
        n_rows = 5
        spacing = 1.0
        top_buff = 1.0
        peg_radius = 0.1
        ball_radius = 0.1
        bucket_floor_buff = 1.0
        bucket_style = dict(fill_color=GREY_D, fill_opacity=1.0)
        stack_ratio = 1.0
        fall_factor = 0.6
        clink_sound = "plate.wav"
    </declarations>
    <dependencies>
        <external>
            manim_imports_ext
        </external>
        <internal>
            <filepath>_2023.clt.main</filepath>
            <description>Imports from main module of the CLT (Central Limit Theorem) implementation</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="setup">
            <description>Sets up the initial scene by creating a ball template</description>
            <args>self</args>
            <returns />
            <side-effects>Creates and configures a 3D sphere template for balls</side-effects>
        </function>
        <function name="get_pegs">
            <description>Creates and positions the pegs for the Galton board</description>
            <args>self</args>
            <returns>VGroup of positioned Dot objects representing pegs</returns>
        </function>
        <function name="get_buckets">
            <description>Creates the collection buckets at the bottom of the board</description>
            <args>self, pegs</args>
            <returns>VGroup of bucket objects</returns>
        </function>
        <function name="random_trajectory">
            <description>Calculates a random trajectory for a ball through the pegs</description>
            <args>self, ball, pegs, buckets, bits=None</args>
            <returns>Tuple of (full trajectory, trajectory pieces)</returns>
        </function>
        <function name="drop_n_balls">
            <description>Animates dropping multiple balls through the board</description>
            <args>self, n, pegs, buckets, lr_factor=1, sound=False</args>
            <returns>Group of ball objects</returns>
            <side-effects>Animates balls falling and optionally plays sound effects</side-effects>
        </function>
    </function-defs>
    <file-summary>
        This file implements a Galton Board simulation using Manim. It creates an interactive visualization of balls falling through a triangular array of pegs, demonstrating the central limit theorem through the resulting normal distribution of balls in the collection buckets. The implementation includes detailed physics-like animations, sound effects, and various visualization options.
    </file-summary></file>
        <file name="main.py"><declarations>
        - EXP_DISTRIBUTION = [0.41, 0.25, 0.15, 0.10, 0.06, 0.03]
        - U_SHAPED_DISTRIBUTION = [0.3, 0.15, 0.05, 0.05, 0.15, 0.3]
        - STEEP_U_SHAPED_DISTRIBUTION = [0.4, 0.075, 0.025, 0.025, 0.075, 0.4]
    </declarations>
    <dependencies>
        <external>
            - manim_imports_ext
            - typing
        </external>
        <internal>
            <filepath>_2023.convolutions2.continuous</filepath>
            <description>Imports continuous convolution-related functionality</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="ChartBars">
            <description>Creates a group of bars for a bar chart visualization</description>
            <args>
                - axes: Axes object to plot on
                - values: Sequence of float/int values for bar heights
                - xs: Optional x-coordinates for bars
                - width_ratio: Float for relative bar width
                - offset: Float for bar offset
                - fill_color: Color for bar fill
                - fill_opacity: Float for bar opacity
                - stroke_color: Color for bar outline
                - stroke_width: Float for outline width
            </args>
            <returns>VGroup containing the bar rectangles</returns>
            <side-effects>None</side-effects>
        </function>
        <function name="get_die_distribution_chart">
            <description>Creates a chart showing probability distribution for dice rolls</description>
            <args>
                - dist: List of probabilities
                - die_config: Dict of die face configuration
                - axes_config: Dict of axes configuration
                - font_size: Integer for text size
                - y_range: Tuple for y-axis range
                - max_value: Integer for max die value
                - bar_colors: Tuple of colors for bars
            </args>
            <returns>VGroup containing axes, bars and die faces</returns>
            <side-effects>None</side-effects>
        </function>
        <function name="get_sample_markers">
            <description>Creates arrow markers for sample points on bars</description>
            <args>
                - bars: VGroup of bars
                - samples: List of sample values
            </args>
            <returns>VGroup of arrow tips</returns>
            <side-effects>None</side-effects>
        </function>
    </function-defs>
    <file-summary>
        This file implements animations demonstrating the Central Limit Theorem through dice roll distributions. It includes classes for random die rolls, dice sum distributions, and various probability distribution visualizations. The code uses Manim to create mathematical animations showing how different initial distributions converge to a normal distribution when summed.
    </file-summary></file>
        <file name="wordy_scenes.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            sympy
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports core Manim functionality and extensions</description>
            <filepath>_2023.clt.main</filepath>
            <description>Imports functionality from the main CLT module</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>Scene construction method that appears in multiple scene classes (GaltonBoardName, NormalName, etc)</description>
            <args>
                self - Scene instance
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and animates visual elements in the scene
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_factor_group">
            <description>Helper method in ErdosKac class to create factor visualization group</description>
            <args>
                self - Scene instance
                num - Number to factorize
                h_line - Reference line
                font_size - Font size for text elements
            </args>
            <returns>
                VGroup containing number visualization elements
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_rhs">
            <description>Helper method in ErdosKac class to create right-hand side of factorization</description>
            <args>
                self - Scene instance
                num_mob - Integer mobject
            </args>
            <returns>
                VGroup containing factorization visualization
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_pi">
            <description>Helper method in PopulationHeights class to create a pi character with specified height</description>
            <args>
                self - Scene instance
                height - Height of the pi character
            </args>
            <returns>
                Randolph character mobject
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains multiple Manim scene classes that create various animations and visualizations related to the Central Limit Theorem. The scenes include visualizations of the Galton Board, normal distribution names, Erdős–Kac theorem, population heights, and various explanatory scenes with teacher-student interactions. The scenes use a combination of text, mathematical expressions, graphs, and character animations to explain statistical concepts.
    </file-summary></file>
      </directory>
      <directory name="clt_proof">
        <directory-summary>This directory contains animation code for creating educational content about the Central Limit Theorem (CLT) proof using Manim. The main.py file defines multiple scene classes that build various mathematical visualizations to explain different aspects of the CLT proof in an engaging way.

The animations cover several key concepts:
- Initial setup with split screen layouts
- Character animations showing thought processes about proving CLT
- Visual explanations of Gaussian distributions
- Teacher-student interactions about the proof
- Explorations of statistical concepts like moments and cumulants
- Detailed explanations of the Moment Generating Function

The code is designed to be used as part of an educational video series, utilizing Manim's animation capabilities to make complex mathematical concepts more accessible and visually engaging. Each scene can be rendered independently to create specific segments of the larger CLT proof explanation.

The directory relies on external dependencies including manim_imports_ext and scipy.integrate for creating the mathematical visualizations and calculations.</directory-summary><file name="main.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            manim_imports_ext
            scipy.integrate
        </external>
        <internal>
            
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Multiple scene classes are defined, each with a construct method that builds animations related to proving the Central Limit Theorem
            </description>
            <args>
                self
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Creates and animates manim scenes with various mathematical visualizations
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    
                </handled>
                <unhandled>
                    
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains multiple scene classes for creating animations related to proving the Central Limit Theorem. The main scenes include:
        - SplitScreen: Creates a split screen layout
        - ImagineProving: Shows an animation with Randy thinking about proving CLT
        - WhyGaussian: Displays a question about e^(-x^2)
        - AskAboutTheProof: Shows a teacher-student interaction about the proof
        - RefinedHypothesis: (Incomplete) Scene about hypothesis refinement
        - LookingBeyondExpectationAndVariance: Explores statistical moments
        - DefineMGF: Defines and explains the Moment Generating Function
        - CumulantsOfScaledSum: Explores cumulants of scaled sums
        Each scene builds specific animations to explain different aspects of the CLT proof.
    </file-summary></file>
      </directory>
      <directory name="convolutions2">
        <directory-summary>This directory contains Python files that implement a comprehensive set of Manim animations for explaining and visualizing convolutions and probability distributions. The main components are:

1. continuous.py - Core functionality for continuous probability distributions and convolution visualizations, including utility functions for creating various distribution shapes and convolution graphs.

2. diagonal_slices.py - Implements 3D visualizations showing diagonal slices through surfaces created by multiplying functions, helping explain convolution geometry.

3. dice.py - Creates animations demonstrating convolutions using dice probability distributions, with helper functions for bar charts and dice sum visualizations.

4. gauss_example_supplements.py - Contains scenes specifically focused on Gaussian distributions and their special properties in convolutions.

5. supplements.py - Additional educational scenes featuring teacher-student interactions and explanatory animations.

The directory appears to be part of a larger educational video project about convolutions, with files building on each other to create a complete educational narrative. The code makes heavy use of Manim's animation capabilities and includes both discrete and continuous probability concepts, with particular emphasis on geometric interpretations and visual explanations of convolutions.

These files should be used together to generate educational video content, with continuous.py providing core functionality that other files build upon for specific demonstrations and examples.</directory-summary><file name="continuous.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            scipy.stats
            numpy (via manim imports)
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports core Manim functionality</description>
            <filepath>_2023.clt.main</filepath>
            <description>Imports from another module in the codebase</description>
            <filepath>_2022.convolutions.discrete</filepath>
            <description>Imports from convolutions discrete module</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="wedge_func">
            <description>Creates a wedge-shaped function using numpy clip</description>
            <args>x: numeric input for the function</args>
            <returns>Clipped value between 0 and 1</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="double_lump">
            <description>Creates a double gaussian bump function</description>
            <args>x: numeric input for the function</args>
            <returns>Sum of two gaussian functions</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="uniform">
            <description>Creates a uniform distribution function between -0.5 and 0.5</description>
            <args>x: numeric input for the function</args>
            <returns>1.0 if x is between -0.5 and 0.5, 0 otherwise</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_conv_graph">
            <description>Generates a convolution graph from two input functions</description>
            <args>
                axes: Manim Axes object
                f: First function to convolve
                g: Second function to convolve
                dx: Step size for sampling (default 0.1)
            </args>
            <returns>VMobject representing the convolution graph</returns>
            <side-effects>Creates and modifies a VMobject for visualization</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements various probability distribution functions and convolution visualizations using Manim. It contains several scene classes that demonstrate continuous probability concepts, convolutions, and transitions between discrete and continuous probability distributions. The main components are utility functions for creating specific distributions and a series of Manim scenes for visualization.
    </file-summary></file>
        <file name="diagonal_slices.py"><declarations>
        
        plane_config = dict with x_range, y_range, width, height settings
        plane_line_style = dict with stroke settings
        graph_resolution = (101, 101)
        mesh_resolution = (21, 21)
        shadow_opacity = 0.25
        clip_plane_unit_coord = 0.45
    </declarations>
    <dependencies>
        <external>
            manim
            numpy
            math
        </external>
        <internal>
            <filepath>
                _2023.convolutions2.continuous
            </filepath>
            <description>
                Imports functions used for visualization like wedge_func, double_lump, uniform, gauss_func
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Main animation sequence for visualizing 3D graphs and diagonal slices
            </description>
            <args>
                self
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and animates various manim objects
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_plane">
            <description>
                Creates and returns a NumberPlane with configured settings
            </description>
            <args>
                self
            </args>
            <returns>
                NumberPlane object
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_three_d_axes">
            <description>
                Creates and returns 3D axes aligned with the given plane
            </description>
            <args>
                self
                plane: NumberPlane
            </args>
            <returns>
                ThreeDAxes object
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains manim scenes for visualizing diagonal slices through 3D surfaces created by multiplying two functions. It includes several scene classes that build upon each other to demonstrate different aspects of these slices, including rotational symmetry and various function combinations. The main classes are DiagonalSlices, SyncedSlices, and several variations that use different input functions.
    </file-summary></file>
        <file name="dice.py"><declarations>
        <external>
            SKEW_DISTRIBUTION = [0.12, 0.23, 0.31, 0.18, 0.12, 0.04]
        </external>
    </declarations>
    <dependencies>
        <external>
            manim_imports_ext
            numpy (via np)
        </external>
        <internal>
            <filepath>_2022.convolutions.discrete</filepath>
            <description>Imports utilities for discrete convolutions</description>
            <filepath>_2023.clt.main</filepath>
            <description>Imports utilities from central limit theorem module</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_bar_group">
            <description>Creates a group of bars representing a probability distribution with labels</description>
            <args>
                dist: List[float] - Distribution values
                bar_colors: Tuple[Color] - Colors for bars gradient
                value_labels: Optional[List] - Labels for values
                width_ratio: float - Width ratio for bars
                height: float - Height of bars
                number_config: dict - Configuration for number displays
                label_buff: float - Buffer space for labels
            </args>
            <returns>VGroup containing bars with labels</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="die_sum_labels">
            <description>Creates labels showing dice sums from 2 to 12</description>
            <args>
                color1: Color - Color for first die
                color2: Color - Color for second die
                height: float - Height of the label group
            </args>
            <returns>VGroup containing sum labels</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="rotate_sum_label">
            <description>Rotates and adjusts positioning of a sum label</description>
            <args>
                sum_label: Mobject - Label to be rotated
            </args>
            <returns />
            <side-effects>Modifies the input sum_label's position and rotation</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="p_mob">
            <description>Creates a probability notation mobject P(X) around given mobject</description>
            <args>
                mob: Mobject - Mobject to wrap in probability notation
                scale_factor: float - Scale factor for the result
            </args>
            <returns>VGroup containing probability notation with embedded mobject</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements animations for demonstrating convolutions using dice probability distributions. It includes helper functions for creating visual elements like bar charts and dice labels, and scene classes that animate the convolution process. The main scenes show how probability distributions combine when adding random variables.
    </file-summary></file>
        <file name="gauss_example_supplements.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim core functionality</description>
            <filepath>_2023.convolutions2.continuous</filepath>
            <description>Imports from local continuous module</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>Scene construction method for IntroWords class showing title transitions</description>
            <args>self</args>
            <returns />
            <side-effects>Creates and animates title text objects</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="construct">
            <description>Scene construction method for NewIntroWords class showing multiple text transitions</description>
            <args>self</args>
            <returns />
            <side-effects>Creates and animates multiple text objects in sequence</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="pseudo_bell">
            <description>Helper function defining a pseudo bell curve</description>
            <args>x: float</args>
            <returns>float value representing height of curve at x</returns>
            <side-effects>None</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        
    </function-defs>
    <file-summary>
        This file contains multiple manim scene classes that create animations related to Gaussian distributions and convolutions. It includes scenes for introductory text, mathematical visualizations of bell curves, and explanatory animations about convolutions between Gaussian functions. The scenes build up to explaining why Gaussian functions are special in the context of convolutions and the Central Limit Theorem.
    </file-summary></file>
        <file name="supplements.py"><declarations>
    </declarations>
    <dependencies>
        <external>
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim core functionality and extensions</description>
            <filepath>_2023.convolutions2.continuous</filepath>
            <description>Imports functionality from the continuous convolutions module</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>Animation construction method implemented across multiple scene classes</description>
            <args>
                self - Scene instance
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and plays animations in the manim scene
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains supplementary scene classes for a video about convolutions. It includes multiple TeacherStudentsScene and InteractiveScene subclasses that create various educational animations explaining concepts around convolutions, probability distributions, and mathematical proofs. The scenes feature teacher-student interactions, mathematical visualizations, and explanatory animations using the manim animation engine.
    </file-summary></file>
      </directory>
      <directory name="gauss_int">
        <directory-summary>This directory contains a collection of Python files that create mathematical animations using the Manim library, specifically focused on visualizing and explaining Gaussian integrals and distributions. The directory consists of three main files:

1. herschel.py - Focuses on 2D Gaussian distribution visualizations, including interactive dartboard demonstrations, coordinate systems, and various mathematical transformations. It contains multiple scene classes that build up different aspects of understanding 2D Gaussian distributions.

2. integral.py - Provides animations specifically focused on Gaussian integrals, featuring bell curve visualizations, area calculations, and 3D representations. It includes both 2D and 3D visualizations with interactive elements and detailed mathematical explanations.

3. supplements.py - Contains supplementary scenes for the video series, including zoom animations, title sequences, story elements, and connections to related content. This file helps create the overall narrative structure of the educational content.

Together, these files form a comprehensive video tutorial about Gaussian integrals and distributions, using visual animations to explain complex mathematical concepts. The content appears to be part of a larger educational series, with references to central limit theorem (CLT) and other related mathematical concepts.

The directory is designed to be used with the Manim animation engine, and requires various dependencies including numpy, scipy, and core Manim functionality to create the mathematical visualizations.</directory-summary><file name="herschel.py"><declarations>
        
        n_points = 2000
        n_dots_per_moment = 10
        c_values = [1.0, 0.5, -1.0, -0.7, -0.5, 0.25, -0.2, -0.4, -0.9, -0.1, 0.5, 0.3, 0.1]
    </declarations>
    <dependencies>
        <external>
            numpy
            manim
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports core Manim functionality and extensions</description>
            <filepath>_2023.clt.main</filepath>
            <description>Imports functionality from the CLT main module</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>Main construction method for various scene classes that creates and animates mathematical visualizations</description>
            <args>
                self: Scene instance
            </args>
            <returns />
            <side-effects>
                Creates and displays animations on screen
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_plane">
            <description>Creates and returns a NumberPlane object with specific configuration</description>
            <args>
                self: Scene instance
            </args>
            <returns>
                NumberPlane object
            </returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_dartboard">
            <description>Creates and returns a Dartboard object matched to plane dimensions</description>
            <args>
                self: Scene instance
                plane: NumberPlane object
            </args>
            <returns>
                Dartboard object
            </returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="add_random_points_anim">
            <description>Creates animation of random points appearing on the plane</description>
            <args>
                self: Scene instance
                plane: NumberPlane object
            </args>
            <returns />
            <side-effects>
                Adds animation to scene
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains several scene classes for visualizing 2D Gaussian distributions and related mathematical concepts using Manim. The main scenes include TwoDGaussianAsADistribution, FaintDartboard, ShowXYCoordinate, IndependentCoordinates, ShowPointR0, RescaleG, ManyDifferentFs, VariableInputs, RationalNumbers, and TwoKeyProperties. Each scene creates different visualizations and animations to demonstrate properties of Gaussian distributions and mathematical transformations.
    </file-summary></file>
        <file name="integral.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
            numpy (as np)
            scipy.stats
            math
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports core Manim functionality</description>
            <filepath>_2023.convolutions2.continuous</filepath>
            <description>Imports related continuous convolution animations</description>
            <filepath>_2023.clt.main</filepath>
            <description>Imports central limit theorem related content</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="LastTime">
            <description>A video wrapper class with title "Normal Distribution"</description>
            <args />
            <returns />
            <side-effects>
                
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="AltBuildUpGaussian">
            <description>An alternative implementation of BuildUpGaussian</description>
            <args />
            <returns />
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="BellCurveArea">
            <description>Creates an animation showing the area under a bell curve with interactive elements</description>
            <args>self</args>
            <returns />
            <side-effects>
                Creates and animates various mathematical objects on screen
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="CartesianSlices">
            <description>Creates an animation showing Cartesian slices of a 3D Gaussian surface</description>
            <args>self</args>
            <returns />
            <side-effects>
                Creates and animates 3D mathematical visualizations
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="CartesianSliceOverlay">
            <description>Creates an overlay animation explaining Cartesian slices with equations</description>
            <args>self</args>
            <returns />
            <side-effects>
                Creates and animates mathematical equations and explanatory text
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains Manim animations for visualizing and explaining Gaussian integrals. It includes multiple scene classes that build up the visualization of a bell curve, its area, and various ways of understanding the integral through both 2D and 3D representations. The animations include interactive elements, mathematical equations, and explanatory text to help understand the concepts.
    </file-summary></file>
        <file name="supplements.py"><declarations>
        None at file level
    </declarations>
    <dependencies>
        <external>
            None
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim animation library components</description>
            <filepath>_2023.clt.main</filepath>
            <description>Imports components from the CLT (Central Limit Theorem) main module</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>Scene construction method present in multiple scene classes</description>
            <args>self</args>
            <returns />
            <side-effects>
                Creates and animates visual elements in the scene
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains multiple scene classes for a mathematical visualization video, including:
        - WignerZoom/WignerReverseZoom: Scenes showing zoom animations on images
        - PaperTitle: Scene showing paper title animation
        - StoryWords/ClosingStoryWords: Scenes displaying story text
        - ClassicProofFrame: Video wrapper scene
        - OtherVideos: Scene showing thumbnails of related videos
        - Various other scenes related to mathematical concepts and animations
        
        The scenes primarily use manim to create mathematical animations and visualizations, with many focusing on Gaussian distributions and related mathematical concepts.
    </file-summary></file>
      </directory>
      <directory name="moser_reboot">
        <directory-summary>This directory contains code for creating mathematical animations related to Moser's Circle Problem, a geometric and combinatorial mathematics concept. The main.py file implements various Manim scenes that build up an educational explanation of this mathematical problem.

The directory's content is focused on:
1. Mathematical calculations through the moser() function that computes combinations
2. Multiple animated scenes that progressively explain mathematical concepts
3. Visual demonstrations of patterns and geometric relationships
4. Educational content delivery through animated mathematical diagrams and explanations

The implementation relies on Manim's animation framework (imported through manim_imports_ext) to create visual mathematical content. This directory appears to be part of a larger educational mathematics visualization project, specifically focused on explaining Moser's Circle Problem through animated sequences.

Users would typically use this directory's contents to generate educational videos about this mathematical concept, with the various scenes building upon each other to create a complete educational narrative.</directory-summary><file name="main.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim functionality needed for animations and scenes</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="moser">
            <description>Calculates a value based on combinations of n using choose function</description>
            <args>n: Integer - Input value for calculation</args>
            <returns>Integer - Result of choose(n,4) + choose(n,2) + 1</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    - No error handling for invalid n values
                    - No type checking on input
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements several manim scenes related to Moser's Circle Problem. The main components are:
        - A moser() function for calculations
        - Introduction scene showing a title animation
        - ShowPattern scene demonstrating number patterns
        - Multiple scenes showing mathematical concepts including:
            - AskAboutPosition
            - ExplainNChoose2
            - SimpleCircle
            - LeftDiagram
            - Various other scenes for explaining mathematical concepts
        The file is focused on creating educational animations about mathematical concepts.
    </file-summary></file>
      </directory>
      <directory name="numberphile">
        <directory-summary>This directory contains animations related to Numberphile-style mathematical visualizations, specifically focusing on prime number behavior. The main content is a visualization of the "prime race" phenomenon, implemented in prime_race.py.

The directory contains code that creates three types of visualizations:
1. A dynamic race animation between prime numbers congruent to 1 and 3 (mod 4)
2. A graph showing the difference between counts of these primes up to ~27,000
3. A longer-range visualization extending to 650,000

The code uses Manim for animation and SymPy for mathematical computations. It's structured to create educational content similar to Numberphile videos, with clear visualizations and animations that help explain mathematical concepts. The implementations allow for different scales of visualization, from detailed shorter ranges to broader patterns over larger number ranges.

This directory appears to be part of a larger collection of mathematical animations, specifically styled for Numberphile-type educational content.</directory-summary><file name="prime_race.py"><declarations>
        
        race_length = 26863 (in PrimeRace class)
        race_length = 26863, y_range = (-4, 30, 2) (in RaceGraph class)
        race_length = 650000, y_range = (-10, 100, 5) (in LongRaceGraph class)
    </declarations>
    <dependencies>
        <external>
            manim_imports_ext
            sympy
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Main construction method for PrimeRace class that creates an animation showing a race between prime numbers congruent to 1 and 3 mod 4
            </description>
            <args>
                self: PrimeRace instance
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and animates visual elements on the scene
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="construct">
            <description>
                Main construction method for RaceGraph class that creates a graph showing the difference between counts of primes congruent to 3 and 1 mod 4
            </description>
            <args>
                self: RaceGraph instance
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and animates a graph visualization
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="set_x_shift">
            <description>
                Helper function to animate the shifting of a blocking rectangle
            </description>
            <args>
                x: position to shift to
                anims: list of additional animations
                kwargs: additional keyword arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Animates scene elements
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="set_x_squish">
            <description>
                Helper function to animate the squishing of the graph visualization
            </description>
            <args>
                x1: start position
                x2: end position
                kwargs: additional keyword arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Animates scene elements
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements a Manim animation visualizing the "prime race" between prime numbers that are congruent to 1 and 3 modulo 4. It contains three classes: PrimeRace for showing the actual race animation, RaceGraph for displaying a graph of the difference between the counts, and LongRaceGraph for showing the same visualization over a longer range of numbers.
    </file-summary></file>
      </directory>
      <directory name="optics_puzzles">
        <directory-summary>This directory contains a collection of Python files that implement various optical physics visualizations and animations using the Manim animation framework. The directory focuses on creating educational content about wave behavior, optics, and related physics phenomena.

Key components include:
- Wave behavior demonstrations (adding_waves.py, bending_waves.py, slowing_waves.py)
- Polarization and optical material effects (cylinder.py, annotations.py)
- Electric field visualizations (e_field.py)
- Index of refraction explanations (ior_annotations.py)
- Mechanical wave demonstrations (wave_machine.py)
- Core utility objects and functions (objects.py)

The files work together to create sophisticated animations that explain concepts like:
- Wave addition and interference
- Light refraction and reflection
- Polarization effects
- Electric fields and wave propagation
- Harmonic oscillation
- Wave-material interactions

The code is structured to be used with the Manim animation engine, with each file containing one or more Scene classes that can be rendered into educational videos. The objects.py file provides common utilities and base classes used across the other animations.

This directory appears to be part of a larger educational content creation project, likely for physics education or scientific visualization purposes. Users would typically render these scenes using Manim to create video content explaining optical physics concepts.</directory-summary><file name="adding_waves.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim core functionality and extensions</description>
            <filepath>_2023.optics_puzzles.objects</filepath>
            <description>Imports custom objects used for optics visualizations</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="WhiteLightAsASum">
            <description>Creates an animation showing how white light can be decomposed into a sum of different colored waves</description>
            <args>
                <arg>self: InteractiveScene instance</arg>
            </args>
            <returns />
            <side-effects>
                <effect>Creates and displays animation on screen</effect>
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="AddTwoSineWaves">
            <description>Creates an animation demonstrating the addition of two sine waves with interactive parameters</description>
            <args>
                <arg>self: InteractiveScene instance</arg>
            </args>
            <returns />
            <side-effects>
                <effect>Creates and displays animation on screen</effect>
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="WavePlusLayerInfluence">
            <description>Creates an animation showing how waves interact with layers of material</description>
            <args>
                <arg>self: InteractiveScene instance</arg>
            </args>
            <returns />
            <side-effects>
                <effect>Creates and displays animation on screen</effect>
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="Pulse">
            <description>Creates an animation demonstrating wave pulse behavior</description>
            <args>
                <arg>self: InteractiveScene instance</arg>
            </args>
            <returns />
            <side-effects>
                <effect>Creates and displays animation on screen</effect>
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains several animation scenes demonstrating wave behavior and interactions. It includes visualizations of white light decomposition, sine wave addition, wave-material interactions, and wave pulses. The animations are built using the manim framework and include interactive elements and parameter adjustments.
    </file-summary></file>
        <file name="annotations.py"><summary>&lt;declarations&gt;
        &lt;!-- No file-level declarations found --&gt;
    &lt;/declarations&gt;
    &lt;dependencies&gt;
        &lt;external&gt;
            &lt;!-- No external dependencies found --&gt;
        &lt;/external&gt;
        &lt;internal&gt;
            &lt;filepath&gt;manim_imports_ext&lt;/filepath&gt;
            &lt;description&gt;Imports manim core functionality&lt;/description&gt;
            &lt;filepath&gt;_2023.optics_puzzles.objects&lt;/filepath&gt;
            &lt;description&gt;Imports custom objects for optics puzzles&lt;/description&gt;
        &lt;/internal&gt;
    &lt;/dependencies&gt;
    &lt;function-defs&gt;
        &lt;function name="construct"&gt;
            &lt;description&gt;Scene construction method that appears in multiple classes to create various animations and visual elements&lt;/description&gt;
            &lt;args&gt;
                &lt;arg&gt;self: Scene instance&lt;/arg&gt;
            &lt;/args&gt;
            &lt;returns&gt;&lt;/returns&gt;
            &lt;side-effects&gt;
                Creates and animates visual elements on screen
            &lt;/side-effects&gt;
            &lt;errors-and-exceptions&gt;
                &lt;handled&gt;&lt;/handled&gt;
                &lt;unhandled&gt;&lt;/unhandled&gt;
            &lt;/errors-and-exceptions&gt;
        &lt;/function&gt;
        &lt;function name="get_questions"&gt;
            &lt;description&gt;Creates and returns a group of formatted question texts&lt;/description&gt;
            &lt;args&gt;
                &lt;arg&gt;self: Scene instance&lt;/arg&gt;
            &lt;/args&gt;
            &lt;returns&gt;VGroup of formatted question texts&lt;/returns&gt;
            &lt;side-effects&gt;
                None
            &lt;/side-effects&gt;
            &lt;errors-and-exceptions&gt;
                &lt;handled&gt;&lt;/handled&gt;
                &lt;unhandled&gt;&lt;/handled&gt;
            &lt;/errors-and-exceptions&gt;
        &lt;/function&gt;
        &lt;function name="get_pixel_indicator"&gt;
            &lt;description&gt;Creates an indicator showing pixel color at a given position&lt;/description&gt;
            &lt;args&gt;
                &lt;arg&gt;self: Scene instance&lt;/arg&gt;
                &lt;arg&gt;image: ImageMobject&lt;/arg&gt;
                &lt;arg&gt;vect_len: float = 2.0&lt;/arg&gt;
                &lt;arg&gt;direction: np.array = DOWN&lt;/arg&gt;
                &lt;arg&gt;square_size: float = 1.0&lt;/arg&gt;
            &lt;/args&gt;
            &lt;returns&gt;VGroup containing square and vector indicators&lt;/returns&gt;
            &lt;side-effects&gt;
                None
            &lt;/side-effects&gt;
            &lt;errors-and-exceptions&gt;
                &lt;handled&gt;&lt;/handled&gt;
                &lt;unhandled&gt;&lt;/unhandled&gt;
            &lt;/errors-and-exceptions&gt;
        &lt;/function&gt;
    &lt;/function-defs&gt;
    &lt;file-summary&gt;
        This file contains multiple scene classes for creating animations related to optics puzzles. It includes demonstrations of polarization, sugar solutions, light behavior, and various educational animations. The scenes use manim's animation framework to create visual explanations of optical phenomena.
    &lt;/file-summary&gt;</summary></file>
        <file name="bending_waves.py"><summary>&lt;declarations&gt;
        &lt;!-- No file-level variable/constant declarations --&gt;
    &lt;/declarations&gt;
    &lt;dependencies&gt;
        &lt;external&gt;
            &lt;!-- Dependencies from external libraries --&gt;
            &lt;filepath&gt;manim_imports_ext&lt;/filepath&gt;
        &lt;/external&gt;
        &lt;internal&gt;
            &lt;filepath&gt;_2023.optics_puzzles.objects&lt;/filepath&gt;
            &lt;description&gt;Imports objects used for optics puzzle visualizations&lt;/description&gt;
        &lt;/internal&gt;
    &lt;/dependencies&gt;
    &lt;function-defs&gt;
        &lt;function name="get_beam"&gt;
            &lt;description&gt;Creates and returns a beam line with updaters for angle tracking&lt;/description&gt;
            &lt;args&gt;
                angle_tracker: ValueTracker - Tracks the angle of the beam
                hit_point: Point - Where the beam hits the medium
                stroke_color: Color - Color of the beam (default YELLOW)
                stroke_width: float - Width of beam stroke (default 3)
            &lt;/args&gt;
            &lt;returns&gt;Line object with updaters for beam visualization&lt;/returns&gt;
            &lt;side-effects&gt;None&lt;/side-effects&gt;
            &lt;errors-and-exceptions&gt;
                &lt;handled&gt;&lt;/handled&gt;
                &lt;unhandled&gt;&lt;/unhandled&gt;
            &lt;/errors-and-exceptions&gt;
        &lt;/function&gt;
        &lt;function name="get_medium"&gt;
            &lt;description&gt;Creates and returns a medium object with specified properties&lt;/description&gt;
            &lt;args&gt;
                width: float - Width of medium
                height: float - Height of medium 
                depth: float - Depth of medium
                color: Color - Color of medium
                opacity: float - Opacity of medium
            &lt;/args&gt;
            &lt;returns&gt;VCube object representing the medium&lt;/returns&gt;
            &lt;side-effects&gt;None&lt;/side-effects&gt;
            &lt;errors-and-exceptions&gt;
                &lt;handled&gt;&lt;/handled&gt;
                &lt;unhandled&gt;&lt;/handled&gt;
            &lt;/errors-and-exceptions&gt;
        &lt;/function&gt;
        &lt;function name="get_wave"&gt;
            &lt;description&gt;Creates and returns a wave object with specified properties&lt;/description&gt;
            &lt;args&gt;
                **kwargs: Additional arguments passed to WaveIntoMedium
            &lt;/args&gt;
            &lt;returns&gt;WaveIntoMedium object&lt;/returns&gt;
            &lt;side-effects&gt;None&lt;/side-effects&gt;
            &lt;errors-and-exceptions&gt;
                &lt;handled&gt;&lt;/handled&gt;
                &lt;unhandled&gt;&lt;/handled&gt;
            &lt;/errors-and-exceptions&gt;
        &lt;/function&gt;
        &lt;function name="get_wave_dots"&gt;
            &lt;description&gt;Creates dots visualization for waves&lt;/description&gt;
            &lt;args&gt;
                wave: Wave object to visualize
                density: float - Density of dots
                offset: float - Offset for dots
                color: Color - Color of dots
                max_opacity: float - Maximum opacity of dots
            &lt;/args&gt;
            &lt;returns&gt;WavesByOpacity object&lt;/returns&gt;
            &lt;side-effects&gt;None&lt;/side-effects&gt;
            &lt;errors-and-exceptions&gt;
                &lt;handled&gt;&lt;/handled&gt;
                &lt;unhandled&gt;&lt;/handled&gt;
            &lt;/errors-and-exceptions&gt;
        &lt;/function&gt;
    &lt;/function-defs&gt;
    &lt;file-summary&gt;
        This file implements various Manim scenes for visualizing wave behavior in different mediums, including Snell's Law demonstrations, wave transitions between mediums, and prism effects. It contains several scene classes (SnellsLaw, WavesIntoAngledMedium, etc.) and helper classes for wave visualization (WaveIntoMedium, ScalarFieldByOpacity, etc.).
    &lt;/file-summary&gt;</summary></file>
        <file name="cylinder.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim core functionality</description>
            <filepath>_2023.optics_puzzles.objects</filepath>
            <description>Imports custom objects needed for optics visualizations</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>Main animation construction method for each scene class</description>
            <args>
                <arg>self - Scene instance</arg>
            </args>
            <returns />
            <side-effects>
                Creates and animates various manim objects on screen
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_slice_group">
            <description>Creates a group of objects representing a slice view</description>
            <args>
                <arg>self - Scene instance</arg>
                <arg>axes - Coordinate axes</arg>
                <arg>wave - Wave object</arg>
            </args>
            <returns>Group of visualization objects</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_polarization_rod">
            <description>Creates a rod showing polarization direction</description>
            <args>
                <arg>self - Scene instance</arg>
                <arg>axes - Coordinate axes</arg>
                <arg>wave - Wave object</arg>
                <arg>get_x - Function to get x position</arg>
                <arg>stroke_color - Optional color</arg>
                <arg>length_mult - Optional length multiplier</arg>
                <arg>stroke_width - Optional stroke width</arg>
            </args>
            <returns>Line object representing polarization rod</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains several scene classes for visualizing light behavior in optical systems, particularly focusing on polarization and wave propagation through cylinders. The main scenes include SimpleLightBeam, TwistingLightBeam, and variations for different colors and behaviors. The code makes heavy use of manim's 3D visualization capabilities and custom updater functions to create smooth animations of wave propagation and polarization effects.
    </file-summary></file>
        <file name="driven_harmonic_oscillator.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            numpy (as np)
            manim_imports_ext
        </external>
        <internal>
            <filepath>_2023.optics_puzzles.objects</filepath>
            <description>
                Imports TimeVaryingVectorField, Calcite, and Sucrose classes used for visualization
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="HarmonicOscillator">
            <description>
                A class representing a harmonic oscillator that can be driven by external forces
            </description>
            <args>
                center: np.array - Center position (default: zeros)
                initial_velocity: np.array - Initial velocity (default: zeros) 
                k: float - Spring constant (default: 20.0)
                damping: float - Damping coefficient (default: 0.1)
                mass: float - Mass of oscillator (default: 1.0)
                radius: float - Visual radius (default: 0.5)
                color: str - Color of oscillator (default: BLUE)
                three_d: bool - Whether to make 3D (default: True)
            </args>
            <returns>
                Instance of HarmonicOscillator class
            </returns>
            <side-effects>
                Updates position and velocity based on physics simulation
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="Spring">
            <description>
                A class representing a visual spring connecting two points
            </description>
            <args>
                mobject: Mobject - Object spring is attached to
                base_point: np.array - Fixed point of spring
                edge: np.array - Edge direction (default: ORIGIN)
                stroke_color: str - Color of spring (default: GREY)
                stroke_width: float - Width of spring line (default: 2)
                twist_rate: float - Rate of spring twists (default: 8.0)
                n_twists: int - Number of twists (default: 8)
                radius: float - Radius of spring coils (default: 0.1)
                lead_length: float - Length of straight ends (default: 0.25)
            </args>
            <returns>
                Instance of Spring class
            </returns>
            <side-effects>
                Updates spring visualization based on attached object movement
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="DynamicPlot">
            <description>
                A class for creating dynamic plots that update over time
            </description>
            <args>
                axes: Axes - Coordinate axes for plotting
                func: callable - Function to plot
                stroke_color: str - Color of plot line (default: RED)
                stroke_width: float - Width of plot line (default: 3)
            </args>
            <returns>
                Instance of DynamicPlot class
            </returns>
            <side-effects>
                Updates plot visualization over time
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements a driven harmonic oscillator simulation and visualization using Manim. It includes classes for the oscillator itself, connecting springs, and dynamic plotting. The main scene class DrivenHarmonicOscillator demonstrates the physics of driven oscillations, including resonance effects and frequency response.
    </file-summary></file>
        <file name="e_field.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim functionality</description>
            <filepath>_2023.optics_puzzles.objects</filepath>
            <description>Imports custom objects for optics puzzles</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_influence_ring">
            <description>Creates an expanding circle animation to show influence propagation</description>
            <args>
                center_point: Point where ring originates
                color: Color of ring (default WHITE)
                speed: Speed of ring expansion (default 2.0)
                max_width: Maximum width of ring stroke (default 3.0)
                width_decay_exp: Exponent for width decay (default 0.5)
            </args>
            <returns>Circle object with updater for expansion animation</returns>
            <side-effects>
                Modifies the passed Circle object by adding updater
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements electric field visualizations and animations using manim. It contains several scene classes that demonstrate different aspects of electric fields and wave propagation:

        - TestFields: Basic test scene for Coulomb and Lorentz fields
        - IntroduceEField: Main scene introducing electric field concepts
        - Multiple specialized scenes for different field visualizations (CircularPolarization, RandomRicochet, etc.)
        
        The scenes use custom objects from the optics_puzzles module to create interactive animations showing field lines, wave propagation, and particle interactions. The animations demonstrate concepts like Coulomb's law, Lorentz force, and electromagnetic wave propagation.
    </file-summary></file>
        <file name="ior_annotations.py"><declarations>
        <constant name="EQUATION_T2C">Dictionary mapping LaTeX expressions to colors for equation text coloring</constant>
    </declarations>
    <dependencies>
        <external>
            manim_imports_ext
        </external>
    </dependencies>
    <function-defs>
        <function name="get_bordered_thumbnail">
            <description>Creates a bordered thumbnail from an image file</description>
            <args>
                path: str - Path to the image file
                height: float = 3 - Height of the thumbnail
                stroke_width: float = 3 - Width of the border stroke
            </args>
            <returns>Group - Manim Group containing the bordered image</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    File not found errors if image path is invalid
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="HoldUpAlbumCover">
            <description>Scene showing teacher holding up Dark Side of the Moon album cover</description>
            <args>TeacherStudentsScene parameters</args>
            <returns />
            <side-effects>
                Renders animation scene
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="DefineIndexOfRefraction">
            <description>Scene defining and explaining index of refraction</description>
            <args>InteractiveScene parameters</args>
            <returns />
            <side-effects>
                Renders animation scene
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains Manim scenes and utilities for creating animations explaining the index of refraction concept. It includes scenes showing the Dark Side of the Moon album cover, defining index of refraction, and various other educational animations about optics and wave behavior. The file uses Manim's animation framework to create mathematical visualizations.
    </file-summary></file>
        <file name="objects.py"><declarations>
        spectral_cmap = colormaps.get_cmap("Spectral")
    </declarations>
    <dependencies>
        <external>
            from __future__ import annotations
            from matplotlib import colormaps
            from typing import TYPE_CHECKING, Callable
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim core functionality and extensions</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_spectral_color">
            <description>Converts an alpha value to a color using the spectral colormap</description>
            <args>alpha: float between 0 and 1</args>
            <returns>Color object with RGB values from spectral colormap</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled>Could raise errors if alpha is outside [0,1] range</unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_spectral_colors">
            <description>Generates a list of colors from the spectral colormap</description>
            <args>
                n_colors: int - number of colors to generate
                lower_bound: float - lower bound for alpha values (default 0)
                upper_bound: float - upper bound for alpha values (default 1)
            </args>
            <returns>List of Color objects</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled>Could raise errors if bounds are invalid</unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_axes_and_plane">
            <description>Creates and configures 3D axes and a number plane</description>
            <args>
                Various configuration parameters for axes ranges, units, and styling
            </args>
            <returns>Tuple of (ThreeDAxes, NumberPlane)</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_twist">
            <description>Calculates twist based on wavelength and distance</description>
            <args>
                wave_length: float
                distance: float
            </args>
            <returns>float - twist value</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled>Division by zero if wavelength is 0</unhandled>
            </errors-and-exceptions>
        </function>
        <function name="acceleration_from_position">
            <description>Calculates acceleration using finite differences</description>
            <args>
                pos_func: Callable - position function
                time: float - time at which to calculate acceleration
                dt: float - time step for finite difference (default 1e-3)
            </args>
            <returns>Acceleration vector</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="points_to_particle_info">
            <description>Calculates unit vectors and distances from particle to points</description>
            <args>
                particle: Particle object
                points: array of points
                radius: float or None
                c: float - speed constant
            </args>
            <returns>Tuple of (unit vectors, norms, adjusted norms)</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled>Handles division by zero in norm calculation</handled>
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines various utility functions and classes for optics-related animations in Manim. It includes functions for color management, coordinate calculations, and physical simulations (Coulomb/Lorentz forces). It also defines several classes for representing molecules and wave phenomena.
    </file-summary></file>
        <file name="slowing_waves.py"><declarations>
        
        default_wave_config = dict(z_amplitude=0, y_amplitude=1, wave_len=2.0, color=BLUE)
        default_layer_style = dict(stroke_width=2.0, stroke_color=WHITE)
        default_vect_wave_style = dict(stroke_opacity=0.5)
    </declarations>
    <dependencies>
        <external>
            manim_imports_ext
        </external>
        <internal>
            <filepath>_2023.optics_puzzles.objects</filepath>
            <description>
                Imports custom objects needed for optics visualizations
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>
                Initializes a SlicedWave object with given parameters
            </description>
            <args>
                axes: ThreeDAxes object
                layer_xs: array of x-coordinates for layers
                phase_kick_back: float for phase offset
                layer_height: float for height of layers
                damping_per_layer: float for damping factor
                wave_config: dict of wave configuration
                vect_wave_style: dict of vector wave style
                layer_style: dict of layer style
            </args>
            <returns />
            <side-effects>
                Initializes instance variables and creates wave visualization components
            </side-effects>
        </function>
        <function name="set_layer_xs">
            <description>
                Sets the x-coordinates for the layers
            </description>
            <args>
                xs: array of x-coordinates
            </args>
            <returns />
            <side-effects>
                Updates the layer_xs instance variable
            </side-effects>
        </function>
        <function name="xt_to_yz">
            <description>
                Converts x,t coordinates to y,z coordinates for wave visualization
            </description>
            <args>
                x: x-coordinate array
                t: time value
            </args>
            <returns>
                Tuple of (y-coordinates, z-coordinates)
            </returns>
            <side-effects />
        </function>
    </function-defs>
    <file-summary>
        This file implements wave visualization for optics simulations, particularly focusing on wave behavior when passing through different media. It includes the SlicedWave class for creating wave visualizations with multiple layers, and several scene classes that demonstrate different wave behaviors like phase shifts, absorption, and speed changes in different media.
    </file-summary></file>
        <file name="slowing_waves_insert_embed.py"><declarations>
        
        default_wave_config = dict(z_amplitude=0, y_amplitude=1, wave_len=2.0, color=BLUE)
        default_layer_style = dict(stroke_width=2.0, stroke_color=WHITE)
        default_vect_wave_style = dict(stroke_opacity=0.5)
    </declarations>
    <dependencies>
        <external>
            manim_imports_ext
        </external>
        <internal>
            <filepath>_2023.optics_puzzles.objects</filepath>
            <description>
                Imports custom objects needed for optics visualizations
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>
                Initializes a SlicedWave object with given parameters
            </description>
            <args>
                axes: ThreeDAxes object
                layer_xs: array of x-coordinates for layers
                phase_kick_back: float for phase offset
                layer_height: float for height of layers
                damping_per_layer: float for damping factor
                wave_config: dict of wave configuration
                vect_wave_style: dict of vector wave style
                layer_style: dict of layer style
            </args>
            <returns />
            <side-effects>
                Initializes instance variables and creates wave visualization components
            </side-effects>
        </function>
        <function name="set_layer_xs">
            <description>
                Updates the x-coordinates of the layers
            </description>
            <args>
                xs: array of new x-coordinates
            </args>
            <returns />
            <side-effects>
                Updates layer_xs instance variable
            </side-effects>
        </function>
        <function name="xt_to_yz">
            <description>
                Converts x,t coordinates to y,z coordinates for wave visualization
            </description>
            <args>
                x: x-coordinate array
                t: time value
            </args>
            <returns>
                Tuple of (y-coordinates, z-coordinates)
            </returns>
        </function>
    </function-defs>
    <file-summary>
        This file implements wave visualization for optics simulations, particularly focusing on wave behavior when passing through different media. It contains the SlicedWave class for creating wave visualizations with phase shifts and multiple scene classes for different demonstrations of wave behavior in various media. The scenes show effects like phase kicks, wave slowing, and absorption in materials like glass.
    </file-summary></file>
        <file name="wave_machine.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
            manim_imports_ext
        </external>
        <internal>
            
        </internal>
    </dependencies>
    <function-defs>
        <function name="__init__">
            <description>
                Constructor for WaveMachine class that creates a mechanical wave demonstration using cylinders and spheres
            </description>
            <args>
                n_arms: int = 100 - Number of arms in the wave machine
                width: float = 20 - Width of the machine
                delta_angle: float = 2*TAU/50 - Angle between arms
                shaft_radius: float = 0.1 - Radius of main shaft
                arm_radius: float = 0.025 - Radius of each arm
                arm_length: float = 1.5 - Length of each arm
                arm_cap_radius: float = 0.035 - Radius of arm caps
                shaft_color: Color = GREY_D - Color of main shaft
                arm_color: Color = GREY_BROWN - Color of arms
                cap_color: Color = GREY_BROWN - Color of arm caps
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Initializes the WaveMachine object with shaft and arms as components
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="construct">
            <description>
                Main animation method for WaveMachineDemo class that creates and animates the wave machine
            </description>
            <args>
                self - Reference to the scene instance
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and animates various wave machine configurations with different animations and camera movements
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_rotation_arrow_animations">
            <description>
                Creates animations for rotation arrows in the scene
            </description>
            <args>
                self - Reference to the scene instance
                x_value: float = 6 - X-coordinate position for the arrows
            </args>
            <returns>
                Generator of arrow animations
            </returns>
            <side-effects>
                Creates and configures arrow animations
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements a wave machine visualization using the Manim animation library. It contains two main classes: WaveMachine (a mechanical wave demonstration device) and WaveMachineDemo (a scene that demonstrates the wave machine with various animations). The wave machine consists of a central shaft with multiple arms arranged in a helical pattern, which when rotated creates a wave-like visual effect.
    </file-summary></file>
      </directory>
      <directory name="standup_maths">
        <directory-summary>This directory contains Manim animation scripts focused on mathematical visualizations, likely created for or used in Stand-up Maths videos. It includes two main Python files:

1. basketball.py - Creates sophisticated 3D visualizations of NBA shot data from 1997-2022. The script generates both dot-based representations and density bar visualizations of shot locations on a basketball court, featuring interactive camera movements and year-by-year progression animations.

2. pool.py - Demonstrates pool table physics and reflection patterns through animations. It visualizes ball trajectories, reflection points, and geometric patterns on a simulated pool table, including functions for calculating reflections and creating various line patterns.

These files appear to be specialized visualization tools for educational mathematics content, utilizing Manim's animation capabilities to create engaging visual demonstrations of mathematical concepts in sports and physics. The scripts are designed to be run using Manim to generate video animations, likely for educational content creation.</directory-summary><file name="basketball.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            manim_imports_ext
            pandas
        </external>
        <internal>
            
        </internal>
    </dependencies>
    <function-defs>
        <function name="year_to_file_name">
            <description>
                Converts a year to a filename format for NBA shot data CSV files
            </description>
            <args>
                year: integer representing the year
            </args>
            <returns>
                string: formatted filename path
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="load_data">
            <description>
                Loads NBA shot data from a CSV file for a specific year
            </description>
            <args>
                year: integer representing the year to load data for
            </args>
            <returns>
                numpy array: filtered coordinates of shots excluding (0,0) coordinates
            </returns>
            <side-effects>
                Reads from filesystem
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    FileNotFoundError when CSV file doesn't exist
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_dots">
            <description>
                Creates a DotCloud visualization of shot coordinates
            </description>
            <args>
                axes: Manim Axes object
                coords: numpy array of coordinates
            </args>
            <returns>
                DotCloud: Manim object representing shot locations
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_bars">
            <description>
                Creates 3D bar visualization of shot density
            </description>
            <args>
                axes: Manim Axes object
                coords: numpy array of coordinates
                resolution: tuple of (width, height) for grid resolution, defaults to (50, 94)
            </args>
            <returns>
                VGroup: collection of 3D boxes representing shot density
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file is a Manim animation script that visualizes NBA shot data over multiple years (1997-2022). It creates a 3D visualization showing shot locations on a basketball court, with both dot representations and density bars. The script includes a class ShotHistory that inherits from InteractiveScene and ThreeDScene to create an animated visualization with camera movements and year progression.
    </file-summary></file>
        <file name="pool.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            manim_imports_ext
        </external>
        <internal>
            
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_reflection">
            <description>
                Calculates reflection point based on given point and dimensions
            </description>
            <args>
                point: Vector/point coordinates
                dims: List of dimensions to reflect (default=[0])
            </args>
            <returns>
                Vector representing reflected point
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="line_to_trajectory">
            <description>
                Converts a line into a trajectory with reflections
            </description>
            <args>
                line: Line object
                n_reflections: Number of reflections (default=2)
            </args>
            <returns>
                VMobject representing the trajectory
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_diamond_line">
            <description>
                Creates a line between points on number lines with specified length
            </description>
            <args>
                x: x-coordinate
                y: y-coordinate
                length: Line length (default=25)
            </args>
            <returns>
                Line object
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="n_to_lines">
            <description>
                Generates a group of diamond lines based on input number
            </description>
            <args>
                n: Number to generate lines from
            </args>
            <returns>
                VGroup of lines
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_clean_lines">
            <description>
                Creates lines from a point to diamond points
            </description>
            <args>
                point: Point to draw lines from
            </args>
            <returns>
                VGroup of lines
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains a Manim animation class PoolTableReflections that demonstrates pool table reflections and trajectories. It creates an interactive scene showing a pool table with a ball, and visualizes various reflection patterns and trajectories using geometric calculations and animations. The code includes helper functions for calculating reflections, creating trajectories, and generating various line patterns.
    </file-summary></file>
      </directory>
    </directory>
    <directory name="_2024">
      <directory-summary>This directory contains a comprehensive collection of Manim animation projects organized into several key subdirectories:

1. antp/ - Animations related to prime numbers and the twin prime conjecture, including visualizations of prime sequences, proofs, and mathematical concepts.

2. holograms/ - A complete toolkit for creating hologram and diffraction visualizations, including shader implementations, video frame processing, and educational animations about holographic principles.

3. manim_demo/ - Example implementations showing how to create complex mathematical visualizations, featuring the Lorenz attractor system as a demonstration.

4. puzzles/ - Mathematical puzzle visualizations covering topics like geometric problems, random variables, and mathematical relationships through interactive animations.

5. transformers/ - An extensive collection of animations explaining transformer neural networks, including:
   - Attention mechanisms
   - Word embeddings
   - Network architecture
   - Text generation
   - Educational visualizations

The directory serves as a repository of sophisticated mathematical and scientific animations created with Manim, suitable for educational content creation. Each subdirectory is self-contained with its own specialized focus, but shares common Manim infrastructure and visualization techniques.

To use these animations:
1. Install Manim and required dependencies
2. Select desired scene classes from relevant subdirectories
3. Render animations using Manim's command line interface
4. Combine rendered animations into educational videos or presentations

The code is structured to be both educational in content and serve as examples of advanced Manim usage for creating complex mathematical and scientific visualizations.</directory-summary><directory name="antp">
        <directory-summary>This directory contains animations and visualizations related to prime numbers and the twin prime conjecture, implemented using the Manim mathematical animation library. The main.py file defines multiple scene classes that create educational animations demonstrating various concepts about prime numbers, including:

    - Visualizations of twin primes and prime number sequences
    - Historical timeline animations
    - Proofs of infinite primes (including Euclid's proof)
    - Prime number density and distribution visualizations
    - Demonstrations of the Sieve of Eratosthenes
    - Animations showing prime gaps and related mathematical concepts

    The directory appears to be part of a larger educational mathematics visualization project, with scenes that can be rendered individually to create mathematical explainer videos. It depends on external libraries like sympy for mathematical operations and builds on internal components like the ChartBars class for data visualization.

    To use these animations, one would need to run the Manim rendering commands on the specific scene classes defined in main.py to generate the desired mathematical visualization videos.</directory-summary><file name="main.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            manim_imports_ext
            sympy
        </external>
        <internal>
            <filepath>_2023.clt.main</filepath>
            <description>Imports ChartBars class used for creating bar charts</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>Main animation construction method present in multiple scene classes</description>
            <args>
                self: Scene instance
            </args>
            <returns />
            <side-effects>
                Creates and plays animations on screen
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains multiple Manim scene classes that create animations related to prime numbers and the twin prime conjecture:

        - TwinPrimScrolling: Shows scrolling animation of prime numbers with twin primes highlighted
        - Timeline: Creates a historical timeline visualization
        - InfinitePrimes: Demonstrates the concept of infinite primes
        - ThoughtBubble/SimpleBubble: Simple thought bubble animations
        - EuclidProof: Animates Euclid's proof of infinite primes
        - PrimeDensityHistogram: Shows histogram of prime number density
        - PrimesNearMillion: Visualizes primes near one million
        - SieveWithMod: Demonstrates sieve of Eratosthenes with modular arithmetic
        - Various other scenes related to prime gaps and mathematical concepts

        The file focuses on mathematical visualization and proof concepts around prime numbers.
    </file-summary></file>
      </directory>
      <directory name="holograms">
        <directory-summary>This directory contains a comprehensive set of files for creating educational animations about holograms and diffraction using Manim. The implementation consists of several key components:

1. diffraction.py - Core implementation of diffraction-related animations, including wave interference patterns, light intensity visualizations, and various scene classes demonstrating diffraction concepts.

2. diffraction_shader/ - Contains GLSL shader files (frag.glsl and vert.glsl) that implement real-time holographic diffraction simulations, supporting up to 32 wave sources and capable of rendering complex interference patterns.

3. model.py - Provides functionality for extracting and processing video frames, specifically designed to work with hologram demonstration footage. It includes tools for creating grid-based frame arrangements.

4. supplements.py - Contains additional scene classes for educational content about holograms, including comparisons between photographs and holograms, conceptual demonstrations, and pedagogical transitions.

The directory serves as a complete toolkit for creating educational content about holography, combining both technical simulations through shaders and explanatory animations through Manim. It's designed to be used as part of a larger educational video project, with components that can handle both the mathematical/physical demonstrations and the conceptual explanations of holographic principles.</directory-summary><file name="diffraction.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            numpy (as np)
            moderngl
            Path
        </external>
        <internal>
            manim_imports_ext
            <filepath>manim_imports_ext</filepath>
            <description>Imports core Manim functionality and extensions</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="hsl_to_rgb">
            <description>Converts HSL color values to RGB color values</description>
            <args>
                hsl: np.ndarray - Array of shape (n,3) containing HSL values (Hue, Saturation, Lightness)
            </args>
            <returns>
                np.ndarray - Array of shape (n,3) containing RGB values in range [0,1]
            </returns>
            <side-effects>
                None
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Could handle invalid input array shapes
                    Could handle out of range HSL values
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements diffraction-related animations and visualizations in Manim. It contains:
        
        1. A utility function for HSL to RGB color conversion
        2. LightWaveSlice class for rendering wave interference patterns
        3. LightIntensity class extending LightWaveSlice for showing light intensity
        4. Several scene classes demonstrating diffraction concepts:
           - LightFieldAroundScene
           - DiffractionGratingScene 
           - LightExposingFilm
           - TwoInterferingWaves
           - ComplexWaves
           - StateOnA2DScreen
           - PointSourceDiffractionPattern
    </file-summary></file>
        <directory name="diffraction_shader">
          <directory-summary>This directory contains GLSL shader files that implement a holographic diffraction simulation system. The implementation consists of two key shader files:

1. frag.glsl - A fragment shader that handles the core wave interference calculations. It can simulate up to 32 wave sources (either point sources or plane waves) and compute their interference patterns. The shader supports customizable parameters like frequency, wave number, amplitude, and decay factors, and can output either wave amplitude or intensity visualization.

2. vert.glsl - A complementary vertex shader that handles the basic geometry processing, passing vertex positions through to the fragment shader where the main diffraction calculations occur.

Together, these shaders create a real-time holographic diffraction visualization system that could be used for educational purposes or visual effects. The system is highly parameterizable through uniform variables, allowing for dynamic adjustment of the interference pattern characteristics.

This shader system would typically be used within a larger graphics application (like Manim) to render interference patterns and wave phenomena, particularly useful for physics demonstrations or artistic effects involving wave behavior.</directory-summary><file name="frag.glsl"><declarations>
        <uniform-variables>
            - vec3 color
            - float opacity, frequency, wave_number, max_amp, n_sources, time, decay_factor
            - float show_intensity
            - vec3 point_source0 through point_source31 (32 total)
        </uniform-variables>
        <input-variables>
            - vec3 frag_point
        </input-variables>
        <output-variables>
            - vec4 frag_color
        </output-variables>
        <constants>
            - float TAU = 6.283185307179586
            - float PLANE_WAVE_THRESHOLD = 999.0
        </constants>
    </declarations>
    <function-defs>
        <function name="amp_from_source">
            <description>
                Calculates the complex amplitude contribution from a single wave source, handling both plane waves and point sources
            </description>
            <args>
                vec3 source - The position vector of the wave source
            </args>
            <returns>
                vec2 - Complex amplitude (real and imaginary components)
            </returns>
            <side-effects>
                None
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="main">
            <description>
                Main shader function that computes the final fragment color based on wave interference from multiple sources
            </description>
            <args>
                None (uses uniform and input variables)
            </args>
            <returns>
                void (sets frag_color output variable)
            </returns>
            <side-effects>
                Sets the fragment color output (frag_color)
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL fragment shader that simulates wave interference patterns from multiple sources. It can handle both point sources and plane waves, calculating the amplitude at each fragment position. The shader supports up to 32 wave sources and can display either the wave amplitude or intensity. The final output includes color modulation based on the wave's magnitude and opacity based on the amplitude strength.
    </file-summary></file>
          <file name="vert.glsl"><declarations>
        <variable>in vec3 point</variable>
        <variable>out vec3 frag_point</variable>
    </declarations>
    <dependencies>
        <external>
            <dependency>OpenGL GLSL 3.30</dependency>
        </external>
        <internal>
            <filepath>emit_gl_Position.glsl</filepath>
            <description>
                Included via #INSERT directive, presumably contains the emit_gl_Position function implementation
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="main">
            <description>
                Vertex shader main function that passes through vertex position and sets gl_Position
            </description>
            <args>
                
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Sets frag_point output variable
                Calls emit_gl_Position which presumably sets gl_Position
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This is a GLSL vertex shader file that takes a 3D point as input, passes it through to the fragment shader as frag_point, and sets the vertex position using an externally defined emit_gl_Position function. It's a relatively simple pass-through vertex shader that appears to be part of a hologram diffraction effect implementation.
    </file-summary></file>
        </directory>
        <file name="model.py"><declarations>
        class ExtractFramesFromFootage(InteractiveScene):
            video_file = "/Users/grant/3Blue1Brown Dropbox/3Blue1Brown/videos/2024/holograms/SceneModel/MultiplePOVs.2.mp4"
            image_dir = "/tmp/"
            frequency = 0.25
            start_time = 0
            end_time = 14
            small_image_size = (1080, 1080)
            n_cols = 8
    </declarations>
    <dependencies>
        <external>
            cv2
            pathlib.Path
            PIL.Image (implied from Image usage)
        </external>
        <internal>
            <filepath>
                manim_imports_ext
            </filepath>
            <description>
                Imports manim-specific utilities and classes for scene creation and animation
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="setup">
            <description>
                Initializes the video capture and sets up video properties
            </description>
            <args>
                self: ExtractFramesFromFootage instance
            </args>
            <returns>
            </returns>
            <side-effects>
                Initializes self.video, self.video_fps, and self.video_duration
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    Potential cv2.VideoCapture failures
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="tear_down">
            <description>
                Releases the video capture resources
            </description>
            <args>
                self: ExtractFramesFromFootage instance
            </args>
            <returns>
            </returns>
            <side-effects>
                Releases video capture resources
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="construct">
            <description>
                Main animation construction method that extracts frames and creates animation
            </description>
            <args>
                self: ExtractFramesFromFootage instance
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and displays animation sequence
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="image_from_timestamp">
            <description>
                Extracts a frame from video at given timestamp and saves it as an image
            </description>
            <args>
                self: ExtractFramesFromFootage instance
                time: float - timestamp in seconds
            </args>
            <returns>
                ImageMobject or None if frame capture fails
            </returns>
            <side-effects>
                Saves image file to disk in image_dir
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    Failed frame capture is handled with print statement
                </handled>
                <unhandled>
                    File system errors when saving images
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines a manim scene class that extracts frames from a video file at regular intervals and creates an animation showing the extraction process. The extracted frames are arranged in a grid and displayed alongside the original video frame.
    </file-summary></file>
        <file name="supplements.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim functionality needed for scene creation and animations</description>
        </internal>
    </dependencies>
    <function-defs>
        
    </function-defs>
    <file-summary>
        This file contains supplementary scene classes for a manim animation project about holograms. The scenes include:

        - Comparisons between photographs and holograms
        - Animations for various hologram concepts
        - Visual demonstrations of diffraction and interference
        - Complex mathematical explanations using the complex plane
        - Teacher-student interaction scenes for pedagogical transitions
        - Various visual effects and animations to support the explanations

        The scenes appear to be part of a larger educational video about holography, with a mix of technical explanations and conceptual demonstrations. The code makes heavy use of manim's animation capabilities and custom scene classes.
    </file-summary></file>
      </directory>
      <directory name="manim_demo">
        <directory-summary>This directory contains demonstration code for Manim animations, specifically focused on visualizing the Lorenz attractor system. The main file 'lorenz.py' provides a complete implementation for creating sophisticated 3D animations of the Lorenz system, a famous chaotic dynamical system.

The directory serves as an example of how to:
1. Create complex mathematical visualizations using Manim
2. Implement numerical integration of differential equations
3. Generate 3D animations with multiple animated elements
4. Combine mathematical equations and dynamic visualizations

The code demonstrates advanced Manim usage by creating an animation that includes:
- Multiple 3D trajectories of the Lorenz system
- Color-coded paths
- Moving dots following the trajectories
- Rotating 3D axes
- Mathematical equations displayed in the corner

This directory can be used as a reference for creating similar mathematical visualizations or as a starting point for developing other complex Manim animations involving dynamical systems.</directory-summary><file name="lorenz.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            manim_imports_ext
            scipy.integrate (odeint, solve_ivp)
        </external>
        <internal>
            
        </internal>
    </dependencies>
    <function-defs>
        <function name="lorenz_system">
            <description>
                Defines the Lorenz system of differential equations
            </description>
            <args>
                t: float (time)
                state: list[float] (x, y, z coordinates)
                sigma: float = 10 (system parameter)
                rho: float = 28 (system parameter)
                beta: float = 8/3 (system parameter)
            </args>
            <returns>
                list[float] - derivatives [dx/dt, dy/dt, dz/dt]
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="ode_solution_points">
            <description>
                Solves the ODE system and returns solution points
            </description>
            <args>
                function: callable - The ODE system
                state0: list[float] - Initial state
                time: float - Total time to solve for
                dt: float = 0.01 - Time step
            </args>
            <returns>
                numpy.ndarray - Array of solution points
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="for_later">
            <description>
                Appears to be a placeholder function with example code
            </description>
            <args>
            </args>
            <returns>
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements a Manim animation of the Lorenz attractor system. It includes the mathematical definition of the Lorenz system, numerical integration utilities, and a visualization class LorenzAttractor that creates a 3D animation of multiple trajectories in the Lorenz system with color-coded paths and moving dots. The animation includes rotating 3D axes and the system's equations displayed in the corner.
    </file-summary></file>
      </directory>
      <directory name="puzzles">
        <directory-summary>This directory contains Python files for creating mathematical puzzle visualizations using the Manim animation library. The directory includes two main files:

1. added_dimension.py - Contains a collection of scene classes for visualizing various geometric and mathematical concepts including:
   - Lozenge shapes and tilings
   - 3D cube visualizations and arrangements
   - Circular strips and sphere problems
   - Monge's theorem demonstrations
   - Triangle area calculations
   - 4D determinant visualizations
   - Intersecting circles animations

2. max_rand.py - Focuses on visualizing random variables and their properties, featuring:
   - Animations for random number generation
   - Comparisons of random processes
   - Visualization tools for tracking and displaying random variables
   - Demonstrations of mathematical relationships between random values

The directory serves as a collection of mathematical puzzle demonstrations and educational visualizations, primarily using Manim's animation capabilities to create interactive and engaging mathematical content. These files can be used to generate educational videos or presentations explaining complex mathematical concepts through visual means.</directory-summary><file name="added_dimension.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim library components for animation and visualization</description>
        </external>
        <internal>
            
        </internal>
    </dependencies>
    <function-defs>
        
    </function-defs>
    <file-summary>
        This file contains several scene classes for mathematical visualizations using Manim:
        - ShowLozenge: Creates and animates a lozenge shape with angle labels and tiling
        - CubesAsHexagonTiling: Base class for 3D cube visualizations
        - AmbientTilingChanges: Animates dynamic changes in cube tiling
        - ShowAsThreeD: Demonstrates 3D perspective of cube arrangements
        - AskStripQuestion: Visualizes circular strips problem
        - SphereStrips: Creates 3D visualization of strips on a sphere
        - MongesTheorem: Demonstrates Monge's theorem with circles and spheres
        - AskAboutVolumeOfParallelpiped: Shows 3D tetrahedron visualization
        - TriangleAreaFormula: Demonstrates triangle area calculation
        - LogicForArea: Shows mathematical equations for area calculations
        - FourDDet: Displays 4D determinant formula
        - IntersectingCircles: Animates intersecting circles with radial lines

        Each class inherits from InteractiveScene or other scene classes and implements various mathematical visualizations using Manim's animation capabilities.
    </file-summary></file>
        <file name="max_rand.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim functionality for animation and scene creation</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="Randomize">
            <description>Animation class that randomizes a value tracker over time</description>
            <args>
                value_tracker: ValueTracker object
                frequency: int = 8
                rand_func: function = random.random
                final_value: float = None
                **kwargs: additional animation parameters
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Updates the value_tracker's value over time
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="TrackingDots">
            <description>Animation class that creates trailing dots following a point</description>
            <args>
                point_func: function returning point coordinates
                fade_factor: float = 0.95
                radius: float = 0.25
                color: Color = YELLOW
                **kwargs: additional animation parameters
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Creates and updates dots on screen
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_random_var_label_group">
            <description>Creates a group of objects for visualizing a random variable on an axis</description>
            <args>
                axis: Axis object
                label_name: str
                color: Color = GREY
                initial_value: float = None
                font_size: int = 36
                direction: vector = None
            </args>
            <returns>
                Group of tracker, tip, and label objects
            </returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements animations and visualizations for demonstrating properties of random variables and their maximum values. It includes several scene classes (MaxProcess, SqrtProcess, etc.) that create interactive visualizations comparing random number generation and mathematical operations. The file focuses on demonstrating the relationship between max(rand(), rand()) and sqrt(rand()).
    </file-summary></file>
      </directory>
      <directory name="transformers">
        <directory-summary>This directory contains a comprehensive collection of Manim animation scripts focused on visualizing and explaining transformer neural networks and related concepts. The key components include:

1. Core Visualization Files:
- attention.py: Demonstrates attention mechanisms and patterns
- embedding.py: Visualizes word embeddings and tokenization
- mlp.py: Shows multilayer perceptron components
- network_flow.py: Animates data flow through transformer networks

2. Generation &amp; Processing:
- auto_regression.py &amp; generation.py: Implement text generation visualizations using GPT-2/GPT-3
- almost_orthogonal.py: Demonstrates vector optimization techniques

3. Educational Content:
- ml_basics.py: Covers fundamental machine learning concepts
- supplements.py: Additional educational scenes and explanations
- chm.py: Specialized demonstrations for language model operations

4. Support Files:
- helpers.py: Utility functions and shared components
- embedding.py: Tools for working with word vectors and tokenization

The directory serves as a complete toolkit for creating educational videos about transformer architecture, with files designed to work together to produce sophisticated animations explaining various aspects of transformer neural networks. It relies heavily on the Manim animation library and includes integrations with actual transformer models (GPT-2/GPT-3) for demonstrations.

Primary use cases include creating educational content about:
- Transformer architecture and components
- Attention mechanisms
- Word embeddings and tokenization
- Neural network operations
- Language model behavior and generation</directory-summary><file name="almost_orthogonal.py"><declarations>
        <variable name="num_vectors" type="int" value="10000" />
        <variable name="vector_len" type="int" value="100" />
        <variable name="big_matrix" type="torch.Tensor" />
        <variable name="optimizer" type="torch.optim.Adam" />
        <variable name="num_steps" type="int" value="250" />
        <variable name="losses" type="list" />
        <variable name="dot_diff_cutoff" type="float" value="0.01" />
        <variable name="big_id" type="torch.Tensor" />
    </declarations>
    <dependencies>
        <external>
            <dependency>torch</dependency>
            <dependency>matplotlib.pyplot</dependency>
            <dependency>tqdm</dependency>
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
    </function-defs>
    <file-summary>
        This script implements an optimization procedure to generate a large set of nearly-orthogonal vectors. It creates a matrix of random vectors, then uses gradient descent (Adam optimizer) to adjust these vectors to be as close to orthogonal as possible while maintaining unit length. The script visualizes both the optimization process (loss curve) and the final distribution of angles between vectors. The implementation uses PyTorch for tensor operations and gradient-based optimization, with matplotlib for visualization and tqdm for progress tracking.

        The script performs the following main operations:
        1. Initializes random vectors and normalizes them
        2. Optimizes vectors to be nearly orthogonal using gradient descent
        3. Plots the loss curve during optimization
        4. Visualizes the distribution of angles between the final vectors

        The optimization process minimizes a loss function that penalizes non-orthogonal vector pairs while maintaining vector normalization.
    </file-summary></file>
        <file name="attention.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            manim_imports_ext
        </external>
        <internal>
            <filepath>_2024.transformers.helpers</filepath>
            <description>Imports helper functions for transformer visualizations</description>
            <filepath>_2024.transformers.embedding</filepath>
            <description>
                Imports functions for breaking text into words/tokens and creating visual rectangles around them:
                - break_into_words
                - break_into_tokens
                - get_piece_rectangles
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="AttentionPatterns">
            <description>
                Creates an animation demonstrating how attention patterns work in transformers, showing how words attend to each other and how embeddings are transformed
            </description>
            <args>
                self: The scene instance
            </args>
            <returns>
                
            </returns>
            <side-effects>
                Creates and plays animations showing attention mechanisms
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="bake_mobject_into_vector_entries">
            <description>
                Helper function that animates "baking" a mobject into vector entries
            </description>
            <args>
                self: The scene instance
                mob: The mobject to bake
                vector: The target vector
                path_arc: Arc of the transformation path
                group_type: Type of group for animations
            </args>
            <returns>
                AnimationGroup containing the baking animation
            </returns>
            <side-effects>
                None
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements animations demonstrating attention mechanisms in transformers. It shows how words in a sentence attend to each other, how embeddings are transformed, and visualizes attention patterns. The main class AttentionPatterns creates detailed animations showing the flow of information through attention layers.
    </file-summary></file>
        <file name="auto_regression.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            transformers.GPT2Tokenizer
            transformers.GPT2LMHeadModel
            transformers.PreTrainedModel
            torch
            openai
            tiktoken
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports Manim animation library components</description>
            <filepath>_2024.transformers.helpers</filepath>
            <description>Imports helper functions for transformer visualizations</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_gpt2_tokenizer">
            <description>Cached function to get GPT2 tokenizer instance</description>
            <args>model_name: str = 'gpt2'</args>
            <returns>GPT2Tokenizer instance</returns>
            <side-effects>Downloads model if not cached</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>Network/download errors</unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_gpt2_model">
            <description>Cached function to get GPT2 model instance</description>
            <args>model_name: str = 'gpt2'</args>
            <returns>GPT2LMHeadModel instance</returns>
            <side-effects>Downloads model if not cached</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>Network/download errors</unhandled>
            </errors-and-exceptions>
        </function>
        <function name="gpt2_predict_next_token">
            <description>Predicts next possible tokens using GPT2 model</description>
            <args>
                text: str - Input text to predict from
                n_shown: int = 7 - Number of predictions to return
            </args>
            <returns>Tuple of (tokens list, probabilities list)</returns>
            <side-effects>None</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>Model inference errors</unhandled>
            </errors-and-exceptions>
        </function>
        <function name="gpt3_predict_next_token">
            <description>Predicts next possible tokens using GPT-3 API</description>
            <args>
                text: str - Input text to predict from
                n_shown: int = 10 - Number of predictions to return
                random_seed: int = 0 - Seed for reproducibility
            </args>
            <returns>Tuple of (tokens list, probabilities list)</returns>
            <side-effects>Makes API calls to OpenAI</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>API errors, Authentication errors</unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements autoregressive text generation visualization using Manim. It contains classes for animating text prediction using both GPT-2 and GPT-3 models, with various visualization options for showing the prediction process, token distributions, and machine representations. The main class SimpleAutogregression handles the core animation logic with several specialized subclasses for different demonstration scenarios.
    </file-summary></file>
        <file name="chm.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>_2024.transformers.auto_regression</filepath>
            <description>Imports base class SimpleAutogregression for text prediction functionality</description>
            <filepath>_2024.transformers.helpers</filepath>
            <description>Imports helper functions for transformer-related operations</description>
            <filepath>_2024.transformers.embedding</filepath>
            <description>Imports embedding-related functionality</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>Main animation construction method for PredictTheNextWord class</description>
            <args>
                <arg>self - class instance</arg>
            </args>
            <returns />
            <side-effects>
                Creates and animates a visualization of a language model predicting next words
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_text_snippets">
            <description>Retrieves and randomizes text snippets from a file</description>
            <args>
                <arg>self - class instance</arg>
            </args>
            <returns>List of text snippets</returns>
            <side-effects>
                Reads from external file
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    File reading errors
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements several Manim scenes related to transformer and language model visualizations. The main classes include PredictTheNextWord, LotsOfTextIntoTheMachine, and various other scenes that demonstrate different aspects of language model operation and text processing. The scenes create animations showing how language models process text and make predictions.
    </file-summary></file>
        <file name="embedding.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            - gensim: For word vector models
            - tiktoken: For token encoding
            - numpy: For numerical computations
        </external>
        <internal>
            <filepath>
                - manim_imports_ext
                - _2024.transformers.helpers
            </filepath>
            <description>
                Imports Manim animation library components and helper functions for transformer visualizations
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_token_encoding">
            <description>
                Returns the tokenizer encoding for the davinci model
            </description>
            <args>
            </args>
            <returns>
                tiktoken encoding object for davinci model
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_principle_components">
            <description>
                Calculates principal components of input data
            </description>
            <args>
                data: Input data matrix
                n_components: Number of components to return (default 3)
            </args>
            <returns>
                Matrix of principal component vectors
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="find_nearest_words">
            <description>
                Finds nearest word vectors to a given vector
            </description>
            <args>
                model: Word vector model
                vector: Target vector
                n: Number of nearest neighbors to return (default 20)
            </args>
            <returns>
                List of nearest word strings
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_word_to_vec_model">
            <description>
                Loads or downloads a word2vec model
            </description>
            <args>
                model_name: Name of the model to load (default "glove-wiki-gigaword-50")
            </args>
            <returns>
                Loaded word vector model
            </returns>
            <side-effects>
                May download and save model file if not present locally
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains utilities and animation scenes for visualizing word embeddings and tokenization in transformers. It includes functions for loading word vector models, finding nearest neighbors, and various Manim scenes that demonstrate embedding concepts through animations.
    </file-summary></file>
        <file name="generation.py"><declarations>
        None
    </declarations>
    <dependencies>
        <external>
            - transformers.models.videomae
            - transformers.GPT2Tokenizer
            - transformers.GPT2LMHeadModel
            - transformers.PreTrainedModel
            - torch
            - openai
            - tiktoken
        </external>
        <internal>
            <filepath>
                - manim_imports_ext
                - _2024.transformers.helpers
            </filepath>
            <description>
                Imports Manim animation library and helper functions for transformer visualizations
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_gpt2_tokenizer">
            <description>
                Cached function to get GPT2 tokenizer instance
            </description>
            <args>
                model_name: str = 'gpt2'
            </args>
            <returns>
                GPT2Tokenizer instance
            </returns>
            <side-effects>
                Downloads model weights if not cached
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Network/download errors
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_gpt2_model">
            <description>
                Cached function to get GPT2 model instance
            </description>
            <args>
                model_name: str = 'gpt2'
            </args>
            <returns>
                GPT2LMHeadModel instance
            </returns>
            <side-effects>
                Downloads model weights if not cached
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Network/download errors
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="gpt2_predict_next_token">
            <description>
                Predicts next possible tokens using GPT2 model
            </description>
            <args>
                text: str
                n_shown: int = 7
            </args>
            <returns>
                Tuple of (tokens list, probabilities list)
            </returns>
            <side-effects>
                None
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Model inference errors
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="gpt3_predict_next_token">
            <description>
                Predicts next possible tokens using GPT3 model
            </description>
            <args>
                text: str
                n_shown: int = 10
                random_seed: int = 0
            </args>
            <returns>
                Tuple of (tokens list, probabilities list)
            </returns>
            <side-effects>
                Makes API calls to OpenAI
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    General exceptions from API calls
                </handled>
                <unhandled>
                    API key/auth errors
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains code for visualizing text generation using transformer models (GPT2 and GPT3). It includes several Manim scenes that demonstrate autoregressive text generation, with animations showing the prediction process and probability distributions of next tokens. The file also contains utility functions for interacting with the language models and formatting text output.
    </file-summary></file>
        <file name="helpers.py"><declarations>
        DATA_DIR = Path(get_output_dir(), "2024/transformers/data/")
        WORD_FILE = Path(DATA_DIR, "OWL3_Dictionary.txt")
    </declarations>
    <dependencies>
        <external>
            numpy
            warnings
            typing
            Path
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim animation library components</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_paragraph">
            <description>Handles word wrapping to create a formatted text block</description>
            <args>
                words: list of strings
                line_len: int = 40 (max line length)
                font_size: int = 48
            </args>
            <returns>Text object with wrapped text</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>

        <function name="softmax">
            <description>Implements softmax function with temperature scaling and numerical stability</description>
            <args>
                logits: array-like
                temperature: float = 1.0
            </args>
            <returns>Normalized probability distribution array</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled>Warnings for numerical operations</handled>
                <unhandled />
            </errors-and-exceptions>
        </function>

        <function name="value_to_color">
            <description>Maps numeric values to colors on a gradient scale</description>
            <args>
                value: float
                low_positive_color: Color = BLUE_E
                high_positive_color: Color = BLUE_B
                low_negative_color: Color = RED_E
                high_negative_color: Color = RED_B
                min_value: float = 0.0
                max_value: float = 10.0
            </args>
            <returns>Color object</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>

        <function name="read_in_book">
            <description>Reads text content from a file</description>
            <args>name: str = "tale_of_two_cities"</args>
            <returns>String content of the text file</returns>
            <side-effects>File I/O</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>FileNotFoundError</unhandled>
            </errors-and-exceptions>
        </function>

        <function name="load_image_net_data">
            <description>Loads and processes ImageNet dataset</description>
            <args>dataset_name: str = "image_net_1k"</args>
            <returns>List of tuples containing image paths and labels</returns>
            <side-effects>File I/O, Directory creation</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>FileNotFoundError, IOError</unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        A helper module for transformer visualization containing utility functions for text processing, data loading, color mapping, and various animation-related classes and functions. Includes implementations for neural network visualization, matrix operations, and custom animation components.
    </file-summary></file>
        <file name="ml_basics.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
            <filepath>manim_imports_ext</filepath>
            <description>Imports all manim functionality</description>
        </external>
        <internal>
            <filepath>_2024.transformers.helpers</filepath>
            <description>Imports helper functions for transformer visualizations</description>
            <filepath>_2024.transformers.embedding</filepath>
            <description>Imports embedding-related functionality</description>
            <filepath>_2024.transformers.generation</filepath>
            <description>Imports generation-related functionality</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>Scene construction method for DialTest class that demonstrates dial animations</description>
            <args>
                <arg>self: Scene instance</arg>
            </args>
            <returns />
            <side-effects>
                <effect>Creates and animates visual elements on screen</effect>
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_titled_box">
            <description>Creates a titled box with specified parameters</description>
            <args>
                <arg>self: Scene instance</arg>
                <arg>text: String for box title</arg>
                <arg>color: Color for box</arg>
                <arg>font_size: Size of font</arg>
                <arg>y_space: Vertical spacing</arg>
                <arg>x_space: Horizontal spacing</arg>
                <arg>opacity: Box opacity</arg>
            </args>
            <returns>VGroup containing box and title</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_regression_drawing">
            <description>Creates a visualization of regression with dots and line</description>
            <args>
                <arg>self: Scene instance</arg>
            </args>
            <returns>VGroup containing axes, dots, and line</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_bayes_net_drawing">
            <description>Creates a visualization of a Bayesian network</description>
            <args>
                <arg>self: Scene instance</arg>
            </args>
            <returns>VGroup containing nodes and edges of network</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains Manim scene classes for visualizing machine learning concepts. It includes DialTest, MLWithinDeepL, ShowCross, FlashThroughImageData, FlashThroughTextData2, TweakedMachine, PremiseOfML, LinearRegression, ShowGPT3Numbers, SoftmaxBreakdown, and CostFunction classes. Each class creates animations to demonstrate different aspects of machine learning, from basic concepts to specific algorithms like softmax and cost functions.
    </file-summary></file>
        <file name="mlp.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            torch
            scipy.stats.norm
        </external>
        <internal>
            <filepath>_2024.transformers.helpers</filepath>
            <description>Imports helper functions for transformer visualizations</description>
            <filepath>manim_imports_ext</filepath>
            <description>Imports extended manim functionality</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>Main animation sequence showing transformer architecture with focus on MLP blocks</description>
            <args>self</args>
            <returns />
            <side-effects>
                Creates and animates various visual elements on screen
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_thumbnails">
            <description>Creates thumbnail images for chapters 5 and 6</description>
            <args>self</args>
            <returns>Group of thumbnail images with surrounding rectangles</returns>
            <side-effects>
                Loads external image files
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Potential file not found errors when loading images
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_att_icon">
            <description>Creates attention visualization icon with dots</description>
            <args>
                self
                block: Block to place icon on
                n_rows: Number of rows in dot grid (default=8)
            </args>
            <returns>Grid of dots with random opacity</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_mlp_icon">
            <description>Creates MLP visualization icon with connected layers</description>
            <args>
                self
                block: Block to place icon on
                dot_buff: Buffer between dots
                layer_buff: Buffer between layers
                layer0_size: Size of first layer
            </args>
            <returns>Visual representation of MLP layers with connections</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_block">
            <description>Creates a 3D block for visualization</description>
            <args>
                self
                width: Block width (default=5)
                height: Block height (default=3)
                depth: Block depth (default=1)
                color: Block color (default=GREY_D)
                opacity: Block opacity (default=0.8)
            </args>
            <returns>3D cube with specified properties</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains manim animations for explaining transformer architecture, with particular focus on MLP blocks. It includes several scene classes that create various visualizations of neural network components, including attention mechanisms and MLPs. The main class LastTwoChapters creates an elaborate animation sequence showing the relationship between different transformer components.
    </file-summary></file>
        <file name="network_flow.py"><declarations>
        
        use_words = False
        hide_block_labels = False
        block_to_title_direction = UP
        example_text = "It is said that which does not kill you only makes you stronger"
        possible_next_tokens = [list of tuples with tokens and probabilities]
    </declarations>
    <dependencies>
        <external>
            torch
        </external>
        <internal>
            <filepath>
                manim_imports_ext
                _2024.transformers.helpers
                _2024.transformers.embedding
            </filepath>
            <description>
                Imports manim-specific utilities and custom transformer-related helper functions and embedding components
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="setup">
            <description>
                Initializes the scene setup with floor plane and camera settings
            </description>
            <args>
                self
            </args>
            <returns>
            </returns>
            <side-effects>
                Sets up scene properties including camera position and initializes empty groups
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="construct">
            <description>
                Main animation sequence for showing network flow
            </description>
            <args>
                self
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and animates various visual elements showing network flow
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_embedding_array">
            <description>
                Creates an embedding array with specified parameters
            </description>
            <args>
                self, shape=(9, 10), height=4, dots_index=-4, buff_ratio=0.4, bracket_color=GREY_B, backstroke_width=3, add_background_rectangle=False
            </args>
            <returns>
                EmbeddingArray object
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements a Manim animation scene showing the flow of data through a transformer network. It includes visualizations of embedding layers, attention blocks, and MLP layers. The code creates various visual elements and animations to demonstrate how text is processed through the network, including attention mechanisms and feed-forward operations.
    </file-summary></file>
        <file name="supplements.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports core Manim functionality and extensions</description>
            <filepath>_2024.transformers.helpers</filepath>
            <description>Helper functions for transformer visualizations</description>
            <filepath>_2024.transformers.embedding</filepath>
            <description>Embedding-related visualization components</description>
        </internal>
    </dependencies>
    <function-defs>
        
    </function-defs>
    <file-summary>
        This file contains supplementary scene classes for a video series about transformers. It includes various scenes that:
        1. Introduce key concepts like GPT (Generative Pre-trained Transformer)
        2. Demonstrate attention mechanisms and MLPs
        3. Show interactive explanations with teacher-student dialogues
        4. Visualize neural network components and transformations
        5. Present technical concepts with animations and visual aids
        
        The scenes use Manim's animation framework to create educational visualizations about transformer architecture and deep learning concepts. Most scenes inherit from either InteractiveScene or TeacherStudentsScene base classes.
    </file-summary></file>
      </directory>
    </directory>
    <directory name="outside_videos">
      <directory-summary>This directory contains a collection of Manim animation scripts used for creating various mathematical and educational video content, likely for the 3Blue1Brown YouTube channel and other platforms. The files can be grouped into several categories:

1. Mathematical Visualizations:
- analysis.py - Complex mathematical visualizations (exponential functions, zeta functions)
- geometry.py - Geometric animations and transformations
- probability.py - Probability and statistics visualizations
- patterns.py - Mathematical pattern demonstrations (Pascal's triangle, triominoes)

2. Educational Content:
- for_site.py - Website/presentation content animations
- qa_examples.py - Interactive demonstration scenes
- talk_scenes.py - Scenes designed for mathematical presentations
- grover.py - Quantum computing visualizations

3. Branding and Social Media:
- banners.py - Channel banner animations
- podcast.py - Podcast-related animations
- short_links.py - Animations for video shorts/links
- merch_designs.py - Merchandise-related animations

4. Complex Demonstrations:
- mug_to_torus.py - Topological transformation animations
- name_animation.py - Text-based animations with mathematical transformations

5. Social Media Content (/tweets subdirectory):
- Collection of shorter animations designed for Twitter/social media platforms
- Includes puzzles, mathematical demonstrations, and artistic visualizations

The directory serves as a repository of animation scripts that can be rendered using the Manim animation engine to create educational mathematical content. Each file is generally self-contained and focuses on specific mathematical concepts or visual effects. The code relies heavily on the manim_imports_ext module and demonstrates various animation techniques, from simple 2D animations to complex 3D transformations.</directory-summary><file name="aeoud.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports all manim components through the wildcard import</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>Creates a Venn diagram visualization with two circles, labels, and geometric elements to demonstrate a proportion</description>
            <args>self - the scene instance</args>
            <returns />
            <side-effects>
                Adds visual elements to the scene
                Animates various elements
                Modifies scene state
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="construct">
            <description>Creates a 3D visualization with two spheres and a spherical cap</description>
            <args>self - the scene instance</args>
            <returns />
            <side-effects>
                Adds 3D objects to the scene
                Sets camera orientation
                Configures sphere properties and meshes
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains two Manim scene classes: VennDiagram and Spheres. The VennDiagram class creates an animated visualization showing two intersecting circles with labels and geometric elements to demonstrate a proportion of 1/3. The Spheres class creates a 3D visualization with two spheres and a spherical cap, including mesh visualizations and camera positioning.
    </file-summary></file>
      <file name="analysis.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            math
            itertools (imported as it)
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim core functionality</description>
            <filepath>_2016.zeta</filepath>
            <description>Imports zeta function implementation used in visualization</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="approx_exp">
            <description>Approximates exponential function using Taylor series expansion</description>
            <args>
                x: complex number or float - input value
                n: int - number of terms in Taylor series
            </args>
            <returns>float or complex - approximated exponential value</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Potential overflow for large x or n values
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains several Manim scene classes for mathematical visualizations:
        - ExpPlay: Visualizes exponential function approximation using vectors
        - ZetaSum: Visualizes zeta function summation in complex plane
        - ZetaSpiral: Creates spiral visualization of zeta function
        - SumRotVectors: Demonstrates sum of rotating vectors
        - Spirals: Creates spiral visualizations based on complex parameters
        
        The file focuses on mathematical animations, particularly around exponential and zeta functions, using Manim's animation framework. Each scene class implements specific visualization techniques with interactive elements and parametric curves.
    </file-summary></file>
      <file name="banners.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>
                Imports all manim components through the wildcard import (*)
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_pis">
            <description>
                Creates and returns a group of modified Randolph (pi) characters with specific styling and positioning
            </description>
            <args>
                
            </args>
            <returns>
                Returns a VGroup containing four modified Randolph characters
            </returns>
            <side-effects>
                
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    
                </handled>
                <unhandled>
                    
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines two banner classes for Manim animations: CleanBanner and ShortsBanner. CleanBanner is a simple banner with an empty message, while ShortsBanner is more complex, featuring "3b1b shorts" as its message and including a method to create and customize a group of Randolph (pi) characters with specific visual modifications and positioning.
    </file-summary></file>
      <file name="for_site.py"><declarations>
    </declarations>
    <dependencies>
        <external>
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>
                Imports all manim-related dependencies needed for scene creation and animation
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Multiple scene classes (WhyPi, GeneralExpositionIcon, GeometryIcon, PhysicsIcon, SupportIcon, SupportPitch1-4, RantPage, ClipsLogo) each containing a construct method that sets up visual elements for different scenes
            </description>
            <args>
                self - the scene instance
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and positions visual elements in the scene
                Adds elements to the scene for rendering
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    Potential file not found errors for image loading in GeometryIcon and PhysicsIcon
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains multiple Scene classes used to create various visual elements for what appears to be a website or presentation. It includes scenes for mathematical formulas (WhyPi), general exposition, geometry, physics, and support-related content. Each scene is defined as a class inheriting from Scene with a construct method that sets up the visual elements. The file makes heavy use of manim's animation and visualization capabilities to create mathematical and educational content.
    </file-summary></file>
      <file name="geometry.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports all manim-related functionality needed for the geometric animations</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>Main animation construction method for FakeAreaManipulation scene</description>
            <args>self - Scene instance</args>
            <returns />
            <side-effects>Creates and plays animations in the scene</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_diagrams">
            <description>Creates geometric diagrams used in the FakeAreaManipulation scene</description>
            <args>self - Scene instance</args>
            <returns>Two VGroups containing geometric shapes</returns>
            <side-effects>None</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="construct">
            <description>Main animation construction method for LogarithmicSpiral scene</description>
            <args>self - Scene instance</args>
            <returns />
            <side-effects>Creates and plays spiral animation in the scene</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_group">
            <description>Generates geometric groups for the logarithmic spiral</description>
            <args>
                self - Scene instance
                n - Integer for number of divisions
                n_spirals - Integer for number of spiral iterations (default=50)
            </args>
            <returns>VGroup containing lines and spiral VMobject</returns>
            <side-effects>None</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains two Manim scenes: FakeAreaManipulation and LogarithmicSpiral. FakeAreaManipulation creates an animation involving geometric shapes that transform and manipulate areas, with zooming capabilities. LogarithmicSpiral generates an animated logarithmic spiral with adjustable parameters. Both scenes use Manim's animation framework to create mathematical visualizations.
    </file-summary></file>
      <file name="gifs.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            <dependency>numpy (via manim_imports_ext)</dependency>
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>
                Imports all manim components through the project's consolidated import system
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Defines animation sequence for HyperSlinky scene, creating a slinky-like transformation of a number plane
            </description>
            <args>
                self - Scene instance
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and plays an animation in the scene
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="construct">
            <description>
                Defines animation sequence for CircleAtaphogy scene, creating a repeating circle animation
            </description>
            <args>
                self - Scene instance
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and plays an animation in the scene
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines two animation scenes using the Manim library:
        1. HyperSlinky: Creates a complex transformation of a number plane using pointwise functions to create a slinky-like effect
        2. CircleAtaphogy: Animates a circle with a repeating effect
        Both scenes are meant to create GIF-like animations for visualization purposes.
    </file-summary></file>
      <file name="grover.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            <dependency>manim_imports_ext</dependency>
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Creates a visualization of a qubit state on a 2D plane with axes and interactive elements
            </description>
            <args>
                <arg>self</arg>
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and animates visual elements on the scene
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_prob_label">
            <description>
                Creates a probability label for quantum measurements
            </description>
            <args>
                <arg>self</arg>
                <arg>coef - coefficient value</arg>
                <arg>bit - bit value (defaults to "0")</arg>
            </args>
            <returns>
                Returns a Tex object containing the probability label
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains Manim animations for quantum computing visualizations. It includes two main classes:
        1. QBitDiagram - Visualizes a qubit state on a 2D plane with interactive elements
        2. BlocksToQuantum - Creates an animation showing the transition from classical blocks to quantum states
        
        The animations demonstrate quantum superposition, state vectors, and probability measurements in an interactive and visual way.
    </file-summary></file>
      <file name="merch_designs.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            numpy (imported via manim_imports_ext)
        </external>
        <internal>
            <filepath>
                manim_imports_ext
                manimlib.once_useful_constructs.fractals
            </filepath>
            <description>
                Imports manim-specific classes and utilities, including fractal-related constructs used for creating visual animations
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Creates and displays fractal curves with different orders and stroke widths
            </description>
            <args>
                self
            </args>
            <returns>
            </returns>
            <side-effects>
                Adds visual elements to the scene
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="approx_square_wave">
            <description>
                Approximates a square wave using Fourier series
            </description>
            <args>
                self
                x: float - x coordinate
                L: float - period length
                n_terms: int - number of terms in the Fourier series (default=3)
            </args>
            <returns>
                float - approximated square wave value at point x
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains several Manim scene classes for creating mathematical visualizations, primarily focused on fractals and mathematical patterns. It includes implementations for Hilbert curves, Flow snakes, Sierpinski triangles, square waves, and pendulum phase space visualizations. Each class is designed to create specific mathematical animations or visualizations that could be used for merchandise designs.
    </file-summary></file>
      <file name="misc_thumbnails.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            <dependency>numpy (as np)</dependency>
            <dependency>sympy</dependency>
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports all manim-related classes and utilities needed for scene creation</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="pendulum_vector_field_func">
            <description>Calculates the vector field for a pendulum system</description>
            <args>
                theta: float - angle
                omega: float - angular velocity
                mu: float = 0.3 - damping coefficient
                g: float = 9.8 - gravitational acceleration
                L: float = 3 - pendulum length
            </args>
            <returns>List of two floats representing the vector field components</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains various Scene classes used to create thumbnails for different mathematical concepts:
        - LinalgThumbnail: Creates a 3D scene with transformed cubes for linear algebra
        - CSThumbnail: Generates a background of random 0s and 1s
        - GroupThumbnail: Creates a 3D scene with multiple rotated cubes
        - BaselThumbnail: Visualizes the Basel problem with lighthouses around a lake
        - Eola1Thumbnail: Creates a vector visualization with coordinate system
        - ODEThumbnail: Generates a vector field visualization for a pendulum system
        - PrimeSpirals: Creates a visualization of prime numbers in a spiral pattern
        - EGraph: Creates a visualization of the exponential function and the number e
    </file-summary></file>
      <file name="mug_to_torus.py"><declarations>
        <variable>R1, R2 = (2, 0.75)</variable>
    </declarations>
    <dependencies>
        <external>
            <dependency>math</dependency>
            <dependency>numpy (as np)</dependency>
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>
                Imports manim-specific classes and utilities needed for 3D animation creation
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="torus_func">
            <description>
                Parametric function that defines the shape of a torus in 3D space
            </description>
            <args>
                u: float - angular parameter
                v: float - angular parameter
            </args>
            <returns>
                numpy.ndarray - 3D coordinates of a point on the torus
            </returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="cylinder_func">
            <description>
                Parametric function that defines the shape of a cylinder in 3D space
            </description>
            <args>
                u: float - height parameter
                v: float - angular parameter
            </args>
            <returns>
                tuple - 3D coordinates (x, y, z) of a point on the cylinder
            </returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="construct">
            <description>
                Main animation method that creates and animates the transformation of a mug (cylinder with disks) into a torus
            </description>
            <args>
                self - ThreeDScene instance
            </args>
            <returns />
            <side-effects>
                Creates and plays animations in the scene
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines a Manim animation class MugToTorus that demonstrates the topological equivalence between a coffee mug and a torus through a smooth transformation. It creates a 3D animation showing how a cylinder with two disks (representing a mug) can be continuously deformed into a torus shape.
    </file-summary></file>
      <file name="name_animation.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            numpy (implied through manim)
        </external>
        <internal>
            <filepath>
                manim_imports_ext
                _2019.diffyq.part2.fourier_series
                _2017.eoc.div_curl
            </filepath>
            <description>
                Imports manim core functionality and specific components for Fourier series transformations and vector field animations
            </description>
        </internal>
    </dependencies>
    <function-defs>
        
    </function-defs>
    <file-summary>
        This file contains several animation classes for rendering name-based animations in Manim:
        - ComplexMorphingNames: Creates complex transformations of text
        - FlowNameAnimation: Animates names using vector fields and flow
        - NameAnimationScene: Base class for name animations with configuration options
        - RotatingNameLetters: Creates rotating letter animations around a circle
        - ModularMultiplicationNameAnimation: Creates modular multiplication visualizations with text
        - FourierNameAnimation: Applies Fourier transformations to names
        - QuaternionNameAnimation: Creates 3D quaternion-based name animations

        The file appears to be part of a larger project for creating mathematical animations, specifically focused on name-based animations using various mathematical transformations.
    </file-summary></file>
      <file name="patterns.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim core functionality and extensions</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>Main animation construction method for PascalColored scene</description>
            <args>self</args>
            <returns />
            <side-effects>
                Creates and animates a colored Pascal's triangle visualization
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_pascal_point">
            <description>Calculates position for a point in Pascal's triangle</description>
            <args>
                self, n (int): row number, k (int): position in row
            </args>
            <returns>Vector position for the point</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_dot_layer">
            <description>Creates a layer of dots for Pascal's triangle</description>
            <args>
                self, n (int): layer number
            </args>
            <returns>VGroup of dots representing a layer</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_dots">
            <description>Creates all layers of dots for Pascal's triangle</description>
            <args>
                self, n_layers (int): number of layers to create
            </args>
            <returns>VGroup containing all dot layers</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="cover_grid">
            <description>Recursive function to cover a grid with triominoes</description>
            <args>
                self, grid: grid to be covered
            </args>
            <returns />
            <side-effects>
                Modifies self.triominos by adding new triominoes
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains two Manim scenes: PascalColored and TriominoGrid. PascalColored creates an animated visualization of Pascal's triangle with colored dots based on modular arithmetic. TriominoGrid demonstrates a recursive algorithm for covering a 2^n × 2^n grid with L-shaped triominoes, leaving one square uncovered.
    </file-summary></file>
      <file name="podcast.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            <dependency>manim_imports_ext</dependency>
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Creates an animation of a radio tower with expanding circular waves
            </description>
            <args>
                <arg>self - The Scene instance</arg>
            </args>
            <returns>
            </returns>
            <side-effects>
                <effect>Creates and plays animations in the scene</effect>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_radio_tower">
            <description>
                Creates a visual representation of a radio tower using lines and dots
            </description>
            <args>
                <arg>self - The Scene instance</arg>
            </args>
            <returns>
                <return>VGroup containing the tower base and dot</return>
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_circle">
            <description>
                Creates a circle made of two arcs with different colors
            </description>
            <args>
                <arg>self - The Scene instance</arg>
                <arg>center - Point for circle center (default: ORIGIN)</arg>
                <arg>radius - Circle radius (default: 1)</arg>
            </args>
            <returns>
                <return>VGroup containing two colored arcs forming a circle</return>
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines a PodcastIntro scene class that creates an animation of a radio tower with expanding circular waves. It includes methods to generate the tower structure and circles for the wave effect. The animation shows the tower being created followed by expanding rings emanating from it.
    </file-summary></file>
      <file name="probability.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports all (*) from manim_imports_ext, which appears to be a manim-specific import file containing necessary animation components</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>Creates an animation that demonstrates stacking bars to form a bell curve shape through iterative transformations</description>
            <args>self - The Scene instance</args>
            <returns />
            <side-effects>
                Creates and manipulates visual elements on the scene
                Plays animations that modify the state of the scene
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Potential index out of range errors when accessing bars array
                    Potential overflow errors when scaling/stretching objects
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines a Manim Scene class called StacksApproachBellCurve that creates an animation demonstrating how stacking bars in a specific pattern can approximate a bell curve distribution. The animation involves creating, copying, moving, and stacking bars with color gradients, while maintaining size constraints within the frame. The process is repeated for a configured number of iterations (default 70) to build up the curve shape.
    </file-summary></file>
      <file name="qa_examples.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>
                Imports all manim components through the standard manim imports extension
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Main construction method for the DemoScene class that creates and animates a grid-based visualization with interactive square flipping
            </description>
            <args>
                <arg>self - reference to the DemoScene instance</arg>
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and manipulates visual elements on the scene
                Plays animations
                Modifies scene state
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="flip">
            <description>
                Helper function that creates an animation to flip a square and toggle its color between blue and grey
            </description>
            <args>
                <arg>square - Square object to be flipped and recolored</arg>
            </args>
            <returns>
                Animation object for flipping and recoloring the square
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains a demo scene class (DemoScene) that inherits from InteractiveScene. It creates an interactive visualization featuring a grid of squares that can be flipped and recolored through animations. The scene includes numbered labels and demonstrates various animation techniques including sequential highlighting and transformation of grid elements. It concludes with a PiCreature animation.
    </file-summary></file>
      <file name="short_links.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            <dependency>os</dependency>
            <dependency>random</dependency>
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim core functionality and extensions</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_vertical_screen">
            <description>Creates and returns a centered rectangular screen with specific dimensions</description>
            <args>
                
            </args>
            <returns>Rectangle object with specific width/height ratio centered on screen</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains animations for displaying comments and interactions in video shorts. It includes several classes:
        - CommentFlurry and its subclasses: Handle displaying random PNG images from specific folders
        - PiLookingAtPhone: Animates a character looking at a phone with various expressions
        - ThisIsALink: Creates an animation highlighting a link with a yellow rectangle
        - LinkHighlightOverlay: Creates a flashing highlight effect for links
        
        The file is primarily focused on creating visual elements for educational videos, specifically around highlighting and displaying links and comments.
    </file-summary></file>
      <file name="talk_scenes.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim-specific components and utilities needed for scene creation</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>Main scene construction method that appears in multiple classes to set up visual elements</description>
            <args>self</args>
            <returns />
            <side-effects>Creates and animates visual elements on the scene</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_block">
            <description>Creates a grid of checkmarks or X marks based on probability</description>
            <args>
                self
                prob: float - probability for generating checkmarks
            </args>
            <returns>VGroup of marks arranged in a grid</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_mark">
            <description>Creates either a checkmark or X mark based on random probability</description>
            <args>
                self
                prob: float - probability threshold for checkmark vs X
            </args>
            <returns>Tex object of either checkmark or X</returns>
            <side-effects>Uses random number generation</side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_pi_chart">
            <description>Creates a circular chart divided into n equal sectors</description>
            <args>
                self
                n: int - number of sectors to create
            </args>
            <returns>VGroup of Sector objects</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file contains several Scene classes for mathematical presentations:
        - DoingMathVsHowMathIsPresented: Compares presentation vs actual math practice
        - PiCharts: Demonstrates fraction addition using pie charts
        - AskAboutCircleProportion: Shows circle proportion visualization
        - BorweinIntegrals: Displays a sequence of increasingly complex integrals
        Each scene is designed to illustrate mathematical concepts through visual animations.
    </file-summary></file>
      <directory name="tweets">
        <directory-summary>This directory contains a collection of Manim animation scripts that were likely created for Twitter/social media content. Each file creates a specific mathematical or visual demonstration:

1. addition_anagram.py - Demonstrates the numerical equivalence of "twelve + one" and "eleven + two" using text and dot animations
2. door_puzzle.py - Visualizes the classic 100-doors puzzle using a 10x10 grid of animated squares
3. image_manipulation.py - Shows image transformation effects using modulo 256 operations on a lion image (marked as "broken but fixable")
4. powers_of_two.py - Creates a visual demonstration of powers of 2 from 2^0 to 2^22 using dot patterns and labels
5. starry_night.py - Generates an artistic 3D starfield animation using stereographic projections and transformations
6. sudanese_band.py - Creates complex mathematical visualizations of Sudanese bands and Möbius strips in 3D space

The files in this directory are standalone Manim scenes that can be rendered individually to create educational or visually engaging mathematical content. They primarily rely on the manim_imports_ext module and create self-contained animations suitable for short-form video content.</directory-summary><file name="addition_anagram.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
            manim_imports_ext
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Creates an animation demonstrating an anagram between "twelve + one" and "eleven + two" with dots representing the numbers
            </description>
            <args>
                self - The Scene instance
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and displays animations on the scene
                Modifies the scene state through self.add() and self.play()
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines a Manim Scene class called AdditionAnagram that creates an animation showing the relationship between "twelve + one" and "eleven + two". It visualizes these expressions using text and dots above each number, demonstrating that both expressions represent the same quantity (13) through an animated transformation between the two representations.
    </file-summary></file>
        <file name="door_puzzle.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>
                Imports all (*) from manim_imports_ext, which provides the core Manim animation functionality used throughout the file
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Creates and animates a visual demonstration of the door puzzle, where squares in a 10x10 grid are toggled based on multiples
            </description>
            <args>
                self - The InteractiveScene instance
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and manipulates visual elements on the scene
                Animates the squares changing colors
                Controls animation timing
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    Potential index errors if squares array access goes out of bounds
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements a visualization of the classic door puzzle using Manim. It creates a 10x10 grid of squares, numbered 1-100, and animates a process where squares are toggled (filled/unfilled) based on their factors. The animation speed adjusts based on the current iteration number, and each square tracks how many times it has been toggled through the n_hits property.
    </file-summary></file>
        <file name="image_manipulation.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            <dependency>PIL.Image</dependency>
            <dependency>numpy</dependency>
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>
                Imports manim-specific classes and utilities needed for scene creation and animation
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Creates an animation that manipulates an image of a lion by applying modulo 256 operations with increasing multipliers
            </description>
            <args>
                <arg>self - The Scene instance</arg>
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and manipulates visual elements on the scene
                Performs image processing operations
                Controls animation timing and display
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    Potential image loading failures
                    Potential memory issues with large images
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines a Manim Scene class called ImagesMod256 that creates an animation demonstrating image manipulation using modulo 256 operations. The animation shows a lion image being transformed by applying different multipliers and taking modulo 256 of each pixel value. The scene includes a mathematical expression at the top showing the current multiplier being applied. The file is marked as "Broken, but fixable" in the comments.
    </file-summary></file>
        <file name="powers_of_two.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            
            manim_imports_ext
        </external>
        <internal>
        </internal>
    </dependencies>
    <function-defs>
        <function name="construct">
            <description>
                Main animation construction method that creates a visualization of powers of two using dots and labels
            </description>
            <args>
                self - class instance
            </args>
            <returns>
            </returns>
            <side-effects>
                Creates and plays animations in the scene
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_label">
            <description>
                Creates a label showing 2^n = result for a given power n
            </description>
            <args>
                self - class instance
                n - integer representing the power of 2
            </args>
            <returns>
                VGroup containing the formatted label
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_dots">
            <description>
                Creates a visual representation of 2^n using dots arranged in a grid
            </description>
            <args>
                self - class instance
                n - integer representing the power
                height - optional height parameter (default=6)
            </args>
            <returns>
                Group of DotCloud objects arranged in a specific pattern
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="get_marginal_dots">
            <description>
                Creates a DotCloud object with dots arranged in a grid based on the power n
            </description>
            <args>
                self - class instance
                n - integer representing the power
            </args>
            <returns>
                DotCloud object with dots arranged in a grid
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines a Manim Scene class PowersOfTwo that creates an animation demonstrating powers of two. It visualizes the exponential growth of powers of two using both numerical labels and dot patterns. The animation shows the transition from 2^0 up to 2^22, with dots arranged in grids that grow according to the power, and uses color coding to distinguish different powers.
    </file-summary></file>
        <file name="starry_night.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            <dependency>numpy</dependency>
            <dependency>random</dependency>
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>
                Imports all manim-related dependencies using wildcard import
            </description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="stereo_project_point">
            <description>
                Performs stereographic projection of a point with normalization
            </description>
            <args>
                point: ndarray - Point coordinates
                axis: int - Projection axis (default=0)
                r: float - Radius parameter (default=1)
                max_norm: float - Maximum norm threshold (default=10000)
            </args>
            <returns>
                ndarray - Projected point coordinates
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                    Potential division by zero if point[axis] + r equals 0
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file defines a Manim animation scene called StarryStarryNight that creates a 3D starfield effect. 
        It generates a cloud of random points and applies various transformations including stereographic projection, 
        complex functions, and rotations to create an artistic visualization. The scene includes camera movement 
        and various animations that transform the point cloud in different ways over time.
    </file-summary></file>
        <file name="sudanese_band.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            <dependency>math</dependency>
            <dependency>numpy (as np)</dependency>
        </external>
        <internal>
            <filepath>manim_imports_ext</filepath>
            <description>Imports manim-specific utilities and classes for animation and visualization</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="stereo_project_point">
            <description>Projects a point using stereographic projection</description>
            <args>
                point: array-like
                axis: int = 0
                r: float = 1
                max_norm: float = 10000
            </args>
            <returns>numpy array representing projected point</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="sudanese_band_func">
            <description>Generates points for a Sudanese band surface using complex numbers</description>
            <args>
                eta: float
                phi: float
            </args>
            <returns>3D point coordinates for the Sudanese band</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="mobius_strip_func">
            <description>Generates points for a Möbius strip surface</description>
            <args>
                u: float
                phi: float
            </args>
            <returns>3D point coordinates for the Möbius strip</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="reversed_band">
            <description>Creates a reversed version of a band function</description>
            <args>band_func: function</args>
            <returns>function that reverses the phi parameter of the input function</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_full_surface">
            <description>Creates a complete surface with meshes and boundaries</description>
            <args>
                band_func: function
                x_range: tuple
            </args>
            <returns>Group of surface, meshes, and boundary elements</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
        <function name="get_sudanese_band">
            <description>Creates a Sudanese band with optional orientation adjustment</description>
            <args>circle_on_xy_plane: bool = False</args>
            <returns>Group containing the Sudanese band surface and related elements</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled />
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements visualization of mathematical surfaces, specifically a Sudanese band and a Möbius strip, using manim. It includes two scene classes (SudaneseBand and SudaneseBandToKleinBottle) that create animations showing these surfaces and their transformations. The file contains various helper functions for generating points and surfaces in 3D space.
    </file-summary></file>
      </directory>
    </directory>
    <file name="stage_scenes.py"><declarations>
    </declarations>
    <dependencies>
        <external>
            inspect
            os
            sys
            importlib
        </external>
        <internal>
            <filepath>manimlib.config</filepath>
            <description>Imports get_module function for loading Python modules</description>
            <filepath>manimlib.extract_scene</filepath>
            <description>Imports is_child_scene function for scene class validation</description>
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_sorted_scene_classes">
            <description>Retrieves and sorts scene classes from a given module, either using a predefined order or by their definition order in the file</description>
            <args>module_name: str - Name of the module to extract scene classes from</args>
            <returns>List of sorted scene classes</returns>
            <side-effects />
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    Module import failures
                    Attribute access errors
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="stage_scenes">
            <description>Creates symbolic links to animation files in a staged directory, organizing them in sequential order</description>
            <args>module_name: str - Name of the module containing scene classes</args>
            <returns />
            <side-effects>
                Creates new directory for staged scenes
                Creates symbolic links to animation files
                Prints message if no animations are found
            </side-effects>
            <errors-and-exceptions>
                <handled />
                <unhandled>
                    File system operation errors (directory creation, symlink creation)
                    Permission errors
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This script is part of the Manim animation engine, responsible for organizing and staging animation scenes. It provides functionality to sort scene classes from a module and create an organized directory structure with symbolic links to animation files. The script includes a hardcoded animation directory path and is typically run from the command line with a module name argument.
    </file-summary></file>
    <directory name="sublime_custom_commands">
      <directory-summary>This directory contains Sublime Text integration files for the Manim animation engine, providing a suite of custom commands to enhance the development workflow. The directory consists of:

1. Multiple `.sublime-commands` configuration files that define custom commands accessible through Sublime Text's command palette:
   - Commands for checkpoint management (paste, recorded, and skipped variations)
   - Scene running capabilities
   - Manim scene exit functionality
   - Directory navigation tools

2. A Python implementation file (`manim_plugins.py`) that contains the core functionality for these commands, including:
   - Terminal interaction through Terminus
   - Scene detection and execution
   - Clipboard management
   - Utility functions for command generation and terminal handling

These files are designed to be used together to provide a seamless development experience when creating Manim animations within Sublime Text. Users can execute common Manim operations directly from the editor, such as running scenes, managing checkpoints, and controlling the animation workflow, without needing to switch constantly between the editor and terminal.

To use these features, users should have Sublime Text installed with the Terminus package, and the files should be properly installed in their Sublime Text packages directory.</directory-summary><file name="ManimCheckpointPaste.sublime-commands"><file-summary>This is a Sublime Text command configuration file in JSON format that defines a single custom command. The command is named "manim_checkpoint_paste" and is displayed in Sublime Text's command palette as "ManimCheckpointPaste: Copy selection, run `checkpoint_paste` in terminal". This command appears to be part of a Manim development workflow, allowing users to copy selected text and execute a checkpoint_paste command in the terminal.</file-summary></file>
      <file name="ManimExit.sublime-commands"><file-summary>This is a Sublime Text commands configuration file in JSON format that defines a single command. The file contains a command definition for "ManimExit" which allows users to exit a Manim scene. The command is named "manim_exit" and has a user-friendly caption "ManimExit: Exit manim scene" that appears in Sublime Text's command palette.</file-summary></file>
      <file name="ManimRecordedCheckpointPaste.sublime-commands"><file-summary>This is a Sublime Text commands configuration file in JSON format. It defines a single custom command for Manim that allows copying a selection and running the `checkpoint_paste(record=True)` function in the terminal. The command is named "manim_recorded_checkpoint_paste" and has a descriptive caption explaining its functionality.</file-summary></file>
      <file name="ManimRunScene.sublime-commands"><file-summary>This is a Sublime Text commands configuration file in JSON format. It defines a single command for running highlighted Manim scenes within Sublime Text. The file contains a JSON array with one object that specifies:
        1. A caption that will appear in Sublime Text's command palette: "ManimRunScene: Run highlighted manim scene"
        2. A command identifier: "manim_run_scene"
        This command configuration allows users to execute Manim scenes directly from the Sublime Text editor interface.</file-summary></file>
      <file name="ManimSkippedCheckpointPaste.sublime-commands"><file-summary>This is a Sublime Text commands configuration file in JSON format. It defines a single custom command for Manim development. The command is named "manim_skipped_checkpoint_paste" and is associated with a caption that describes its functionality: copying the selected text and running the checkpoint_paste function with skip=True parameter in the terminal. This appears to be part of a development workflow automation for the Manim project.</file-summary></file>
      <file name="OpenMirroredDirectory.sublime-commands"><file-summary>This is a Sublime Text command configuration file in JSON format. It defines a single command that opens a mirrored directory in the finder. The command is named "open_mirrored_directory" and has a user-friendly caption "OpenMirroredDirectory: Open mirrored directory in finder". This file is part of the Sublime Text integration for the project, allowing users to access mirrored directories directly from the Sublime Text interface.</file-summary></file>
      <file name="manim_plugins.py"><declarations>
        
    </declarations>
    <dependencies>
        <external>
            sublime_plugin
            sublime
            os
            subprocess
            threading
            re
            time
        </external>
        <internal>
            
        </internal>
    </dependencies>
    <function-defs>
        <function name="get_command">
            <description>
                Generates a manim command based on the current file and cursor position
            </description>
            <args>
                view: sublime.View object
                window: sublime.Window object
            </args>
            <returns>
                Tuple of (command string, boolean for enter)
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                    StopIteration - When no matching classes are found
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="send_terminus_command">
            <description>
                Sends a command to the Terminus terminal
            </description>
            <args>
                command: string to send
                clear: boolean to clear terminal
                center: boolean to center output
                enter: boolean to send enter key
            </args>
            <returns>
            </returns>
            <side-effects>
                Modifies terminal state
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="find_terminus_sheet">
            <description>
                Finds an existing Terminus terminal sheet
            </description>
            <args>
            </args>
            <returns>
                Sheet object or None
            </returns>
            <side-effects>
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="ensure_terminus_tab_exists">
            <description>
                Ensures a Terminus terminal tab exists, creating one if necessary
            </description>
            <args>
            </args>
            <returns>
                Integer timeout value
            </returns>
            <side-effects>
                May create new window and terminal
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
        <function name="checkpoint_paste_wrapper">
            <description>
                Wraps selected text in a checkpoint_paste command
            </description>
            <args>
                view: sublime.View object
                arg_str: string of additional arguments
            </args>
            <returns>
            </returns>
            <side-effects>
                Modifies clipboard content
                Sends commands to terminal
            </side-effects>
            <errors-and-exceptions>
                <handled>
                </handled>
                <unhandled>
                </unhandled>
            </errors-and-exceptions>
        </function>
    </function-defs>
    <file-summary>
        This file implements Sublime Text commands for interacting with Manim animations. It includes functionality for running scenes, managing checkpoints, and handling terminal interactions through Terminus. The file contains both utility functions and Sublime Text command classes for various Manim-related operations.
    </file-summary></file>
    </directory>
  </directory>
</repository>